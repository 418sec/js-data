<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Settable.js.html":{"id":"Settable.js.html","title":"Source: Settable.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Settable.js import utils from './utils' /** * A base class which gives instances private properties. * * Typically you won't instantiate this class directly, but you may find it * useful as an abstract class for your own components. * * See {@link Settable.extend} for an example of using {@link Settable} as a * base class. * *```javascript * import {Settable} from 'js-data' * ``` * * @class Settable * @returns {Settable} A new {@link Settable} instance. * @since 3.0.0 */ export default function Settable () { const _props = {} Object.defineProperties(this, { /** * Get a private property of this instance. * * __Don't use the method unless you know what you're doing.__ * * @method Settable#_get * @param {string} key The property to retrieve. * @returns {*} The value of the property. * @since 3.0.0 */ _get: { value (key) { return utils.get(_props, key) } }, /** * Set a private property of this instance. * * __Don't use the method unless you know what you're doing.__ * * @method __Don't use the method unless you know what you're doing.__#_set * @param {(string|Object)} key The key or path to the property. Can also * pass in an object of key/value pairs, which will all be set on the instance. * @param {*} [value] The value to set. * @since 3.0.0 */ _set: { value (key, value) { return utils.set(_props, key, value) } }, /** * Unset a private property of this instance. * * __Don't use the method unless you know what you're doing.__ * * @method __Don't use the method unless you know what you're doing.__#_unset * @param {string} key The property to unset. * @since 3.0.0 */ _unset: { value (key) { return utils.unset(_props, key) } } }) } /** * Create a subclass of this Settable: * * @example &lt;caption&gt;Settable.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Settable } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomSettableClass extends Settable { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customSettable = new CustomSettableClass(); * console.log(customSettable.foo()); * console.log(CustomSettableClass.beep()); * * // Extend the class using alternate method. * const OtherSettableClass = Settable.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherSettable = new OtherSettableClass(); * console.log(otherSettable.foo()); * console.log(OtherSettableClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherSettableClass () { * Settable.call(this); * this.created_at = new Date().getTime(); * } * Settable.extend({ * constructor: AnotherSettableClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherSettable = new AnotherSettableClass(); * console.log(anotherSettable.created_at); * console.log(anotherSettable.foo()); * console.log(AnotherSettableClass.beep()); * * @method Settable.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Settable class. * @since 3.0.0 */ Settable.extend = utils.extend × Search results Close api.js-data.io • js-data.io "},"Mapper.js.html":{"id":"Mapper.js.html","title":"Source: Mapper.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Mapper.js import utils from './utils' import Component from './Component' import Record from './Record' import Schema from './Schema' import { Relation } from './relations' import { belongsTo, belongsToType, hasMany, hasManyType, hasOne, hasOneType } from './decorators' const DOMAIN = 'Mapper' const applyDefaultsHooks = [ 'beforeCreate', 'beforeCreateMany' ] const validatingHooks = [ 'beforeCreate', 'beforeCreateMany', 'beforeUpdate', 'beforeUpdateAll', 'beforeUpdateMany' ] const makeNotify = function (num) { return function (...args) { const opts = args[args.length - num] const op = opts.op this.dbg(op, ...args) if (applyDefaultsHooks.indexOf(op) !== -1 &amp;&amp; opts.applyDefaults !== false) { const schema = this.getSchema() if (schema &amp;&amp; schema.applyDefaults) { let toProcess = args[0] if (!utils.isArray(toProcess)) { toProcess = [toProcess] } toProcess.forEach((record) =&gt; { schema.applyDefaults(record) }) } } // Automatic validation if (validatingHooks.indexOf(op) !== -1 &amp;&amp; !opts.noValidate) { // Save current value of option const originalExistingOnly = opts.existingOnly // For updates, ignore required fields if they aren't present if (op.indexOf('beforeUpdate') === 0 &amp;&amp; opts.existingOnly === undefined) { opts.existingOnly = true } const errors = this.validate(args[op === 'beforeUpdate' ? 1 : 0], utils.pick(opts, ['existingOnly'])) // Restore option opts.existingOnly = originalExistingOnly // Abort lifecycle due to validation errors if (errors) { const err = new Error('validation failed') err.errors = errors return utils.reject(err) } } // Emit lifecycle event if (opts.notify || (opts.notify === undefined &amp;&amp; this.notify)) { setTimeout(() =&gt; { this.emit(op, ...args) }) } } } // These are the default implementations of all of the lifecycle hooks const notify = makeNotify(1) const notify2 = makeNotify(2) // This object provides meta information used by Mapper#crud to actually // execute each lifecycle method const LIFECYCLE_METHODS = { count: { defaults: [{}, {}], skip: true, types: [] }, destroy: { defaults: [{}, {}], skip: true, types: [] }, destroyAll: { defaults: [{}, {}], skip: true, types: [] }, find: { defaults: [undefined, {}], types: [] }, findAll: { defaults: [{}, {}], types: [] }, sum: { defaults: [undefined, {}, {}], skip: true, types: [] }, update: { adapterArgs (mapper, id, props, opts) { return [id, mapper.toJSON(props, opts), opts] }, beforeAssign: 1, defaults: [undefined, {}, {}], types: [] }, updateAll: { adapterArgs (mapper, props, query, opts) { return [mapper.toJSON(props, opts), query, opts] }, beforeAssign: 0, defaults: [{}, {}, {}], types: [] }, updateMany: { adapterArgs (mapper, records, opts) { return [records.map((record) =&gt; mapper.toJSON(record, opts)), opts] }, beforeAssign: 0, defaults: [[], {}], types: [] } } const MAPPER_DEFAULTS = { /** * Hash of registered adapters. Don't modify directly. Use * {@link Mapper#registerAdapter} instead. * * @default {} * @name Mapper#_adapters * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ _adapters: {}, /** * Whether {@link Mapper#beforeCreate} and {@link Mapper#beforeCreateMany} * should automatically receive default values according to the Mapper's schema. * * @default true * @name Mapper#applyDefaults * @since 3.0.0 * @type {boolean} */ applyDefaults: true, /** * Whether to augment {@link Mapper#recordClass} with ES5 getters and setters * according to the properties defined in {@link Mapper#schema}. This makes * possible validation and change tracking on individual properties * when using the dot (e.g. `user.name = \"Bob\"`) operator to modify a * property, and is `true` by default. * * @default true * @name Mapper#applySchema * @since 3.0.0 * @type {boolean} */ applySchema: true, /** * The name of the registered adapter that this Mapper should used by default. * * @default \"http\" * @name Mapper#defaultAdapter * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] * @type {string} */ defaultAdapter: 'http', /** * The field used as the unique identifier on records handled by this Mapper. * * @default id * @name Mapper#idAttribute * @since 3.0.0 * @type {string} */ idAttribute: 'id', /** * Whether records created from this mapper keep changeHistory on property changes. * * @default true * @name Mapper#keepChangeHistory * @since 3.0.0 * @type {boolean} */ keepChangeHistory: true, /** * Whether this Mapper should emit operational events. * * @default true * @name Mapper#notify * @since 3.0.0 * @type {boolean} */ notify: true, /** * Whether to skip validation when the Record instances are created. * * @default false * @name Mapper#noValidate * @since 3.0.0 * @type {boolean} */ noValidate: false, /** * Whether {@link Mapper#create}, {@link Mapper#createMany}, * {@link Mapper#update}, {@link Mapper#updateAll}, {@link Mapper#updateMany}, * {@link Mapper#find}, {@link Mapper#findAll}, {@link Mapper#destroy}, * {@link Mapper#destroyAll}, {@link Mapper#count}, and {@link Mapper#sum} * should return a raw result object that contains both the instance data * returned by the adapter _and_ metadata about the operation. * * The default is to NOT return the result object, and instead return just the * instance data. * * @default false * @name Mapper#raw * @since 3.0.0 * @type {boolean} */ raw: false, /** * Whether records created from this mapper automatically validate their properties * when their properties are modified. * * @default true * @name Mapper#validateOnSet * @since 3.0.0 * @type {boolean} */ validateOnSet: true } /** * The core of JSData's [ORM/ODM][orm] implementation. Given a minimum amout of * meta information about a resource, a Mapper can perform generic CRUD * operations against that resource. Apart from its configuration, a Mapper is * stateless. The particulars of various persistence layers have been abstracted * into adapters, which a Mapper uses to perform its operations. * * The term \"Mapper\" comes from the [Data Mapper Pattern][pattern] described in * Martin Fowler's [Patterns of Enterprise Application Architecture][book]. A * Data Mapper moves data between [in-memory object instances][record] and a * relational or document-based database. JSData's Mapper can work with any * persistence layer you can write an adapter for. * * _(\"Model\" is a heavily overloaded term and is avoided in this documentation * to prevent confusion.)_ * * [orm]: https://en.wikipedia.org/wiki/Object-relational_mapping * * @example * [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern * [book]: http://martinfowler.com/books/eaa.html * [record]: Record.html * // Import and instantiate * import { Mapper } from 'js-data'; * const UserMapper = new Mapper({ name: 'user' }); * * @example * // Define a Mapper using the Container component * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('user'); * * @class Mapper * @extends Component * @param {object} opts Configuration options. * @param {boolean} [opts.applySchema=true] See {@link Mapper#applySchema}. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @param {string} [opts.defaultAdapter=http] See {@link Mapper#defaultAdapter}. * @param {string} [opts.idAttribute=id] See {@link Mapper#idAttribute}. * @param {object} [opts.methods] See {@link Mapper#methods}. * @param {string} opts.name See {@link Mapper#name}. * @param {boolean} [opts.notify] See {@link Mapper#notify}. * @param {boolean} [opts.raw=false] See {@link Mapper#raw}. * @param {Function|boolean} [opts.recordClass] See {@link Mapper#recordClass}. * @param {Object|Schema} [opts.schema] See {@link Mapper#schema}. * @returns {Mapper} A new {@link Mapper} instance. * @see http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper\",\"Components of JSData: Mapper\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/modeling-your-data\",\"Modeling your data\"] */ function Mapper (opts) { utils.classCallCheck(this, Mapper) Component.call(this) opts || (opts = {}) // Prepare certain properties to be non-enumerable Object.defineProperties(this, { _adapters: { value: undefined, writable: true }, /** * The {@link Container} that holds this Mapper. __Do not modify.__ * * @name Mapper#lifecycleMethods * @since 3.0.0 * @type {Object} */ datastore: { value: undefined, writable: true }, /** * The meta information describing this Mapper's available lifecycle * methods. __Do not modify.__ * * @name Mapper#lifecycleMethods * @since 3.0.0 * @type {Object} */ lifecycleMethods: { value: LIFECYCLE_METHODS }, /** * Set to `false` to force the Mapper to work with POJO objects only. * * @example * // Use POJOs only. * import { Mapper, Record } from 'js-data'; * const UserMapper = new Mapper({ recordClass: false }); * UserMapper.recordClass // false; * const user = UserMapper.createRecord(); * user instanceof Record; // false * * @example * // Set to a custom class to have records wrapped in your custom class. * import { Mapper, Record } from 'js-data'; * // Custom class * class User { * constructor (props = {}) { * for (var key in props) { * if (props.hasOwnProperty(key)) { * this[key] = props[key]; * } * } * } * } * const UserMapper = new Mapper({ recordClass: User }); * UserMapper.recordClass; // function User() {} * const user = UserMapper.createRecord(); * user instanceof Record; // false * user instanceof User; // true * * * @example * // Extend the {@link Record} class. * import { Mapper, Record } from 'js-data'; * // Custom class * class User extends Record { * constructor () { * super(props); * } * } * const UserMapper = new Mapper({ recordClass: User }); * UserMapper.recordClass; // function User() {} * const user = UserMapper.createRecord(); * user instanceof Record; // true * user instanceof User; // true * * @name Mapper#recordClass * @default {@link Record} * @see Record * @since 3.0.0 */ recordClass: { value: undefined, writable: true }, /** * This Mapper's {@link Schema}. * * @example &lt;caption&gt;Mapper#schema&lt;/caption&gt; * const JSData = require('js-data'); * const { Mapper } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const UserMapper = new Mapper({ * name: 'user', * schema: { * properties: { * id: { type: 'number' }, * first: { type: 'string', track: true }, * last: { type: 'string', track: true }, * role: { type: 'string', track: true, required: true }, * age: { type: 'integer', track: true }, * is_active: { type: 'number' } * } * } * }); * const user = UserMapper.createRecord({ * id: 1, * name: 'John', * role: 'admin' * }); * user.on('change', function (user, changes) { * console.log(changes); * }); * user.on('change:role', function (user, value) { * console.log('change:role - ' + value); * }); * user.role = 'owner'; * * @name Mapper#schema * @see Schema * @since 3.0.0 * @type {Schema} */ schema: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(this, opts) // Fill in any missing options with the defaults utils.fillIn(this, utils.copy(MAPPER_DEFAULTS)) /** * The name for this Mapper. This is the minimum amount of meta information * required for a Mapper to be able to execute CRUD operations for a * Resource. * * @name Mapper#name * @since 3.0.0 * @type {string} */ if (!this.name) { throw utils.err(`new ${DOMAIN}`, 'opts.name')(400, 'string', this.name) } // Setup schema, with an empty default schema if necessary if (this.schema) { this.schema.type || (this.schema.type = 'object') if (!(this.schema instanceof Schema)) { this.schema = new Schema(this.schema || { type: 'object' }) } } // Create a subclass of Record that's tied to this Mapper if (this.recordClass === undefined) { const superClass = Record this.recordClass = superClass.extend({ constructor: (function Record () { var subClass = function Record (props, opts) { utils.classCallCheck(this, subClass) superClass.call(this, props, opts) } return subClass })() }) } if (this.recordClass) { this.recordClass.mapper = this /** * Functions that should be added to the prototype of {@link Mapper#recordClass}. * * @name Mapper#methods * @since 3.0.0 * @type {Object} */ if (utils.isObject(this.methods)) { utils.addHiddenPropsToTarget(this.recordClass.prototype, this.methods) } // We can only apply the schema to the prototype of this.recordClass if the // class extends Record if (Record.prototype.isPrototypeOf(Object.create(this.recordClass.prototype)) &amp;&amp; this.schema &amp;&amp; this.schema.apply &amp;&amp; this.applySchema) { this.schema.apply(this.recordClass.prototype) } } } export default Component.extend({ constructor: Mapper, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCount * @param {object} query The `query` argument passed to {@link Mapper#count}. * @param {object} opts The `opts` argument passed to {@link Mapper#count}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCount: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreate * @param {object} props The `props` argument passed to {@link Mapper#create}. * @param {object} opts The `opts` argument passed to {@link Mapper#create}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterCreateMany * @param {array} records The `records` argument passed to {@link Mapper#createMany}. * @param {object} opts The `opts` argument passed to {@link Mapper#createMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterCreateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {object} opts The `opts` argument passed to {@link Mapper#destroy}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroy: notify2, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterDestroyAll * @param {*} data The `data` returned by the adapter. * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterDestroyAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {object} opts The `opts` argument passed to {@link Mapper#find}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFind: notify2, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterFindAll * @param {object} query The `query` argument passed to {@link Mapper#findAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#findAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterFindAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#afterSum * @param {object} query The `query` argument passed to {@link Mapper#sum}. * @param {object} opts The `opts` argument passed to {@link Mapper#sum}. * @param {*} result The result, if any. * @since 3.0.0 */ afterSum: notify2, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {object} opts The `opts` argument passed to {@link Mapper#update}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdate: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateAll * @param {object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateAll: notify2, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#afterUpdateMany * @param {array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @param {*} result The result, if any. * @since 3.0.0 */ afterUpdateMany: notify2, /** * Mapper lifecycle hook called by {@link Mapper#create}. If this method * returns a promise then {@link Mapper#create} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreate * @param {object} props The `props` argument passed to {@link Mapper#create}. * @param {object} opts The `opts` argument passed to {@link Mapper#create}. * @since 3.0.0 */ beforeCreate: notify, /** * Mapper lifecycle hook called by {@link Mapper#createMany}. If this method * returns a promise then {@link Mapper#createMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCreateMany * @param {array} records The `records` argument passed to {@link Mapper#createMany}. * @param {object} opts The `opts` argument passed to {@link Mapper#createMany}. * @since 3.0.0 */ beforeCreateMany: notify, /** * Mapper lifecycle hook called by {@link Mapper#count}. If this method * returns a promise then {@link Mapper#count} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeCount * @param {object} query The `query` argument passed to {@link Mapper#count}. * @param {object} opts The `opts` argument passed to {@link Mapper#count}. * @since 3.0.0 */ beforeCount: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroy}. If this method * returns a promise then {@link Mapper#destroy} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroy * @param {(string|number)} id The `id` argument passed to {@link Mapper#destroy}. * @param {object} opts The `opts` argument passed to {@link Mapper#destroy}. * @since 3.0.0 */ beforeDestroy: notify, /** * Mapper lifecycle hook called by {@link Mapper#destroyAll}. If this method * returns a promise then {@link Mapper#destroyAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeDestroyAll * @param {query} query The `query` argument passed to {@link Mapper#destroyAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#destroyAll}. * @since 3.0.0 */ beforeDestroyAll: notify, /** * Mappers lifecycle hook called by {@link Mapper#find}. If this method * returns a promise then {@link Mapper#find} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFind * @param {(string|number)} id The `id` argument passed to {@link Mapper#find}. * @param {object} opts The `opts` argument passed to {@link Mapper#find}. * @since 3.0.0 */ beforeFind: notify, /** * Mapper lifecycle hook called by {@link Mapper#findAll}. If this method * returns a promise then {@link Mapper#findAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeFindAll * @param {object} query The `query` argument passed to {@link Mapper#findAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#findAll}. * @since 3.0.0 */ beforeFindAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#sum}. If this method * returns a promise then {@link Mapper#sum} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeSum * @param {string} field The `field` argument passed to {@link Mapper#sum}. * @param {object} query The `query` argument passed to {@link Mapper#sum}. * @param {object} opts The `opts` argument passed to {@link Mapper#sum}. * @since 3.0.0 */ beforeSum: notify, /** * Mapper lifecycle hook called by {@link Mapper#update}. If this method * returns a promise then {@link Mapper#update} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdate * @param {(string|number)} id The `id` argument passed to {@link Mapper#update}. * @param {props} props The `props` argument passed to {@link Mapper#update}. * @param {object} opts The `opts` argument passed to {@link Mapper#update}. * @since 3.0.0 */ beforeUpdate: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateAll}. If this method * returns a promise then {@link Mapper#updateAll} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateAll * @param {object} props The `props` argument passed to {@link Mapper#updateAll}. * @param {object} query The `query` argument passed to {@link Mapper#updateAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#updateAll}. * @since 3.0.0 */ beforeUpdateAll: notify, /** * Mapper lifecycle hook called by {@link Mapper#updateMany}. If this method * returns a promise then {@link Mapper#updateMany} will wait for the promise * to resolve before continuing. * * @method Mapper#beforeUpdateMany * @param {array} records The `records` argument passed to {@link Mapper#updateMany}. * @param {object} opts The `opts` argument passed to {@link Mapper#updateMany}. * @since 3.0.0 */ beforeUpdateMany: notify, /** * This method is called at the end of most lifecycle methods. It does the * following: * * 1. If `opts.raw` is `true`, add this Mapper's configuration to the `opts` * argument as metadata for the operation. * 2. Wrap the result data appropriately using {@link Mapper#wrap}, which * calls {@link Mapper#createRecord}. * * @method Mapper#_end * @private * @since 3.0.0 */ _end (result, opts, skip) { if (opts.raw) { utils._(result, opts) } if (skip) { return result } let _data = opts.raw ? result.data : result if (_data &amp;&amp; utils.isFunction(this.wrap)) { _data = this.wrap(_data, opts) if (opts.raw) { result.data = _data } else { result = _data } } return result }, /** * Define a belongsTo relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * PostMapper.belongsTo(UserMapper, { * // post.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to post records at \"post.user\" * localField: 'user' * }); * * CommentMapper.belongsTo(UserMapper, { * // comment.user_id points to user.id * foreignKey: 'user_id' * // user records will be attached to comment records at \"comment.user\" * localField: 'user' * }); * CommentMapper.belongsTo(PostMapper, { * // comment.post_id points to post.id * foreignKey: 'post_id' * // post records will be attached to comment records at \"comment.post\" * localField: 'post' * }); * * @method Mapper#belongsTo * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ belongsTo (relatedMapper, opts) { return belongsTo(relatedMapper, opts)(this) }, /** * Select records according to the `query` argument and return the count. * * {@link Mapper#beforeCount} will be called before calling the adapter. * {@link Mapper#afterCount} will be called after calling the adapter. * * @example * // Get the number of published blog posts * PostMapper.count({ status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished); // e.g. 45 * }); * * @method Mapper#count * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. Refer to the `count` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the count of the selected records. * @since 3.0.0 */ count (query, opts) { return this.crud('count', query, opts) }, /** * Fired during {@link Mapper#create}. See * {@link Mapper~beforeCreateListener} for how to listen for this event. * * @event Mapper#beforeCreate * @see Mapper~beforeCreateListener * @see Mapper#create */ /** * Callback signature for the {@link Mapper#event:beforeCreate} event. * * @example * function onBeforeCreate (props, opts) { * // do something * } * store.on('beforeCreate', onBeforeCreate); * * @callback Mapper~beforeCreateListener * @param {object} props The `props` argument passed to {@link Mapper#beforeCreate}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeCreate}. * @see Mapper#event:beforeCreate * @see Mapper#create * @since 3.0.0 */ /** * Fired during {@link Mapper#create}. See * {@link Mapper~afterCreateListener} for how to listen for this event. * * @event Mapper#afterCreate * @see Mapper~afterCreateListener * @see Mapper#create */ /** * Callback signature for the {@link Mapper#event:afterCreate} event. * * @example * function onAfterCreate (props, opts, result) { * // do something * } * store.on('afterCreate', onAfterCreate); * * @callback Mapper~afterCreateListener * @param {object} props The `props` argument passed to {@link Mapper#afterCreate}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterCreate}. * @param {object} result The `result` argument passed to {@link Mapper#afterCreate}. * @see Mapper#event:afterCreate * @see Mapper#create * @since 3.0.0 */ /** * Create and save a new the record using the provided `props`. * * {@link Mapper#beforeCreate} will be called before calling the adapter. * {@link Mapper#afterCreate} will be called after calling the adapter. * * @example * // Create and save a new blog post * PostMapper.create({ * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post); // { id: 1234, status: 'draft', ... } * }); * * @fires Mapper#beforeCreate * @fires Mapper#afterCreate * @method Mapper#create * @param {object} props The properties for the new record. * @param {object} [opts] Configuration options. Refer to the `create` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `props` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#create} * or {@link Mapper#createMany} call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created record. * @since 3.0.0 */ create (props, opts) { // Default values for arguments props || (props = {}) opts || (opts = {}) const originalRecord = props let parentRelationMap = {} let adapterResponse = {} // Fill in \"opts\" with the Mapper's configuration utils._(opts, this) opts.adapter = this.getAdapterName(opts) opts.op = 'beforeCreate' return this._runHook(opts.op, props, opts).then((props) =&gt; { opts.with || (opts.with = []) return this._createParentRecordIfRequired(props, opts) }).then((relationMap) =&gt; { parentRelationMap = relationMap }).then(() =&gt; { opts.op = 'create' return this._invokeAdapterMethod(opts.op, props, opts) }).then((result) =&gt; { adapterResponse = result }).then(() =&gt; { const createdProps = opts.raw ? adapterResponse.data : adapterResponse return this._createOrAssignChildRecordIfRequired(createdProps, { opts, parentRelationMap, originalProps: props }) }).then((createdProps) =&gt; { return this._commitChanges(originalRecord, createdProps) }).then((record) =&gt; { if (opts.raw) { adapterResponse.data = record } else { adapterResponse = record } const result = this._end(adapterResponse, opts) opts.op = 'afterCreate' return this._runHook(opts.op, props, opts, result) }) }, _commitChanges (recordOrRecords, newValues) { if (utils.isArray(recordOrRecords)) { return recordOrRecords.map((record, i) =&gt; this._commitChanges(record, newValues[i])) } utils.set(recordOrRecords, newValues, { silent: true }) if (utils.isFunction(recordOrRecords.commit)) { recordOrRecords.commit() } return recordOrRecords }, /** * Use {@link Mapper#createRecord} instead. * @deprecated * @method Mapper#createInstance * @param {Object|Array} props See {@link Mapper#createRecord}. * @param {object} [opts] See {@link Mapper#createRecord}. * @returns {Object|Array} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ createInstance (props, opts) { return this.createRecord(props, opts) }, /** * Creates parent record for relation types like BelongsTo or HasMany with localKeys * in order to satisfy foreignKey dependency (so called child records). * @param {object} props See {@link Mapper#create}. * @param {object} opts See {@link Mapper#create}. * @returns {Object} cached parent records map * @see Mapper#create * @since 3.0.0 */ _createParentRecordIfRequired (props, opts) { const tasks = [] const relations = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { if (!def.isRequiresParentId() || !def.getLocalField(props)) { return } optsCopy.raw = false relations.push(def) tasks.push(def.createParentRecord(props, optsCopy)) }) return utils.Promise.all(tasks).then(records =&gt; { return relations.reduce((map, relation, index) =&gt; { relation.setLocalField(map, records[index]) return map }, {}) }) }, /** * Creates child record for relation types like HasOne or HasMany with foreignKey * in order to satisfy foreignKey dependency (so called parent records). * @param {object} props See {@link Mapper#create}. * @param {object} context contains collected information. * @param {object} context.opts See {@link Mapper#create}. * @param {object} context.parentRelationMap contains parent records map * @param {object} context.originalProps contains data passed into {@link Mapper#create} method * @return {Promise} updated props * @see Mapper#create * @since 3.0.0 */ _createOrAssignChildRecordIfRequired (props, context) { const tasks = [] utils.forEachRelation(this, context.opts, (def, optsCopy) =&gt; { const relationData = def.getLocalField(context.originalProps) if (!relationData) { return } optsCopy.raw = false // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.isRequiresChildId()) { tasks.push(def.createChildRecord(props, relationData, optsCopy)) } else if (def.isRequiresParentId()) { const parent = def.getLocalField(context.parentRelationMap) if (parent) { def.setLocalField(props, parent) } } }) return utils.Promise.all(tasks) .then(() =&gt; props) }, /** * Fired during {@link Mapper#createMany}. See * {@link Mapper~beforeCreateManyListener} for how to listen for this event. * * @event Mapper#beforeCreateMany * @see Mapper~beforeCreateManyListener * @see Mapper#createMany */ /** * Callback signature for the {@link Mapper#event:beforeCreateMany} event. * * @example * function onBeforeCreateMany (records, opts) { * // do something * } * store.on('beforeCreateMany', onBeforeCreateMany); * * @callback Mapper~beforeCreateManyListener * @param {object} records The `records` argument received by {@link Mapper#beforeCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeCreateMany}. * @see Mapper#event:beforeCreateMany * @see Mapper#createMany * @since 3.0.0 */ /** * Fired during {@link Mapper#createMany}. See * {@link Mapper~afterCreateManyListener} for how to listen for this event. * * @event Mapper#afterCreateMany * @see Mapper~afterCreateManyListener * @see Mapper#createMany */ /** * Callback signature for the {@link Mapper#event:afterCreateMany} event. * * @example * function onAfterCreateMany (records, opts, result) { * // do something * } * store.on('afterCreateMany', onAfterCreateMany); * * @callback Mapper~afterCreateManyListener * @param {object} records The `records` argument received by {@link Mapper#afterCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterCreateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterCreateMany}. * @see Mapper#event:afterCreateMany * @see Mapper#createMany * @since 3.0.0 */ /** * Given an array of records, batch create them via an adapter. * * {@link Mapper#beforeCreateMany} will be called before calling the adapter. * {@link Mapper#afterCreateMany} will be called after calling the adapter. * * @example * // Create and save several new blog posts * PostMapper.createMany([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]); // { id: 1234, status: 'draft', ... } * console.log(posts[1]); // { id: 1235, status: 'draft', ... } * }); * * @fires Mapper#beforeCreate * @fires Mapper#afterCreate * @method Mapper#createMany * @param {Record[]} records Array of records to be created in one batch. * @param {object} [opts] Configuration options. Refer to the `createMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to create in a cascading * create if `records` contains nested relations. NOT performed in a * transaction. Each nested create will result in another {@link Mapper#createMany} * call. * @param {string[]} [opts.pass=[]] Relations to send to the adapter as part * of the payload. Normally relations are not sent. * @returns {Promise} Resolves with the created records. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ createMany (records, opts) { // Default values for arguments records || (records = []) opts || (opts = {}) const originalRecords = records let adapterResponse // Fill in \"opts\" with the Mapper's configuration utils._(opts, this) opts.adapter = this.getAdapterName(opts) // beforeCreateMany lifecycle hook opts.op = 'beforeCreateMany' return this._runHook(opts.op, records, opts).then((records) =&gt; { // Deep pre-create belongsTo relations const belongsToRelationData = {} opts.with || (opts.with = []) let tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = records .map((record) =&gt; def.getLocalField(record)) .filter(Boolean) if (def.type === belongsToType &amp;&amp; relationData.length === records.length) { // Create belongsTo relation first because we need a generated id to // attach to the child optsCopy.raw = false tasks.push(def.createLinked(relationData, optsCopy).then((relatedRecords) =&gt; { records.forEach((record, i) =&gt; def.setForeignKey(record, relatedRecords[i])) }).then((relatedRecords) =&gt; { def.setLocalField(belongsToRelationData, relatedRecords) })) } }) return utils.Promise.all(tasks).then(() =&gt; { opts.op = 'createMany' return this._invokeAdapterMethod(opts.op, records, opts) }).then((result) =&gt; { adapterResponse = result }).then(() =&gt; { const createdRecordsData = opts.raw ? adapterResponse.data : adapterResponse // Deep post-create hasOne relations tasks = [] utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = records .map((record) =&gt; def.getLocalField(record)) .filter(Boolean) if (relationData.length !== records.length) { return } optsCopy.raw = false const belongsToData = def.getLocalField(belongsToRelationData) let task // Create hasMany and hasOne after the main create because we needed // a generated id to attach to these items if (def.type === hasManyType) { // Not supported this.log('warn', 'deep createMany of hasMany type not supported!') } else if (def.type === hasOneType) { createdRecordsData.forEach((createdRecordData, i) =&gt; { def.setForeignKey(createdRecordData, relationData[i]) }) task = def.getRelation().createMany(relationData, optsCopy).then((relatedData) =&gt; { createdRecordsData.forEach((createdRecordData, i) =&gt; { def.setLocalField(createdRecordData, relatedData[i]) }) }) } else if (def.type === belongsToType &amp;&amp; belongsToData &amp;&amp; belongsToData.length === createdRecordsData.length) { createdRecordsData.forEach((createdRecordData, i) =&gt; { def.setLocalField(createdRecordData, belongsToData[i]) }) } if (task) { tasks.push(task) } }) return utils.Promise.all(tasks).then(() =&gt; { return this._commitChanges(originalRecords, createdRecordsData) }) }) }).then((records) =&gt; { if (opts.raw) { adapterResponse.data = records } else { adapterResponse = records } const result = this._end(adapterResponse, opts) opts.op = 'afterCreateMany' return this._runHook(opts.op, records, opts, result) }) }, /** * Create an unsaved, uncached instance of this Mapper's * {@link Mapper#recordClass}. * * Returns `props` if `props` is already an instance of * {@link Mapper#recordClass}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example * // Create empty unsaved record instance * const post = PostMapper.createRecord(); * * @example * // Create an unsaved record instance with inital properties * const post = PostMapper.createRecord({ * title: 'Modeling your data', * status: 'draft' * }); * * @example * // Create a record instance that corresponds to a saved record * const post = PostMapper.createRecord({ * // JSData thinks this record has been saved if it has a primary key * id: 1234, * title: 'Modeling your data', * status: 'draft' * }); * * @example * // Create record instances from an array * const posts = PostMapper.createRecord([{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]); * * @example * // Records are validated by default * import { Mapper } from 'js-data'; * const PostMapper = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }); * try { * const post = PostMapper.createRecord({ * title: 1234, * }); * } catch (err) { * console.log(err.errors); // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] * } * * @example * // Skip validation * import { Mapper } from 'js-data'; * const PostMapper = new Mapper({ * name: 'post', * schema: { properties: { title: { type: 'string' } } } * }); * const post = PostMapper.createRecord({ * title: 1234, * }, { noValidate: true }); * console.log(post.isValid()); // false * * @method Mapper#createRecord * @param {Object|Object[]} props The properties for the Record instance or an * array of property objects for the Record instances. * @param {object} [opts] Configuration options. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @returns {Record|Record[]} The Record instance or Record instances. * @since 3.0.0 */ createRecord (props, opts) { props || (props = {}) if (utils.isArray(props)) { return props.map((_props) =&gt; this.createRecord(_props, opts)) } if (!utils.isObject(props)) { throw utils.err(`${DOMAIN}#createRecord`, 'props')(400, 'array or object', props) } if (this.relationList) { this.relationList.forEach(function (def) { def.ensureLinkedDataHasProperType(props, opts) }) } const RecordCtor = this.recordClass return (!RecordCtor || props instanceof RecordCtor) ? props : new RecordCtor(props, opts) }, /** * Lifecycle invocation method. You probably won't call this method directly. * * @method Mapper#crud * @param {string} method Name of the lifecycle method to invoke. * @param {...*} args Arguments to pass to the lifecycle method. * @returns {Promise} * @since 3.0.0 */ crud (method, ...args) { const config = this.lifecycleMethods[method] if (!config) { throw utils.err(`${DOMAIN}#crud`, method)(404, 'method') } const upper = `${method.charAt(0).toUpperCase()}${method.substr(1)}` const before = `before${upper}` const after = `after${upper}` let op, adapter // Default values for arguments config.defaults.forEach((value, i) =&gt; { if (args[i] === undefined) { args[i] = utils.copy(value) } }) const opts = args[args.length - 1] // Fill in \"opts\" with the Mapper's configuration utils._(opts, this) adapter = opts.adapter = this.getAdapterName(opts) // before lifecycle hook op = opts.op = before return utils.resolve(this[op](...args)).then((_value) =&gt; { if (args[config.beforeAssign] !== undefined) { // Allow for re-assignment from lifecycle hook args[config.beforeAssign] = _value === undefined ? args[config.beforeAssign] : _value } // Now delegate to the adapter op = opts.op = method args = config.adapterArgs ? config.adapterArgs(this, ...args) : args this.dbg(op, ...args) return utils.resolve(this.getAdapter(adapter)[op](this, ...args)) }).then((result) =&gt; { // force noValidate on find/findAll const noValidate = /find/.test(op) || opts.noValidate const _opts = Object.assign({}, opts, { noValidate }) result = this._end(result, _opts, !!config.skip) args.push(result) // after lifecycle hook op = opts.op = after return utils.resolve(this[op](...args)).then((_result) =&gt; { // Allow for re-assignment from lifecycle hook return _result === undefined ? result : _result }) }) }, /** * Fired during {@link Mapper#destroy}. See * {@link Mapper~beforeDestroyListener} for how to listen for this event. * * @event Mapper#beforeDestroy * @see Mapper~beforeDestroyListener * @see Mapper#destroy */ /** * Callback signature for the {@link Mapper#event:beforeDestroy} event. * * @example * function onBeforeDestroy (id, opts) { * // do something * } * store.on('beforeDestroy', onBeforeDestroy); * * @callback Mapper~beforeDestroyListener * @param {string|number} id The `id` argument passed to {@link Mapper#beforeDestroy}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeDestroy}. * @see Mapper#event:beforeDestroy * @see Mapper#destroy * @since 3.0.0 */ /** * Fired during {@link Mapper#destroy}. See * {@link Mapper~afterDestroyListener} for how to listen for this event. * * @event Mapper#afterDestroy * @see Mapper~afterDestroyListener * @see Mapper#destroy */ /** * Callback signature for the {@link Mapper#event:afterDestroy} event. * * @example * function onAfterDestroy (id, opts, result) { * // do something * } * store.on('afterDestroy', onAfterDestroy); * * @callback Mapper~afterDestroyListener * @param {string|number} id The `id` argument passed to {@link Mapper#afterDestroy}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterDestroy}. * @param {object} result The `result` argument passed to {@link Mapper#afterDestroy}. * @see Mapper#event:afterDestroy * @see Mapper#destroy * @since 3.0.0 */ /** * Using an adapter, destroy the record with the given primary key. * * {@link Mapper#beforeDestroy} will be called before destroying the record. * {@link Mapper#afterDestroy} will be called after destroying the record. * * @example * // Destroy a specific blog post * PostMapper.destroy(1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }); * * @example * // Get full response * PostMapper.destroy(1234, { raw: true }).then((result) =&gt; { * console.log(result.deleted); e.g. 1 * console.log(...); // etc., more metadata can be found on the result * }); * * @fires Mapper#beforeDestroy * @fires Mapper#afterDestroy * @method Mapper#destroy * @param {(string|number)} id The primary key of the record to destroy. * @param {object} [opts] Configuration options. Refer to the `destroy` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the record has been destroyed. Resolves * even if no record was found to be destroyed. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ destroy (id, opts) { return this.crud('destroy', id, opts) }, /** * Fired during {@link Mapper#destroyAll}. See * {@link Mapper~beforeDestroyAllListener} for how to listen for this event. * * @event Mapper#beforeDestroyAll * @see Mapper~beforeDestroyAllListener * @see Mapper#destroyAll */ /** * Callback signature for the {@link Mapper#event:beforeDestroyAll} event. * * @example * function onBeforeDestroyAll (query, opts) { * // do something * } * store.on('beforeDestroyAll', onBeforeDestroyAll); * * @callback Mapper~beforeDestroyAllListener * @param {object} query The `query` argument passed to {@link Mapper#beforeDestroyAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeDestroyAll}. * @see Mapper#event:beforeDestroyAll * @see Mapper#destroyAll * @since 3.0.0 */ /** * Fired during {@link Mapper#destroyAll}. See * {@link Mapper~afterDestroyAllListener} for how to listen for this event. * * @event Mapper#afterDestroyAll * @see Mapper~afterDestroyAllListener * @see Mapper#destroyAll */ /** * Callback signature for the {@link Mapper#event:afterDestroyAll} event. * * @example * function onAfterDestroyAll (query, opts, result) { * // do something * } * store.on('afterDestroyAll', onAfterDestroyAll); * * @callback Mapper~afterDestroyAllListener * @param {object} query The `query` argument passed to {@link Mapper#afterDestroyAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterDestroyAll}. * @param {object} result The `result` argument passed to {@link Mapper#afterDestroyAll}. * @see Mapper#event:afterDestroyAll * @see Mapper#destroyAll * @since 3.0.0 */ /** * Destroy the records selected by `query` via an adapter. If no `query` is * provided then all records will be destroyed. * * {@link Mapper#beforeDestroyAll} will be called before destroying the records. * {@link Mapper#afterDestroyAll} will be called after destroying the records. * * @example * // Destroy all blog posts * PostMapper.destroyAll().then(() =&gt; { * // All blog posts have been destroyed * }); * * @example * // Destroy all \"draft\" blog posts * PostMapper.destroyAll({ status: 'draft' }).then(() =&gt; { * // All \"draft\" blog posts have been destroyed * }); * * @example * // Get full response * const query = null; * const options = { raw: true }; * PostMapper.destroyAll(query, options).then((result) =&gt; { * console.log(result.deleted); e.g. 14 * console.log(...); // etc., more metadata can be found on the result * }); * * @fires Mapper#beforeDestroyAll * @fires Mapper#afterDestroyAll * @method Mapper#destroyAll * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. Refer to the `destroyAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves when the records have been destroyed. Resolves * even if no records were found to be destroyed. * @see query * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ destroyAll (query, opts) { return this.crud('destroyAll', query, opts) }, /** * Fired during {@link Mapper#find}. See * {@link Mapper~beforeFindListener} for how to listen for this event. * * @event Mapper#beforeFind * @see Mapper~beforeFindListener * @see Mapper#find */ /** * Callback signature for the {@link Mapper#event:beforeFind} event. * * @example * function onBeforeFind (id, opts) { * // do something * } * store.on('beforeFind', onBeforeFind); * * @callback Mapper~beforeFindListener * @param {string|number} id The `id` argument passed to {@link Mapper#beforeFind}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeFind}. * @see Mapper#event:beforeFind * @see Mapper#find * @since 3.0.0 */ /** * Fired during {@link Mapper#find}. See * {@link Mapper~afterFindListener} for how to listen for this event. * * @event Mapper#afterFind * @see Mapper~afterFindListener * @see Mapper#find */ /** * Callback signature for the {@link Mapper#event:afterFind} event. * * @example * function onAfterFind (id, opts, result) { * // do something * } * store.on('afterFind', onAfterFind); * * @callback Mapper~afterFindListener * @param {string|number} id The `id` argument passed to {@link Mapper#afterFind}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterFind}. * @param {object} result The `result` argument passed to {@link Mapper#afterFind}. * @see Mapper#event:afterFind * @see Mapper#find * @since 3.0.0 */ /** * Retrieve via an adapter the record with the given primary key. * * {@link Mapper#beforeFind} will be called before calling the adapter. * {@link Mapper#afterFind} will be called after calling the adapter. * * @example * PostMapper.find(1).then((post) =&gt; { * console.log(post); // { id: 1, ...} * }); * * @example * // Get full response * PostMapper.find(1, { raw: true }).then((result) =&gt; { * console.log(result.data); // { id: 1, ...} * console.log(result.found); // 1 * console.log(...); // etc., more metadata can be found on the result * }); * * @fires Mapper#beforeFind * @fires Mapper#afterFind * @method Mapper#find * @param {(string|number)} id The primary key of the record to retrieve. * @param {object} [opts] Configuration options. Refer to the `find` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found record. Resolves with * `undefined` if no record was found. * @see http://www.js-data.io/v3.0/docs/reading-data * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/reading-data\",\"Reading data\"] */ find (id, opts) { return this.crud('find', id, opts) }, /** * Fired during {@link Mapper#findAll}. See * {@link Mapper~beforeFindAllListener} for how to listen for this event. * * @event Mapper#beforeFindAll * @see Mapper~beforeFindAllListener * @see Mapper#findAll */ /** * Callback signature for the {@link Mapper#event:beforeFindAll} event. * * @example * function onBeforeFindAll (query, opts) { * // do something * } * store.on('beforeFindAll', onBeforeFindAll); * * @callback Mapper~beforeFindAllListener * @param {object} query The `query` argument passed to {@link Mapper#beforeFindAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeFindAll}. * @see Mapper#event:beforeFindAll * @see Mapper#findAll * @since 3.0.0 */ /** * Fired during {@link Mapper#findAll}. See * {@link Mapper~afterFindAllListener} for how to listen for this event. * * @event Mapper#afterFindAll * @see Mapper~afterFindAllListener * @see Mapper#findAll */ /** * Callback signature for the {@link Mapper#event:afterFindAll} event. * * @example * function onAfterFindAll (query, opts, result) { * // do something * } * store.on('afterFindAll', onAfterFindAll); * * @callback Mapper~afterFindAllListener * @param {object} query The `query` argument passed to {@link Mapper#afterFindAll}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterFindAll}. * @param {object} result The `result` argument passed to {@link Mapper#afterFindAll}. * @see Mapper#event:afterFindAll * @see Mapper#findAll * @since 3.0.0 */ /** * Using the `query` argument, select records to retrieve via an adapter. * * {@link Mapper#beforeFindAll} will be called before calling the adapter. * {@link Mapper#afterFindAll} will be called after calling the adapter. * * @example * // Find all \"published\" blog posts * PostMapper.findAll({ status: 'published' }).then((posts) =&gt; { * console.log(posts); // [{ id: 1, status: 'published', ...}, ...] * }); * * @example * // Get full response * PostMapper.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { * console.log(result.data); // [{ id: 1, status: 'published', ...}, ...] * console.log(result.found); // e.g. 13 * console.log(...); // etc., more metadata can be found on the result * }); * * @fires Mapper#beforeFindAll * @fires Mapper#afterFindAll * @method Mapper#findAll * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. Refer to the `findAll` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @param {string[]} [opts.with=[]] Relations to eager load in the request. * @returns {Promise} Resolves with the found records, if any. * @see query * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/reading-data\",\"Reading data\"] */ findAll (query, opts) { return this.crud('findAll', query, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Mapper#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ getAdapter (name) { this.dbg('getAdapter', 'name:', name) const adapter = this.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return this.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Mapper#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || opts.defaultAdapter }, /** * Get the object of registered adapters for this Mapper. * * @method Mapper#getAdapters * @returns {Object} {@link Mapper#_adapters} * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ getAdapters () { return this._adapters }, /** * Returns this Mapper's {@link Schema}. * * @method Mapper#getSchema * @returns {Schema} This Mapper's {@link Schema}. * @see Mapper#schema * @since 3.0.0 */ getSchema () { return this.schema }, /** * Defines a hasMany relationship. Only useful if you're managing your * Mappers manually and not using a Container or DataStore component. * * @example * UserMapper.hasMany(PostMapper, { * // post.user_id points to user.id * foreignKey: 'user_id' * // post records will be attached to user records at \"user.posts\" * localField: 'posts' * }); * * @method Mapper#hasMany * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasMany (relatedMapper, opts) { return hasMany(relatedMapper, opts)(this) }, /** * Defines a hasOne relationship. Only useful if you're managing your Mappers * manually and not using a {@link Container} or {@link DataStore} component. * * @example * UserMapper.hasOne(ProfileMapper, { * // profile.user_id points to user.id * foreignKey: 'user_id' * // profile records will be attached to user records at \"user.profile\" * localField: 'profile' * }); * * @method Mapper#hasOne * @see http://www.js-data.io/v3.0/docs/relations * @since 3.0.0 */ hasOne (relatedMapper, opts) { return hasOne(relatedMapper, opts)(this) }, /** * Return whether `record` is an instance of this Mapper's recordClass. * * @example * const post = PostMapper.createRecord(); * * console.log(PostMapper.is(post)); // true * // Equivalent to what's above * console.log(post instanceof PostMapper.recordClass); // true * * @method Mapper#is * @param {Object|Record} record The record to check. * @returns {boolean} Whether `record` is an instance of this Mapper's * {@link Mapper#recordClass}. * @since 3.0.0 */ is (record) { const recordClass = this.recordClass return recordClass ? record instanceof recordClass : false }, /** * Register an adapter on this Mapper under the given name. * * @method Mapper#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for this Mapper. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ registerAdapter (name, adapter, opts) { opts || (opts = {}) this.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { this.defaultAdapter = name } }, _runHook (hookName, ...hookArgs) { const defaultValueIndex = hookName.indexOf('after') === 0 ? hookArgs.length - 1 : 0 return utils.resolve(this[hookName](...hookArgs)) .then((overridenResult) =&gt; overridenResult === undefined ? hookArgs[defaultValueIndex] : overridenResult) }, _invokeAdapterMethod (method, propsOrRecords, opts) { const conversionOptions = { with: opts.pass || [] } let object this.dbg(opts.op, propsOrRecords, opts) if (utils.isArray(propsOrRecords)) { object = propsOrRecords.map(record =&gt; this.toJSON(record, conversionOptions)) } else { object = this.toJSON(propsOrRecords, conversionOptions) } return this.getAdapter(opts.adapter)[method](this, object, opts) }, /** * Select records according to the `query` argument, and aggregate the sum * value of the property specified by `field`. * * {@link Mapper#beforeSum} will be called before calling the adapter. * {@link Mapper#afterSum} will be called after calling the adapter. * * @example * PurchaseOrderMapper.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid); // e.g. 451125.34 * }); * * @method Mapper#sum * @param {string} field The field to sum. * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. Refer to the `sum` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the aggregated sum. * @since 3.0.0 */ sum (field, query, opts) { return this.crud('sum', field, query, opts) }, /** * Return a plain object representation of the given record. Relations can * be optionally be included. Non-schema properties can be excluded. * * @example * import { Mapper, Schema } from 'js-data'; * const PersonMapper = new Mapper({ * name: 'person', * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }); * const person = PersonMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); * // \"foo\" is stripped by toJSON() * console.log(PersonMapper.toJSON(person)); // {\"id\":1,\"name\":\"John\"} * * const PersonRelaxedMapper = new Mapper({ * name: 'personRelaxed', * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * }, * additionalProperties: true * } * }); * const person2 = PersonRelaxedMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); * // \"foo\" is not stripped by toJSON * console.log(PersonRelaxedMapper.toJSON(person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} * * @method Mapper#toJSON * @param {Record|Record[]} records Record or records from which to create a * POJO representation. * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the POJO representation. * @param {boolean} [opts.withAll] Whether to simply include all relations in * the representation. Overrides `opts.with`. * @returns {Object|Object[]} POJO representation of the record or records. * @since 3.0.0 */ toJSON (records, opts) { let record opts || (opts = {}) if (utils.isArray(records)) { return records.map((record) =&gt; this.toJSON(record, opts)) } else { record = records } const relationFields = (this ? this.relationFields : []) || [] let json = {} // Copy properties defined in the schema if (this &amp;&amp; this.schema) { json = this.schema.pick(record) } else { for (var key in record) { if (relationFields.indexOf(key) === -1) { json[key] = utils.plainCopy(record[key]) } } } // The user wants to include relations in the resulting plain object representation if (this &amp;&amp; opts.withAll) { opts.with = relationFields.slice() } if (this &amp;&amp; opts.with) { if (utils.isString(opts.with)) { opts.with = [opts.with] } utils.forEachRelation(this, opts, (def, optsCopy) =&gt; { const relationData = def.getLocalField(record) if (relationData) { // The actual recursion if (utils.isArray(relationData)) { def.setLocalField(json, relationData.map((item) =&gt; { return def.getRelation().toJSON(item, optsCopy) })) } else { def.setLocalField(json, def.getRelation().toJSON(relationData, optsCopy)) } } }) } return json }, /** * Fired during {@link Mapper#update}. See * {@link Mapper~beforeUpdateListener} for how to listen for this event. * * @event Mapper#beforeUpdate * @see Mapper~beforeUpdateListener * @see Mapper#update */ /** * Callback signature for the {@link Mapper#event:beforeUpdate} event. * * @example * function onBeforeUpdate (id, props, opts) { * // do something * } * store.on('beforeUpdate', onBeforeUpdate); * * @callback Mapper~beforeUpdateListener * @param {string|number} id The `id` argument passed to {@link Mapper#beforeUpdate}. * @param {object} props The `props` argument passed to {@link Mapper#beforeUpdate}. * @param {object} opts The `opts` argument passed to {@link Mapper#beforeUpdate}. * @see Mapper#event:beforeUpdate * @see Mapper#update * @since 3.0.0 */ /** * Fired during {@link Mapper#update}. See * {@link Mapper~afterUpdateListener} for how to listen for this event. * * @event Mapper#afterUpdate * @see Mapper~afterUpdateListener * @see Mapper#update */ /** * Callback signature for the {@link Mapper#event:afterUpdate} event. * * @example * function onAfterUpdate (id, props, opts, result) { * // do something * } * store.on('afterUpdate', onAfterUpdate); * * @callback Mapper~afterUpdateListener * @param {string|number} id The `id` argument passed to {@link Mapper#afterUpdate}. * @param {object} props The `props` argument passed to {@link Mapper#afterUpdate}. * @param {object} opts The `opts` argument passed to {@link Mapper#afterUpdate}. * @param {object} result The `result` argument passed to {@link Mapper#afterUpdate}. * @see Mapper#event:afterUpdate * @see Mapper#update * @since 3.0.0 */ /** * Using an adapter, update the record with the primary key specified by the * `id` argument. * * {@link Mapper#beforeUpdate} will be called before updating the record. * {@link Mapper#afterUpdate} will be called after updating the record. * * @example * // Update a specific post * PostMapper.update(1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post); // { id: 1234, status: 'published', ... } * }); * * @fires Mapper#beforeUpdate * @fires Mapper#afterUpdate * @method Mapper#update * @param {(string|number)} id The primary key of the record to update. * @param {object} props The update to apply to the record. * @param {object} [opts] Configuration options. Refer to the `update` method * of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * transaction. * @returns {Promise} Resolves with the updated record. Rejects if the record * could not be found. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ update (id, props, opts) { return this.crud('update', id, props, opts) }, /** * Fired during {@link Mapper#updateAll}. See * {@link Mapper~beforeUpdateAllListener} for how to listen for this event. * * @event Mapper#beforeUpdateAll * @see Mapper~beforeUpdateAllListener * @see Mapper#updateAll */ /** * Callback signature for the {@link Mapper#event:beforeUpdateAll} event. * * @example * function onBeforeUpdateAll (props, query, opts) { * // do something * } * store.on('beforeUpdateAll', onBeforeUpdateAll); * * @callback Mapper~beforeUpdateAllListener * @param {object} props The `props` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateAll}. * @see Mapper#event:beforeUpdateAll * @see Mapper#updateAll * @since 3.0.0 */ /** * Fired during {@link Mapper#updateAll}. See * {@link Mapper~afterUpdateAllListener} for how to listen for this event. * * @event Mapper#afterUpdateAll * @see Mapper~afterUpdateAllListener * @see Mapper#updateAll */ /** * Callback signature for the {@link Mapper#event:afterUpdateAll} event. * * @example * function onAfterUpdateAll (props, query, opts, result) { * // do something * } * store.on('afterUpdateAll', onAfterUpdateAll); * * @callback Mapper~afterUpdateAllListener * @param {object} props The `props` argument received by {@link Mapper#afterUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#afterUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateAll}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateAll}. * @see Mapper#event:afterUpdateAll * @see Mapper#updateAll * @since 3.0.0 */ /** * Using the `query` argument, perform the a single updated to the selected * records. * * {@link Mapper#beforeUpdateAll} will be called before making the update. * {@link Mapper#afterUpdateAll} will be called after making the update. * * @example * // Turn all of John's blog posts into drafts. * const update = { status: draft: published_at: null }; * const query = { userId: 1234 }; * PostMapper.updateAll(update, query).then((posts) =&gt; { * console.log(posts); // [...] * }); * * @fires Mapper#beforeUpdateAll * @fires Mapper#afterUpdateAll * @method Mapper#updateAll * @param {object} props Update to apply to selected records. * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. Refer to the `updateAll` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the update records, if any. * @see query * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ updateAll (props, query, opts) { return this.crud('updateAll', props, query, opts) }, /** * Fired during {@link Mapper#updateMany}. See * {@link Mapper~beforeUpdateManyListener} for how to listen for this event. * * @event Mapper#beforeUpdateMany * @see Mapper~beforeUpdateManyListener * @see Mapper#updateMany */ /** * Callback signature for the {@link Mapper#event:beforeUpdateMany} event. * * @example * function onBeforeUpdateMany (records, opts) { * // do something * } * store.on('beforeUpdateMany', onBeforeUpdateMany); * * @callback Mapper~beforeUpdateManyListener * @param {object} records The `records` argument received by {@link Mapper#beforeUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateMany}. * @see Mapper#event:beforeUpdateMany * @see Mapper#updateMany * @since 3.0.0 */ /** * Fired during {@link Mapper#updateMany}. See * {@link Mapper~afterUpdateManyListener} for how to listen for this event. * * @event Mapper#afterUpdateMany * @see Mapper~afterUpdateManyListener * @see Mapper#updateMany */ /** * Callback signature for the {@link Mapper#event:afterUpdateMany} event. * * @example * function onAfterUpdateMany (records, opts, result) { * // do something * } * store.on('afterUpdateMany', onAfterUpdateMany); * * @callback Mapper~afterUpdateManyListener * @param {object} records The `records` argument received by {@link Mapper#afterUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateMany}. * @see Mapper#event:afterUpdateMany * @see Mapper#updateMany * @since 3.0.0 */ /** * Given an array of updates, perform each of the updates via an adapter. Each * \"update\" is a hash of properties with which to update an record. Each * update must contain the primary key of the record to be updated. * * {@link Mapper#beforeUpdateMany} will be called before making the update. * {@link Mapper#afterUpdateMany} will be called after making the update. * * @example * PostMapper.updateMany([ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts); // [...] * }); * * @fires Mapper#beforeUpdateMany * @fires Mapper#afterUpdateMany * @method Mapper#updateMany * @param {Record[]} records Array up record updates. * @param {object} [opts] Configuration options. Refer to the `updateMany` * method of whatever adapter you're using for more configuration options. * @param {boolean} [opts.adapter={@link Mapper#defaultAdapter}] Name of the * adapter to use. * @param {boolean} [opts.notify={@link Mapper#notify}] See {@link Mapper#notify}. * @param {boolean} [opts.noValidate={@link Mapper#noValidate}] See {@link Mapper#noValidate}. * @param {boolean} [opts.raw={@link Mapper#raw}] See {@link Mapper#raw}. * @returns {Promise} Resolves with the updated records. Rejects if any of the * records could be found. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ updateMany (records, opts) { return this.crud('updateMany', records, opts) }, /** * Validate the given record or records according to this Mapper's * {@link Schema}. If there are no validation errors then the return value * will be `undefined`. * * @example * import {Mapper, Schema} from 'js-data' * const PersonSchema = new Schema({ * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * }); * const PersonMapper = new Mapper({ * name: 'person', * schema: PersonSchema * }); * let errors = PersonMapper.validate({ name: 'John' }); * console.log(errors); // undefined * errors = PersonMapper.validate({ name: 123 }); * console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Mapper#validate * @param {Object|Object[]} record The record or records to validate. * @param {object} [opts] Configuration options. Passed to * {@link Schema#validate}. * @returns {Object[]} Array of errors or `undefined` if no errors. * @since 3.0.0 */ validate (record, opts) { opts || (opts = {}) const schema = this.getSchema() if (!schema) { return } const _opts = utils.pick(opts, ['existingOnly']) if (utils.isArray(record)) { const errors = record.map((_record) =&gt; schema.validate(_record, utils.pick(_opts, ['existingOnly']))) return errors.some(Boolean) ? errors : undefined } return schema.validate(record, _opts) }, /** * Method used to wrap data returned by an adapter with this Mapper's * {@link Mapper#recordClass}. This method is used by all of a Mapper's CRUD * methods. The provided implementation of this method assumes that the `data` * passed to it is a record or records that need to be wrapped with * {@link Mapper#createRecord}. Override with care. * * Provided implementation of {@link Mapper#wrap}: * * ``` * function (data, opts) { * return this.createRecord(data, opts); * } * ``` * * @example * const PostMapper = new Mapper({ * name: 'post', * // Override to customize behavior * wrap (data, opts) { * const originalWrap = this.constructor.prototype.wrap; * // Let's say \"GET /post\" doesn't return JSON quite like JSData expects, * // but the actual post records are nested under a \"posts\" field. So, * // we override Mapper#wrap to handle this special case. * if (opts.op === 'findAll') { * return originalWrap.call(this, data.posts, opts); * } * // Otherwise perform original behavior * return originalWrap.call(this, data, opts); * } * }); * * @method Mapper#wrap * @param {Object|Object[]} data The record or records to be wrapped. * @param {object} [opts] Configuration options. Passed to {@link Mapper#createRecord}. * @returns {Record|Record[]} The wrapped record or records. * @since 3.0.0 */ wrap (data, opts) { return this.createRecord(data, opts) }, /** * @ignore */ defineRelations () { // Setup the mapper's relations, including generating Mapper#relationList // and Mapper#relationFields utils.forOwn(this.relations, (group, type) =&gt; { utils.forOwn(group, (relations, _name) =&gt; { if (utils.isObject(relations)) { relations = [relations] } relations.forEach((def) =&gt; { const relatedMapper = this.datastore.getMapperByName(_name) || _name def.getRelation = () =&gt; this.datastore.getMapper(_name) if (typeof Relation[type] !== 'function') { throw utils.err(DOMAIN, 'defineRelations')(400, 'relation type (hasOne, hasMany, etc)', type, true) } this[type](relatedMapper, def) }) }) }) } }) /** * Create a subclass of this Mapper: * * @example &lt;caption&gt;Mapper.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Mapper } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomMapperClass extends Mapper { * foo () { return 'bar'; } * static beep () { return 'boop'; } * }; * const customMapper = new CustomMapperClass(); * console.log(customMapper.foo()); * console.log(CustomMapperClass.beep()); * * // Extend the class using alternate method. * const OtherMapperClass = Mapper.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherMapper = new OtherMapperClass(); * console.log(otherMapper.foo()); * console.log(OtherMapperClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherMapperClass () { * Mapper.call(this); * this.created_at = new Date().getTime(); * } * Mapper.extend({ * constructor: AnotherMapperClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherMapper = new AnotherMapperClass(); * console.log(anotherMapper.created_at); * console.log(anotherMapper.foo()); * console.log(AnotherMapperClass.beep()); * * @method Mapper.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Mapper class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Collection.js import utils from './utils' import Component from './Component' import Query from './Query' import Record from './Record' import Index from '../lib/mindex/index' const { noValidatePath } = Record const DOMAIN = 'Collection' const COLLECTION_DEFAULTS = { /** * Whether to call {@link Record#commit} on records that are added to the * collection and already exist in the collection. * * @name Collection#commitOnMerge * @type {boolean} * @default true */ commitOnMerge: true, /** * Whether record events should bubble up and be emitted by the collection. * * @name Collection#emitRecordEvents * @type {boolean} * @default true */ emitRecordEvents: true, /** * Field to be used as the unique identifier for records in this collection. * Defaults to `\"id\"` unless {@link Collection#mapper} is set, in which case * this will default to {@link Mapper#idAttribute}. * * @name Collection#idAttribute * @type {string} * @default \"id\" */ idAttribute: 'id', /** * What to do when inserting a record into this Collection that shares a * primary key with a record already in this Collection. * * Possible values: * merge * replace * skip * * Merge: * * Recursively shallow copy properties from the new record onto the existing * record. * * Replace: * * Shallow copy top-level properties from the new record onto the existing * record. Any top-level own properties of the existing record that are _not_ * on the new record will be removed. * * Skip: * * Ignore new record, keep existing record. * * @name Collection#onConflict * @type {string} * @default \"merge\" */ onConflict: 'merge' } /** * An ordered set of {@link Record} instances. * * @example &lt;caption&gt;Collection#constructor&lt;/caption&gt; * // import { Collection, Record } from 'js-data'; * const JSData = require('js-data'); * const {Collection, Record} = JSData; * console.log('Using JSData v' + JSData.version.full); * * const user1 = new Record({ id: 1 }); * const user2 = new Record({ id: 2 }); * const UserCollection = new Collection([user1, user2]); * console.log(UserCollection.get(1) === user1); * * @class Collection * @extends Component * @param {array} [records] Initial set of records to insert into the * collection. * @param {object} [opts] Configuration options. * @param {string} [opts.commitOnMerge] See {@link Collection#commitOnMerge}. * @param {string} [opts.idAttribute] See {@link Collection#idAttribute}. * @param {string} [opts.onConflict=\"merge\"] See {@link Collection#onConflict}. * @param {string} [opts.mapper] See {@link Collection#mapper}. * @since 3.0.0 */ function Collection (records, opts) { utils.classCallCheck(this, Collection) Component.call(this, opts) if (records &amp;&amp; !utils.isArray(records)) { opts = records records = [] } if (utils.isString(opts)) { opts = { idAttribute: opts } } // Default values for arguments records || (records = []) opts || (opts = {}) Object.defineProperties(this, { /** * Default Mapper for this collection. Optional. If a Mapper is provided, then * the collection will use the {@link Mapper#idAttribute} setting, and will * wrap records in {@link Mapper#recordClass}. * * @example &lt;caption&gt;Collection#mapper&lt;/caption&gt; * const JSData = require('js-data'); * const {Collection, Mapper} = JSData; * console.log('Using JSData v' + JSData.version.full); * * class MyMapperClass extends Mapper { * foo () { return 'bar'; } * } * const myMapper = new MyMapperClass({ name: 'myMapper' }); * const collection = new Collection(null, { mapper: myMapper }); * * @name Collection#mapper * @type {Mapper} * @default null * @since 3.0.0 */ mapper: { value: undefined, writable: true }, // Query class used by this collection queryClass: { value: undefined, writable: true } }) // Apply user-provided configuration utils.fillIn(this, opts) // Fill in any missing options with the defaults utils.fillIn(this, utils.copy(COLLECTION_DEFAULTS)) if (!this.queryClass) { this.queryClass = Query } const idAttribute = this.recordId() Object.defineProperties(this, { /** * The main index, which uses @{link Collection#recordId} as the key. * * @name Collection#index * @type {Index} */ index: { value: new Index([idAttribute], { hashCode (obj) { return utils.get(obj, idAttribute) } }) }, /** * Object that holds the secondary indexes of this collection. * * @name Collection#indexes * @type {Object.&lt;string, Index&gt;} */ indexes: { value: {} } }) // Insert initial data into the collection if (utils.isObject(records) || (utils.isArray(records) &amp;&amp; records.length)) { this.add(records) } } export default Component.extend({ constructor: Collection, /** * Used to bind to events emitted by records in this Collection. * * @method Collection#_onRecordEvent * @since 3.0.0 * @private * @param {...*} [arg] Args passed to {@link Collection#emit}. */ _onRecordEvent (...args) { if (this.emitRecordEvents) { this.emit(...args) } }, /** * Insert the provided record or records. * * If a record is already in the collection then the provided record will * either merge with or replace the existing record based on the value of the * `onConflict` option. * * The collection's secondary indexes will be updated as each record is * visited. * * @method Collection#add * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} data The record or records to insert. * @param {object} [opts] Configuration options. * @param {boolean} [opts.commitOnMerge=true] See {@link Collection#commitOnMerge}. * @param {boolean} [opts.noValidate] See {@link Record#noValidate}. * @param {string} [opts.onConflict] See {@link Collection#onConflict}. * @returns {(Object|Object[]|Record|Record[])} The added record or records. */ add (records, opts) { // Default values for arguments opts || (opts = {}) // Fill in \"opts\" with the Collection's configuration utils._(opts, this) records = this.beforeAdd(records, opts) || records // Track whether just one record or an array of records is being inserted let singular = false const idAttribute = this.recordId() if (!utils.isArray(records)) { if (utils.isObject(records)) { records = [records] singular = true } else { throw utils.err(`${DOMAIN}#add`, 'records')( 400, 'object or array', records ) } } // Map the provided records to existing records. // New records will be inserted. If any records map to existing records, // they will be merged into the existing records according to the onConflict // option. records = records.map(record =&gt; { let id = this.recordId(record) // Grab existing record if there is one const existing = id === undefined ? id : this.get(id) // If the currently visited record is just a reference to an existing // record, then there is nothing to be done. Exit early. if (record === existing) { return existing } if (existing) { // Here, the currently visited record corresponds to a record already // in the collection, so we need to merge them const onConflict = opts.onConflict || this.onConflict if ( onConflict !== 'merge' &amp;&amp; onConflict !== 'replace' &amp;&amp; onConflict !== 'skip' ) { throw utils.err(`${DOMAIN}#add`, 'opts.onConflict')( 400, 'one of (merge, replace, skip)', onConflict, true ) } const existingNoValidate = existing._get(noValidatePath) if (opts.noValidate) { // Disable validation existing._set(noValidatePath, true) } if (onConflict === 'merge') { utils.deepMixIn(existing, record) } else if (onConflict === 'replace') { utils.forOwn(existing, (value, key) =&gt; { if (key !== idAttribute &amp;&amp; record[key] === undefined) { existing[key] = undefined } }) existing.set(record) } // else if(onConflict === 'skip'){ do nothing } if (opts.noValidate) { // Restore previous `noValidate` value existing._set(noValidatePath, existingNoValidate) } record = existing if (opts.commitOnMerge &amp;&amp; utils.isFunction(record.commit)) { record.commit() } // Update all indexes in the collection this.updateIndexes(record) } else { // Here, the currently visted record does not correspond to any record // in the collection, so (optionally) instantiate this record and insert // it into the collection record = this.mapper ? this.mapper.createRecord(record, opts) : record this.index.insertRecord(record) utils.forOwn(this.indexes, function (index, name) { index.insertRecord(record) }) if (record &amp;&amp; utils.isFunction(record.on)) { record.on('all', this._onRecordEvent, this) } } return record }) // Finally, return the inserted data const result = singular ? records[0] : records if (!opts.silent) { this.emit('add', result) } return this.afterAdd(records, opts, result) || result }, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then {@link Collection#add} will return that same value. * * @method Collection#method * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} result The record or records * that were added to this Collection by {@link Collection#add}. * @param {object} opts The `opts` argument passed to {@link Collection#add}. */ afterAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. If this method returns * a value then {@link Collection#remove} will return that same value. * * @method Collection#afterRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {object} opts The `opts` argument passed to {@link Collection#remove}. * @param {object} record The result that will be returned by {@link Collection#remove}. */ afterRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. If this method * returns a value then {@link Collection#removeAll} will return that same * value. * * @method Collection#afterRemoveAll * @since 3.0.0 * @param {object} query The `query` argument passed to {@link Collection#removeAll}. * @param {object} opts The `opts` argument passed to {@link Collection#removeAll}. * @param {object} records The result that will be returned by {@link Collection#removeAll}. */ afterRemoveAll () {}, /** * Lifecycle hook called by {@link Collection#add}. If this method returns a * value then the `records` argument in {@link Collection#add} will be * re-assigned to the returned value. * * @method Collection#beforeAdd * @since 3.0.0 * @param {(Object|Object[]|Record|Record[])} records The `records` argument passed to {@link Collection#add}. * @param {object} opts The `opts` argument passed to {@link Collection#add}. */ beforeAdd () {}, /** * Lifecycle hook called by {@link Collection#remove}. * * @method Collection#beforeRemove * @since 3.0.0 * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}. * @param {object} opts The `opts` argument passed to {@link Collection#remove}. */ beforeRemove () {}, /** * Lifecycle hook called by {@link Collection#removeAll}. * * @method Collection#beforeRemoveAll * @since 3.0.0 * @param {object} query The `query` argument passed to {@link Collection#removeAll}. * @param {object} opts The `opts` argument passed to {@link Collection#removeAll}. */ beforeRemoveAll () {}, /** * Find all records between two boundaries. * * Shortcut for `collection.query().between(18, 30, { index: 'age' }).run()` * * @example * // Get all users ages 18 to 30 * const users = collection.between(18, 30, { index: 'age' }); * * @example * // Same as above * const users = collection.between([18], [30], { index: 'age' }); * * @method Collection#between * @since 3.0.0 * @param {array} leftKeys Keys defining the left boundary. * @param {array} rightKeys Keys defining the right boundary. * @param {object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include records * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include records * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting records to skip. * @returns {Object[]|Record[]} The result. */ between (leftKeys, rightKeys, opts) { return this.query() .between(leftKeys, rightKeys, opts) .run() }, /** * Create a new secondary index on the contents of the collection. * * @example * // Index users by age * collection.createIndex('age'); * * @example * // Index users by status and role * collection.createIndex('statusAndRole', ['status', 'role']); * * @method Collection#createIndex * @since 3.0.0 * @param {string} name The name of the new secondary index. * @param {string[]} [fieldList] Array of field names to use as the key or * compound key of the new secondary index. If no fieldList is provided, then * the name will also be the field that is used to index the collection. */ createIndex (name, fieldList, opts) { if (utils.isString(name) &amp;&amp; fieldList === undefined) { fieldList = [name] } opts || (opts = {}) opts.hashCode || (opts.hashCode = obj =&gt; this.recordId(obj)) const index = (this.indexes[name] = new Index(fieldList, opts)) this.index.visitAll(index.insertRecord, index) }, /** * Find the record or records that match the provided query or pass the * provided filter function. * * Shortcut for `collection.query().filter(queryOrFn[, thisArg]).run()` * * @example &lt;caption&gt;Collection#filter&lt;/caption&gt; * const JSData = require('js-data'); * const { Collection } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const collection = new Collection([ * { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } * ]); * * // Get the draft posts created less than three months ago * let posts = collection.filter({ * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago * } * } * }); * console.log(posts); * * // Use a custom filter function * posts = collection.filter((post) =&gt; post.id % 2 === 0); * * @method Collection#filter * @param {(Object|Function)} [queryOrFn={}] Selection query or filter * function. * @param {object} [thisArg] Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Array} The result. * @see query * @since 3.0.0 */ filter (query, thisArg) { return this.query() .filter(query, thisArg) .run() }, /** * Iterate over all records. * * @example * collection.forEach(function (record) { * // do something * }); * * @method Collection#forEach * @since 3.0.0 * @param {Function} forEachFn Iteration function. * @param {*} [thisArg] Context to which to bind `forEachFn`. * @returns {Array} The result. */ forEach (cb, thisArg) { this.index.visitAll(cb, thisArg) }, /** * Get the record with the given id. * * @method Collection#get * @since 3.0.0 * @param {(string|number)} id The primary key of the record to get. * @returns {(Object|Record)} The record with the given id. */ get (id) { const instances = id === undefined ? [] : this.query() .get(id) .run() return instances.length ? instances[0] : undefined }, /** * Find the record or records that match the provided keyLists. * * Shortcut for `collection.query().getAll(keyList1, keyList2, ...).run()` * * @example * // Get the posts where \"status\" is \"draft\" or \"inReview\" * const posts = collection.getAll('draft', 'inReview', { index: 'status' }); * * @example * // Same as above * const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }); * * @method Collection#getAll * @since 3.0.0 * @param {...Array} [keyList] Provide one or more keyLists, and all * records matching each keyList will be retrieved. If no keyLists are * provided, all records will be returned. * @param {object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Array} The result. */ getAll (...args) { return this.query() .getAll(...args) .run() }, /** * Return the index with the given name. If no name is provided, return the * main index. Throws an error if the specified index does not exist. * * @method Collection#getIndex * @since 3.0.0 * @param {string} [name] The name of the index to retrieve. */ getIndex (name) { const index = name ? this.indexes[name] : this.index if (!index) { throw utils.err(`${DOMAIN}#getIndex`, name)(404, 'index') } return index }, /** * Limit the result. * * Shortcut for `collection.query().limit(maximumNumber).run()` * * @example * const posts = collection.limit(10); * * @method Collection#limit * @since 3.0.0 * @param {number} num The maximum number of records to keep in the result. * @returns {Array} The result. */ limit (num) { return this.query() .limit(num) .run() }, /** * Apply a mapping function to all records. * * @example * const names = collection.map((user) =&gt; user.name); * * @method Collection#map * @since 3.0.0 * @param {Function} mapFn Mapping function. * @param {*} [thisArg] Context to which to bind `mapFn`. * @returns {Array} The result of the mapping. */ map (cb, thisArg) { const data = [] this.index.visitAll(function (value) { data.push(cb.call(thisArg, value)) }) return data }, /** * Return the result of calling the specified function on each record in this * collection's main index. * * @method Collection#mapCall * @since 3.0.0 * @param {string} funcName Name of function to call * @parama {...*} [args] Remaining arguments to be passed to the function. * @returns {Array} The result. */ mapCall (funcName, ...args) { const data = [] this.index.visitAll(function (record) { data.push(record[funcName](...args)) }) return data }, /** * Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. * * @method Collection#prune * @param {object} [opts] Configuration options, passed to {@link Collection#removeAll}. * @since 3.0.0 * @returns {Array} The removed records, if any. */ prune (opts) { return this.removeAll(this.unsaved(), opts) }, /** * Create a new query to be executed against the contents of the collection. * The result will be all or a subset of the contents of the collection. * * @example * // Grab page 2 of users between ages 18 and 30 * collection.query() * .between(18, 30, { index: 'age' }) // between ages 18 and 30 * .skip(10) // second page * .limit(10) // page size * .run(); * * @method Collection#query * @since 3.0.0 * @returns {Query} New query object. */ query () { const Ctor = this.queryClass return new Ctor(this) }, /** * Return the primary key of the given, or if no record is provided, return the * name of the field that holds the primary key of records in this Collection. * * @method Collection#recordId * @since 3.0.0 * @param {(Object|Record)} [record] The record whose primary key is to be * returned. * @returns {(string|number)} Primary key or name of field that holds primary * key. */ recordId (record) { if (record) { return utils.get(record, this.recordId()) } return this.mapper ? this.mapper.idAttribute : this.idAttribute }, /** * Reduce the data in the collection to a single value and return the result. * * @example * const totalVotes = collection.reduce((prev, record) =&gt; { * return prev + record.upVotes + record.downVotes; * }, 0); * * @method Collection#reduce * @since 3.0.0 * @param {Function} cb Reduction callback. * @param {*} initialValue Initial value of the reduction. * @returns {*} The result. */ reduce (cb, initialValue) { const data = this.getAll() return data.reduce(cb, initialValue) }, /** * Remove the record with the given id from this Collection. * * @method Collection#remove * @since 3.0.0 * @param {(string|number|object|Record)} idOrRecord The primary key of the * record to be removed, or a reference to the record that is to be removed. * @param {object} [opts] Configuration options. * @returns {Object|Record} The removed record, if any. */ remove (idOrRecord, opts) { // Default values for arguments opts || (opts = {}) this.beforeRemove(idOrRecord, opts) let record = utils.isSorN(idOrRecord) ? this.get(idOrRecord) : idOrRecord // The record is in the collection, remove it if (utils.isObject(record)) { record = this.index.removeRecord(record) if (record) { utils.forOwn(this.indexes, function (index, name) { index.removeRecord(record) }) if (utils.isFunction(record.off)) { record.off('all', this._onRecordEvent, this) } if (!opts.silent) { this.emit('remove', record) } } } return this.afterRemove(idOrRecord, opts, record) || record }, /** * Remove from this collection the given records or the records selected by * the given \"query\". * * @method Collection#removeAll * @since 3.0.0 * @param {Object|Object[]|Record[]} [queryOrRecords={}] Records to be removed or selection query. See {@link query}. * @param {object} [queryOrRecords.where] See {@link query.where}. * @param {number} [queryOrRecords.offset] See {@link query.offset}. * @param {number} [queryOrRecords.limit] See {@link query.limit}. * @param {string|Array[]} [queryOrRecords.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. * @returns {(Object[]|Record[])} The removed records, if any. */ removeAll (queryOrRecords, opts) { // Default values for arguments opts || (opts = {}) this.beforeRemoveAll(queryOrRecords, opts) let records = utils.isArray(queryOrRecords) ? queryOrRecords.slice() : this.filter(queryOrRecords) // Remove each selected record from the collection const optsCopy = utils.plainCopy(opts) optsCopy.silent = true records = records .map(record =&gt; this.remove(record, optsCopy)) .filter(record =&gt; record) if (!opts.silent) { this.emit('remove', records) } return this.afterRemoveAll(queryOrRecords, opts, records) || records }, /** * Skip a number of results. * * Shortcut for `collection.query().skip(numberToSkip).run()` * * @example * const posts = collection.skip(10); * * @method Collection#skip * @since 3.0.0 * @param {number} num The number of records to skip. * @returns {Array} The result. */ skip (num) { return this.query() .skip(num) .run() }, /** * Return the plain JSON representation of all items in this collection. * Assumes records in this collection have a toJSON method. * * @method Collection#toJSON * @since 3.0.0 * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. * @returns {Array} The records. */ toJSON (opts) { return this.mapCall('toJSON', opts) }, /** * Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. * * @method Collection#unsaved * @since 3.0.0 * @returns {Array} The unsaved records, if any. */ unsaved (opts) { return this.index.get() }, /** * Update a record's position in a single index of this collection. See * {@link Collection#updateIndexes} to update a record's position in all * indexes at once. * * @method Collection#updateIndex * @since 3.0.0 * @param {object} record The record to update. * @param {object} [opts] Configuration options. * @param {string} [opts.index] The index in which to update the record's * position. If you don't specify an index then the record will be updated * in the main index. */ updateIndex (record, opts) { opts || (opts = {}) this.getIndex(opts.index).updateRecord(record) }, /** * Updates all indexes in this collection for the provided record. Has no * effect if the record is not in the collection. * * @method Collection#updateIndexes * @since 3.0.0 * @param {object} record TODO */ updateIndexes (record) { this.index.updateRecord(record) utils.forOwn(this.indexes, function (index, name) { index.updateRecord(record) }) } }) /** * Fired when a record changes. Only works for records that have tracked changes. * See {@link Collection~changeListener} on how to listen for this event. * * @event Collection#change * @see Collection~changeListener */ /** * Callback signature for the {@link Collection#event:change} event. * * @example * function onChange (record, changes) { * // do something * } * collection.on('change', onChange); * * @callback Collection~changeListener * @param {Record} The Record that changed. * @param {object} The changes. * @see Collection#event:change * @since 3.0.0 */ /** * Fired when one or more records are added to the Collection. See * {@link Collection~addListener} on how to listen for this event. * * @event Collection#add * @see Collection~addListener * @see Collection#event:add * @see Collection#add */ /** * Callback signature for the {@link Collection#event:add} event. * * @example * function onAdd (recordOrRecords) { * // do something * } * collection.on('add', onAdd); * * @callback Collection~addListener * @param {Record|Record[]} The Record or Records that were added. * @see Collection#event:add * @see Collection#add * @since 3.0.0 */ /** * Fired when one or more records are removed from the Collection. See * {@link Collection~removeListener} for how to listen for this event. * * @event Collection#remove * @see Collection~removeListener * @see Collection#event:remove * @see Collection#remove * @see Collection#removeAll */ /** * Callback signature for the {@link Collection#event:remove} event. * * @example * function onRemove (recordsOrRecords) { * // do something * } * collection.on('remove', onRemove); * * @callback Collection~removeListener * @param {Record|Record[]} Record or Records that were removed. * @see Collection#event:remove * @see Collection#remove * @see Collection#removeAll * @since 3.0.0 */ /** * Create a subclass of this Collection: * @example &lt;caption&gt;Collection.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Collection } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomCollectionClass extends Collection { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customCollection = new CustomCollectionClass(); * console.log(customCollection.foo()); * console.log(CustomCollectionClass.beep()); * * // Extend the class using alternate method. * const OtherCollectionClass = Collection.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherCollection = new OtherCollectionClass(); * console.log(otherCollection.foo()); * console.log(OtherCollectionClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherCollectionClass () { * Collection.call(this); * this.created_at = new Date().getTime(); * } * Collection.extend({ * constructor: AnotherCollectionClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherCollection = new AnotherCollectionClass(); * console.log(anotherCollection.created_at); * console.log(anotherCollection.foo()); * console.log(AnotherCollectionClass.beep()); * * @method Collection.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Collection class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Component.js.html":{"id":"Component.js.html","title":"Source: Component.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Component.js import utils from './utils' import Settable from './Settable' /** * The base class from which all JSData components inherit some basic * functionality. * * Typically you won't instantiate this class directly, but you may find it * useful as an abstract class for your own components. * * See {@link Component.extend} for an example of using {@link Component} as a * base class. * *```javascript * import {Component} from 'js-data' * ``` * * @class Component * @param {object} [opts] Configuration options. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @returns {Component} A new {@link Component} instance. * @since 3.0.0 */ function Component (opts) { Settable.call(this) opts || (opts = {}) /** * Whether to enable debug-level logs for this component. Anything that * extends `Component` inherits this option and the corresponding logging * functionality. * * @example &lt;caption&gt;Component#debug&lt;/caption&gt; * const JSData = require('js-data'); * const { Component } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const component = new Component(); * component.log('debug', 'some message'); // nothing gets logged * // Display debug logs: * component.debug = true; * component.log('debug', 'other message'); // this DOES get logged * * @default false * @name Component#debug * @since 3.0.0 * @type {boolean} */ this.debug = opts.hasOwnProperty('debug') ? !!opts.debug : false /** * Event listeners attached to this Component. __Do not modify.__ Use * {@link Component#on} and {@link Component#off} instead. * * @name Component#_listeners * @private * @instance * @since 3.0.0 * @type {Object} */ Object.defineProperty(this, '_listeners', { value: {}, writable: true }) } export default Settable.extend({ constructor: Component }) /** * Create a subclass of this Component: * * @example &lt;caption&gt;Component.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Component } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomComponentClass extends Component { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customComponent = new CustomComponentClass(); * console.log(customComponent.foo()); * console.log(CustomComponentClass.beep()); * * // Extend the class using alternate method. * const OtherComponentClass = Component.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherComponent = new OtherComponentClass(); * console.log(otherComponent.foo()); * console.log(OtherComponentClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherComponentClass () { * Component.call(this); * this.created_at = new Date().getTime(); * } * Component.extend({ * constructor: AnotherComponentClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherComponent = new AnotherComponentClass(); * console.log(anotherComponent.created_at); * console.log(anotherComponent.foo()); * console.log(AnotherComponentClass.beep()); * * @method Component.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Component class. * @since 3.0.0 */ Component.extend = utils.extend /** * Log the provided values at the \"debug\" level. Debug-level logs are only * logged if {@link Component#debug} is `true`. * * `.dbg(...)` is shorthand for `.log('debug', ...)`. * * @method Component#dbg * @param {...*} [args] Values to log. * @since 3.0.0 */ /** * Log the provided values. By default sends values to `console[level]`. * Debug-level logs are only logged if {@link Component#debug} is `true`. * * Will attempt to use appropriate `console` methods if they are available. * * @method Component#log * @param {string} level Log level. * @param {...*} [args] Values to log. * @since 3.0.0 */ utils.logify(Component.prototype) /** * Register a new event listener on this Component. * * @example * // Listen for all \"afterCreate\" events in a DataStore * store.on('afterCreate', (mapperName, props, opts, result) =&gt; { * console.log(mapperName); // \"post\" * console.log(props.id); // undefined * console.log(result.id); // 1234 * }); * store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { * console.log(post.id); // 1234 * }); * * @example * // Listen for the \"add\" event on a collection * collection.on('add', (records) =&gt; { * console.log(records); // [...] * }); * * @example * // Listen for \"change\" events on a record * post.on('change', (record, changes) =&gt; { * console.log(changes); // { changed: { title: 'Modeling your data' } } * }); * post.title = 'Modeling your data'; * * @method Component#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Remove an event listener from this Component. If no listener is provided, * then all listeners for the specified event will be removed. If no event is * specified then all listeners for all events will be removed. * * @example * // Remove a particular listener for a particular event * collection.off('add', handler); * * @example * // Remove all listeners for a particular event * record.off('change'); * * @example * // Remove all listeners to all events * store.off(); * * @method Component#off * @param {string} [event] Name of event to unsubsribe to. * @param {Function} [listener] Listener to remove. * @since 3.0.0 */ /** * Trigger an event on this Component. * * @example &lt;caption&gt;Component#emit&lt;/caption&gt; * // import { Collection, DataStore } from 'js-data'; * const JSData = require('js-data'); * const { Collection, DataStore } = JSData; * * const collection = new Collection(); * collection.on('foo', function (msg) { * console.log(msg); * }); * collection.emit('foo', 'bar'); * * const store = new DataStore(); * store.on('beep', function (msg) { * console.log(msg); * }); * store.emit('beep', 'boop'); * * @method Component#emit * @param {string} event Name of event to emit. * @param {...*} [args] Arguments to pass to any listeners. * @since 3.0.0 */ utils.eventify( Component.prototype, function () { return this._listeners }, function (value) { this._listeners = value } ) × Search results Close api.js-data.io • js-data.io "},"Container.js.html":{"id":"Container.js.html","title":"Source: Container.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Container.js import utils from './utils' import Component from './Component' import Mapper from './Mapper' const DOMAIN = 'Container' export const proxiedMapperMethods = [ /** * Wrapper for {@link Mapper#count}. * * @example * // Get the number of published blog posts * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.count('post', { status: 'published' }).then((numPublished) =&gt; { * console.log(numPublished); // e.g. 45 * }); * * @method Container#count * @param {string} name Name of the {@link Mapper} to target. * @param {object} [query] See {@link Mapper#count}. * @param {object} [opts] See {@link Mapper#count}. * @returns {Promise} See {@link Mapper#count}. * @see Mapper#count * @since 3.0.0 */ 'count', /** * Fired during {@link Container#create}. See * {@link Container~beforeCreateListener} for how to listen for this event. * * @event Container#beforeCreate * @see Container~beforeCreateListener * @see Container#create */ /** * Callback signature for the {@link Container#event:beforeCreate} event. * * @example * function onBeforeCreate (mapperName, props, opts) { * // do something * } * store.on('beforeCreate', onBeforeCreate); * * @callback Container~beforeCreateListener * @param {string} name The `name` argument received by {@link Mapper#beforeCreate}. * @param {object} props The `props` argument received by {@link Mapper#beforeCreate}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeCreate}. * @see Container#event:beforeCreate * @see Container#create * @since 3.0.0 */ /** * Fired during {@link Container#create}. See * {@link Container~afterCreateListener} for how to listen for this event. * * @event Container#afterCreate * @see Container~afterCreateListener * @see Container#create */ /** * Callback signature for the {@link Container#event:afterCreate} event. * * @example * function onAfterCreate (mapperName, props, opts, result) { * // do something * } * store.on('afterCreate', onAfterCreate); * * @callback Container~afterCreateListener * @param {string} name The `name` argument received by {@link Mapper#afterCreate}. * @param {object} props The `props` argument received by {@link Mapper#afterCreate}. * @param {object} opts The `opts` argument received by {@link Mapper#afterCreate}. * @param {object} result The `result` argument received by {@link Mapper#afterCreate}. * @see Container#event:afterCreate * @see Container#create * @since 3.0.0 */ /** * Wrapper for {@link Mapper#create}. * * @example * // Create and save a new blog post * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.create('post', { * title: 'Modeling your data', * status: 'draft' * }).then((post) =&gt; { * console.log(post); // { id: 1234, status: 'draft', ... } * }); * * @fires Container#beforeCreate * @fires Container#afterCreate * @method Container#create * @param {string} name Name of the {@link Mapper} to target. * @param {object} props See {@link Mapper#create}. * @param {object} [opts] See {@link Mapper#create}. * @returns {Promise} See {@link Mapper#create}. * @see Mapper#create * @since 3.0.0 */ 'create', /** * Fired during {@link Container#createMany}. See * {@link Container~beforeCreateManyListener} for how to listen for this event. * * @event Container#beforeCreateMany * @see Container~beforeCreateManyListener * @see Container#createMany */ /** * Callback signature for the {@link Container#event:beforeCreateMany} event. * * @example * function onBeforeCreateMany (mapperName, records, opts) { * // do something * } * store.on('beforeCreateMany', onBeforeCreateMany); * * @callback Container~beforeCreateManyListener * @param {string} name The `name` argument received by {@link Mapper#beforeCreateMany}. * @param {object} records The `records` argument received by {@link Mapper#beforeCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeCreateMany}. * @see Container#event:beforeCreateMany * @see Container#createMany * @since 3.0.0 */ /** * Fired during {@link Container#createMany}. See * {@link Container~afterCreateManyListener} for how to listen for this event. * * @event Container#afterCreateMany * @see Container~afterCreateManyListener * @see Container#createMany */ /** * Callback signature for the {@link Container#event:afterCreateMany} event. * * @example * function onAfterCreateMany (mapperName, records, opts, result) { * // do something * } * store.on('afterCreateMany', onAfterCreateMany); * * @callback Container~afterCreateManyListener * @param {string} name The `name` argument received by {@link Mapper#afterCreateMany}. * @param {object} records The `records` argument received by {@link Mapper#afterCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterCreateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterCreateMany}. * @see Container#event:afterCreateMany * @see Container#createMany * @since 3.0.0 */ /** * Wrapper for {@link Mapper#createMany}. * * @example * // Create and save several new blog posts * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.createMany('post', [{ * title: 'Modeling your data', * status: 'draft' * }, { * title: 'Reading data', * status: 'draft' * }]).then((posts) =&gt; { * console.log(posts[0]); // { id: 1234, status: 'draft', ... } * console.log(posts[1]); // { id: 1235, status: 'draft', ... } * }); * * @fires Container#beforeCreateMany * @fires Container#afterCreateMany * @method Container#createMany * @param {string} name Name of the {@link Mapper} to target. * @param {Record[]} records See {@link Mapper#createMany}. * @param {object} [opts] See {@link Mapper#createMany}. * @returns {Promise} See {@link Mapper#createMany}. * @see Mapper#createMany * @since 3.0.0 */ 'createMany', /** * Wrapper for {@link Mapper#createRecord}. * * __Note:__ This method does __not__ interact with any adapter, and does * __not__ save any data. It only creates new objects in memory. * * @example * // Create empty unsaved record instance * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('post'); * const post = PostMapper.createRecord(); * * @method Container#createRecord * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Object[]} props See {@link Mapper#createRecord}. * @param {object} [opts] See {@link Mapper#createRecord}. * @returns {Promise} See {@link Mapper#createRecord}. * @see Mapper#createRecord * @since 3.0.0 */ 'createRecord', /** * Fired during {@link Container#destroy}. See * {@link Container~beforeDestroyListener} for how to listen for this event. * * @event Container#beforeDestroy * @see Container~beforeDestroyListener * @see Container#destroy */ /** * Callback signature for the {@link Container#event:beforeDestroy} event. * * @example * function onBeforeDestroy (mapperName, id, opts) { * // do something * } * store.on('beforeDestroy', onBeforeDestroy); * * @callback Container~beforeDestroyListener * @param {string} name The `name` argument received by {@link Mapper#beforeDestroy}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeDestroy}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeDestroy}. * @see Container#event:beforeDestroy * @see Container#destroy * @since 3.0.0 */ /** * Fired during {@link Container#destroy}. See * {@link Container~afterDestroyListener} for how to listen for this event. * * @event Container#afterDestroy * @see Container~afterDestroyListener * @see Container#destroy */ /** * Callback signature for the {@link Container#event:afterDestroy} event. * * @example * function onAfterDestroy (mapperName, id, opts, result) { * // do something * } * store.on('afterDestroy', onAfterDestroy); * * @callback Container~afterDestroyListener * @param {string} name The `name` argument received by {@link Mapper#afterDestroy}. * @param {string|number} id The `id` argument received by {@link Mapper#afterDestroy}. * @param {object} opts The `opts` argument received by {@link Mapper#afterDestroy}. * @param {object} result The `result` argument received by {@link Mapper#afterDestroy}. * @see Container#event:afterDestroy * @see Container#destroy * @since 3.0.0 */ /** * Wrapper for {@link Mapper#destroy}. * * @example * // Destroy a specific blog post * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.destroy('post', 1234).then(() =&gt; { * // Blog post #1234 has been destroyed * }); * * @fires Container#beforeDestroy * @fires Container#afterDestroy * @method Container#destroy * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#destroy}. * @param {object} [opts] See {@link Mapper#destroy}. * @returns {Promise} See {@link Mapper#destroy}. * @see Mapper#destroy * @since 3.0.0 */ 'destroy', /** * Fired during {@link Container#destroyAll}. See * {@link Container~beforeDestroyAllListener} for how to listen for this event. * * @event Container#beforeDestroyAll * @see Container~beforeDestroyAllListener * @see Container#destroyAll */ /** * Callback signature for the {@link Container#event:beforeDestroyAll} event. * * @example * function onBeforeDestroyAll (mapperName, query, opts) { * // do something * } * store.on('beforeDestroyAll', onBeforeDestroyAll); * * @callback Container~beforeDestroyAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeDestroyAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeDestroyAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeDestroyAll}. * @see Container#event:beforeDestroyAll * @see Container#destroyAll * @since 3.0.0 */ /** * Fired during {@link Container#destroyAll}. See * {@link Container~afterDestroyAllListener} for how to listen for this event. * * @event Container#afterDestroyAll * @see Container~afterDestroyAllListener * @see Container#destroyAll */ /** * Callback signature for the {@link Container#event:afterDestroyAll} event. * * @example * function onAfterDestroyAll (mapperName, query, opts, result) { * // do something * } * store.on('afterDestroyAll', onAfterDestroyAll); * * @callback Container~afterDestroyAllListener * @param {string} name The `name` argument received by {@link Mapper#afterDestroyAll}. * @param {object} query The `query` argument received by {@link Mapper#afterDestroyAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterDestroyAll}. * @param {object} result The `result` argument received by {@link Mapper#afterDestroyAll}. * @see Container#event:afterDestroyAll * @see Container#destroyAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#destroyAll}. * * @example * // Destroy all \"draft\" blog posts * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.destroyAll('post', { status: 'draft' }).then(() =&gt; { * // All \"draft\" blog posts have been destroyed * }); * * @fires Container#beforeDestroyAll * @fires Container#afterDestroyAll * @method Container#destroyAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} [query] See {@link Mapper#destroyAll}. * @param {object} [opts] See {@link Mapper#destroyAll}. * @returns {Promise} See {@link Mapper#destroyAll}. * @see Mapper#destroyAll * @since 3.0.0 */ 'destroyAll', /** * Fired during {@link Container#find}. See * {@link Container~beforeFindListener} for how to listen for this event. * * @event Container#beforeFind * @see Container~beforeFindListener * @see Container#find */ /** * Callback signature for the {@link Container#event:beforeFind} event. * * @example * function onBeforeFind (mapperName, id, opts) { * // do something * } * store.on('beforeFind', onBeforeFind); * * @callback Container~beforeFindListener * @param {string} name The `name` argument received by {@link Mapper#beforeFind}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeFind}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeFind}. * @see Container#event:beforeFind * @see Container#find * @since 3.0.0 */ /** * Fired during {@link Container#find}. See * {@link Container~afterFindListener} for how to listen for this event. * * @event Container#afterFind * @see Container~afterFindListener * @see Container#find */ /** * Callback signature for the {@link Container#event:afterFind} event. * * @example * function onAfterFind (mapperName, id, opts, result) { * // do something * } * store.on('afterFind', onAfterFind); * * @callback Container~afterFindListener * @param {string} name The `name` argument received by {@link Mapper#afterFind}. * @param {string|number} id The `id` argument received by {@link Mapper#afterFind}. * @param {object} opts The `opts` argument received by {@link Mapper#afterFind}. * @param {object} result The `result` argument received by {@link Mapper#afterFind}. * @see Container#event:afterFind * @see Container#find * @since 3.0.0 */ /** * Wrapper for {@link Mapper#find}. * * @example * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.find('post', 1).then((post) =&gt; { * console.log(post) // { id: 1, ...} * }); * * @fires Container#beforeFind * @fires Container#afterFind * @method Container#find * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#find}. * @param {object} [opts] See {@link Mapper#find}. * @returns {Promise} See {@link Mapper#find}. * @see Mapper#find * @since 3.0.0 */ 'find', /** * Fired during {@link Container#findAll}. See * {@link Container~beforeFindAllListener} for how to listen for this event. * * @event Container#beforeFindAll * @see Container~beforeFindAllListener * @see Container#findAll */ /** * Callback signature for the {@link Container#event:beforeFindAll} event. * * @example * function onBeforeFindAll (mapperName, query, opts) { * // do something * } * store.on('beforeFindAll', onBeforeFindAll); * * @callback Container~beforeFindAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeFindAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeFindAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeFindAll}. * @see Container#event:beforeFindAll * @see Container#findAll * @since 3.0.0 */ /** * Fired during {@link Container#findAll}. See * {@link Container~afterFindAllListener} for how to listen for this event. * * @event Container#afterFindAll * @see Container~afterFindAllListener * @see Container#findAll */ /** * Callback signature for the {@link Container#event:afterFindAll} event. * * @example * function onAfterFindAll (mapperName, query, opts, result) { * // do something * } * store.on('afterFindAll', onAfterFindAll); * * @callback Container~afterFindAllListener * @param {string} name The `name` argument received by {@link Mapper#afterFindAll}. * @param {object} query The `query` argument received by {@link Mapper#afterFindAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterFindAll}. * @param {object} result The `result` argument received by {@link Mapper#afterFindAll}. * @see Container#event:afterFindAll * @see Container#findAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#createRecord}. * * @example * // Find all \"published\" blog posts * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.findAll('post', { status: 'published' }).then((posts) =&gt; { * console.log(posts); // [{ id: 1, ...}, ...] * }); * * @fires Container#beforeFindAll * @fires Container#afterFindAll * @method Container#findAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} [query] See {@link Mapper#findAll}. * @param {object} [opts] See {@link Mapper#findAll}. * @returns {Promise} See {@link Mapper#findAll}. * @see Mapper#findAll * @since 3.0.0 */ 'findAll', /** * Wrapper for {@link Mapper#getSchema}. * * @method Container#getSchema * @param {string} name Name of the {@link Mapper} to target. * @returns {Schema} See {@link Mapper#getSchema}. * @see Mapper#getSchema * @since 3.0.0 */ 'getSchema', /** * Wrapper for {@link Mapper#is}. * * @example * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('post'); * const post = store.createRecord(); * * console.log(store.is('post', post)); // true * // Equivalent to what's above * console.log(post instanceof store.getMapper('post').recordClass); // true * * @method Container#is * @param {string} name Name of the {@link Mapper} to target. * @param {Object|Record} record See {@link Mapper#is}. * @returns {boolean} See {@link Mapper#is}. * @see Mapper#is * @since 3.0.0 */ 'is', /** * Wrapper for {@link Mapper#sum}. * * @example * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('purchase_order'); * * store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { * console.log(amountPaid); // e.g. 451125.34 * }); * * @method Container#sum * @param {string} name Name of the {@link Mapper} to target. * @param {string} field See {@link Mapper#sum}. * @param {object} [query] See {@link Mapper#sum}. * @param {object} [opts] See {@link Mapper#sum}. * @returns {Promise} See {@link Mapper#sum}. * @see Mapper#sum * @since 3.0.0 */ 'sum', /** * Wrapper for {@link Mapper#toJSON}. * * @example * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('person', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }); * const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }); * // \"foo\" is stripped by toJSON() * console.log(store.toJSON('person', person)); // {\"id\":1,\"name\":\"John\"} * * store.defineMapper('personRelaxed', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * }, * additionalProperties: true * } * }); * const person2 = store.createRecord('personRelaxed', { id: 1, name: 'John', foo: 'bar' }); * // \"foo\" is not stripped by toJSON * console.log(store.toJSON('personRelaxed', person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} * * @method Container#toJSON * @param {string} name Name of the {@link Mapper} to target. * @param {Record|Record[]} records See {@link Mapper#toJSON}. * @param {object} [opts] See {@link Mapper#toJSON}. * @returns {Object|Object[]} See {@link Mapper#toJSON}. * @see Mapper#toJSON * @since 3.0.0 */ 'toJSON', /** * Fired during {@link Container#update}. See * {@link Container~beforeUpdateListener} for how to listen for this event. * * @event Container#beforeUpdate * @see Container~beforeUpdateListener * @see Container#update */ /** * Callback signature for the {@link Container#event:beforeUpdate} event. * * @example * function onBeforeUpdate (mapperName, id, props, opts) { * // do something * } * store.on('beforeUpdate', onBeforeUpdate); * * @callback Container~beforeUpdateListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdate}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeUpdate}. * @param {object} props The `props` argument received by {@link Mapper#beforeUpdate}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdate}. * @see Container#event:beforeUpdate * @see Container#update * @since 3.0.0 */ /** * Fired during {@link Container#update}. See * {@link Container~afterUpdateListener} for how to listen for this event. * * @event Container#afterUpdate * @see Container~afterUpdateListener * @see Container#update */ /** * Callback signature for the {@link Container#event:afterUpdate} event. * * @example * function onAfterUpdate (mapperName, id, props, opts, result) { * // do something * } * store.on('afterUpdate', onAfterUpdate); * * @callback Container~afterUpdateListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdate}. * @param {string|number} id The `id` argument received by {@link Mapper#afterUpdate}. * @param {object} props The `props` argument received by {@link Mapper#afterUpdate}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdate}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdate}. * @see Container#event:afterUpdate * @see Container#update * @since 3.0.0 */ /** * Wrapper for {@link Mapper#update}. * * @example * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.update('post', 1234, { * status: 'published', * published_at: new Date() * }).then((post) =&gt; { * console.log(post); // { id: 1234, status: 'published', ... } * }); * * @fires Container#beforeUpdate * @fires Container#afterUpdate * @method Container#update * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Mapper#update}. * @param {object} record See {@link Mapper#update}. * @param {object} [opts] See {@link Mapper#update}. * @returns {Promise} See {@link Mapper#update}. * @see Mapper#update * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/saving-data\",\"Saving data\"] */ 'update', /** * Fired during {@link Container#updateAll}. See * {@link Container~beforeUpdateAllListener} for how to listen for this event. * * @event Container#beforeUpdateAll * @see Container~beforeUpdateAllListener * @see Container#updateAll */ /** * Callback signature for the {@link Container#event:beforeUpdateAll} event. * * @example * function onBeforeUpdateAll (mapperName, props, query, opts) { * // do something * } * store.on('beforeUpdateAll', onBeforeUpdateAll); * * @callback Container~beforeUpdateAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} props The `props` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateAll}. * @see Container#event:beforeUpdateAll * @see Container#updateAll * @since 3.0.0 */ /** * Fired during {@link Container#updateAll}. See * {@link Container~afterUpdateAllListener} for how to listen for this event. * * @event Container#afterUpdateAll * @see Container~afterUpdateAllListener * @see Container#updateAll */ /** * Callback signature for the {@link Container#event:afterUpdateAll} event. * * @example * function onAfterUpdateAll (mapperName, props, query, opts, result) { * // do something * } * store.on('afterUpdateAll', onAfterUpdateAll); * * @callback Container~afterUpdateAllListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdateAll}. * @param {object} props The `props` argument received by {@link Mapper#afterUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#afterUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateAll}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateAll}. * @see Container#event:afterUpdateAll * @see Container#updateAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#updateAll}. * * @example * // Turn all of John's blog posts into drafts. * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * const update = { status: draft: published_at: null }; * const query = { userId: 1234 }; * store.updateAll('post', update, query).then((posts) =&gt; { * console.log(posts); // [...] * }); * * @fires Container#beforeUpdateAll * @fires Container#afterUpdateAll * @method Container#updateAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} update See {@link Mapper#updateAll}. * @param {object} [query] See {@link Mapper#updateAll}. * @param {object} [opts] See {@link Mapper#updateAll}. * @returns {Promise} See {@link Mapper#updateAll}. * @see Mapper#updateAll * @since 3.0.0 */ 'updateAll', /** * Fired during {@link Container#updateMany}. See * {@link Container~beforeUpdateManyListener} for how to listen for this event. * * @event Container#beforeUpdateMany * @see Container~beforeUpdateManyListener * @see Container#updateMany */ /** * Callback signature for the {@link Container#event:beforeUpdateMany} event. * * @example * function onBeforeUpdateMany (mapperName, records, opts) { * // do something * } * store.on('beforeUpdateMany', onBeforeUpdateMany); * * @callback Container~beforeUpdateManyListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdateMany}. * @param {object} records The `records` argument received by {@link Mapper#beforeUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateMany}. * @see Container#event:beforeUpdateMany * @see Container#updateMany * @since 3.0.0 */ /** * Fired during {@link Container#updateMany}. See * {@link Container~afterUpdateManyListener} for how to listen for this event. * * @event Container#afterUpdateMany * @see Container~afterUpdateManyListener * @see Container#updateMany */ /** * Callback signature for the {@link Container#event:afterUpdateMany} event. * * @example * function onAfterUpdateMany (mapperName, records, opts, result) { * // do something * } * store.on('afterUpdateMany', onAfterUpdateMany); * * @callback Container~afterUpdateManyListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdateMany}. * @param {object} records The `records` argument received by {@link Mapper#afterUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateMany}. * @see Container#event:afterUpdateMany * @see Container#updateMany * @since 3.0.0 */ /** * Wrapper for {@link Mapper#updateMany}. * * @example * import { Container } from 'js-data'; * import RethinkDBAdapter from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * store.defineMapper('post'); * * store.updateMany('post', [ * { id: 1234, status: 'draft' }, * { id: 2468, status: 'published', published_at: new Date() } * ]).then((posts) =&gt; { * console.log(posts); // [...] * }); * * @fires Container#beforeUpdateMany * @fires Container#afterUpdateMany * @method Container#updateMany * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#updateMany}. * @param {object} [opts] See {@link Mapper#updateMany}. * @returns {Promise} See {@link Mapper#updateMany}. * @see Mapper#updateMany * @since 3.0.0 */ 'updateMany', /** * Wrapper for {@link Mapper#validate}. * * @example * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('post', { * schema: { * properties: { * name: { type: 'string' }, * id: { type: 'string' } * } * } * }); * let errors = store.validate('post', { name: 'John' }); * console.log(errors); // undefined * errors = store.validate('post', { name: 123 }); * console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] * * @method Container#validate * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records See {@link Mapper#validate}. * @param {object} [opts] See {@link Mapper#validate}. * @returns {Promise} See {@link Mapper#validate}. * @see Mapper#validate * @since 3.0.0 */ 'validate' ] /** * The `Container` class is a place to define and store {@link Mapper} instances. * * `Container` makes it easy to manage your Mappers. Without a container, you * need to manage Mappers yourself, including resolving circular dependencies * among relations. All Mappers in a container share the same adapters, so you * don't have to register adapters for every single Mapper. * * @example &lt;caption&gt;Container#constructor&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const {Container} = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * * @class Container * @extends Component * @param {object} [opts] Configuration options. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @param {Constructor} [opts.mapperClass] See {@link Container#mapperClass}. * @param {object} [opts.mapperDefaults] See {@link Container#mapperDefaults}. * @since 3.0.0 */ export function Container (opts) { utils.classCallCheck(this, Container) Component.call(this) opts || (opts = {}) Object.defineProperties(this, { /** * The adapters registered with this Container, which are also shared by all * Mappers in this Container. * * @name Container#_adapters * @see Container#registerAdapter * @since 3.0.0 * @type {Object} */ _adapters: { value: {} }, /** * The the mappers in this container * * @name Container#_mappers * @see Mapper * @since 3.0.0 * @type {Object} */ _mappers: { value: {} }, /** * Constructor function to use in {@link Container#defineMapper} to create new * {@link Mapper} instances. {@link Container#mapperClass} should extend * {@link Mapper}. By default {@link Mapper} is used to instantiate Mappers. * * @example &lt;caption&gt;Container#mapperClass&lt;/caption&gt; * // import { Container, Mapper } from 'js-data'; * const JSData = require('js-data'); * const { Container, Mapper } = JSData; * console.log('Using JSData v' + JSData.version.full); * * class MyMapperClass extends Mapper { * foo () { return 'bar' } * } * const store = new Container({ * mapperClass: MyMapperClass * }); * store.defineMapper('user'); * console.log(store.getMapper('user').foo()); * * @name Container#mapperClass * @see Mapper * @since 3.0.0 * @type {Constructor} */ mapperClass: { value: undefined, writable: true } }) // Apply options provided by the user utils.fillIn(this, opts) /** * Defaults options to pass to {@link Container#mapperClass} when creating a * new {@link Mapper}. * * @example &lt;caption&gt;Container#mapperDefaults&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container({ * mapperDefaults: { * idAttribute: '_id' * } * }); * store.defineMapper('user'); * console.log(store.getMapper('user').idAttribute); * * @default {} * @name Container#mapperDefaults * @since 3.0.0 * @type {Object} */ this.mapperDefaults = this.mapperDefaults || {} // Use the Mapper class if the user didn't provide a mapperClass this.mapperClass || (this.mapperClass = Mapper) } const props = { constructor: Container, /** * Register a new event listener on this Container. * * Proxy for {@link Component#on}. If an event was emitted by a {@link Mapper} * in the Container, then the name of the {@link Mapper} will be prepended to * the arugments passed to the listener. * * @example &lt;caption&gt;Container#on&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.on('foo', function (...args) { console.log(args.join(':')) }); * store.defineMapper('user'); * store.emit('foo', 'arg1', 'arg2'); * store.getMapper('user').emit('foo', 'arg1', 'arg2'); * * @method Container#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Used to bind to events emitted by mappers in this container. * * @method Container#_onMapperEvent * @param {string} name Name of the mapper that emitted the event. * @param {...*} [args] Args See {@link Mapper#emit}. * @private * @since 3.0.0 */ _onMapperEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * Return a container scoped to a particular mapper. * * @example &lt;caption&gt;Container#as&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * const UserMapper = store.defineMapper('user'); * const UserStore = store.as('user'); * * const user1 = store.createRecord('user', { name: 'John' }); * const user2 = UserStore.createRecord({ name: 'John' }); * const user3 = UserMapper.createRecord({ name: 'John' }); * console.log(user1 === user2); * console.log(user2 === user3); * console.log(user1 === user3); * * @method Container#as * @param {string} name Name of the {@link Mapper}. * @returns {Object} A container scoped to a particular mapper. * @since 3.0.0 */ as (name) { const props = {} const original = this proxiedMapperMethods.forEach(function (method) { props[method] = { writable: true, value (...args) { return original[method](name, ...args) } } }) props.getMapper = { writable: true, value () { return original.getMapper(name) } } return Object.create(this, props) }, /** * Create a new mapper and register it in this container. * * @example &lt;caption&gt;Container#defineMapper&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container({ * mapperDefaults: { foo: 'bar' } * }); * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user'); * console.log(UserMapper === store.getMapper('user')); * console.log(UserMapper === store.as('user').getMapper()); * console.log(UserMapper.foo); * * @method Container#defineMapper * @param {string} name Name under which to register the new {@link Mapper}. * {@link Mapper#name} will be set to this value. * @param {object} [opts] Configuration options. Passed to * {@link Container#mapperClass} when creating the new {@link Mapper}. * @returns {Mapper} The newly created instance of {@link Mapper}. * @see Container#as * @since 3.0.0 */ defineMapper (name, opts) { // For backwards compatibility with defineResource if (utils.isObject(name)) { opts = name name = opts.name } if (!utils.isString(name)) { throw utils.err(`${DOMAIN}#defineMapper`, 'name')(400, 'string', name) } // Default values for arguments opts || (opts = {}) // Set Mapper#name opts.name = name opts.relations || (opts.relations = {}) // Check if the user is overriding the datastore's default mapperClass const mapperClass = opts.mapperClass || this.mapperClass delete opts.mapperClass // Apply the datastore's defaults to the options going into the mapper utils.fillIn(opts, this.mapperDefaults) // Instantiate a mapper const mapper = this._mappers[name] = new mapperClass(opts) // eslint-disable-line mapper.relations || (mapper.relations = {}) // Make sure the mapper's name is set mapper.name = name // All mappers in this datastore will share adapters mapper._adapters = this.getAdapters() mapper.datastore = this mapper.on('all', (...args) =&gt; this._onMapperEvent(name, ...args)) mapper.defineRelations() return mapper }, defineResource (name, opts) { console.warn('DEPRECATED: defineResource is deprecated, use defineMapper instead') return this.defineMapper(name, opts) }, /** * Return the registered adapter with the given name or the default adapter if * no name is provided. * * @method Container#getAdapter * @param {string} [name] The name of the adapter to retrieve. * @returns {Adapter} The adapter. * @since 3.0.0 */ getAdapter (name) { const adapter = this.getAdapterName(name) if (!adapter) { throw utils.err(`${DOMAIN}#getAdapter`, 'name')(400, 'string', name) } return this.getAdapters()[adapter] }, /** * Return the name of a registered adapter based on the given name or options, * or the name of the default adapter if no name provided. * * @method Container#getAdapterName * @param {(Object|string)} [opts] The name of an adapter or options, if any. * @returns {string} The name of the adapter. * @since 3.0.0 */ getAdapterName (opts) { opts || (opts = {}) if (utils.isString(opts)) { opts = { adapter: opts } } return opts.adapter || this.mapperDefaults.defaultAdapter }, /** * Return the registered adapters of this container. * * @method Container#getAdapters * @returns {Adapter} * @since 3.0.0 */ getAdapters () { return this._adapters }, /** * Return the mapper registered under the specified name. * * @example &lt;caption&gt;Container#getMapper&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user'); * console.log(UserMapper === store.getMapper('user')); * console.log(UserMapper === store.as('user').getMapper()); * store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" * * @method Container#getMapper * @param {string} name {@link Mapper#name}. * @returns {Mapper} * @since 3.0.0 */ getMapper (name) { const mapper = this.getMapperByName(name) if (!mapper) { throw utils.err(`${DOMAIN}#getMapper`, name)(404, 'mapper') } return mapper }, /** * Return the mapper registered under the specified name. * Doesn't throw error if mapper doesn't exist. * * @example &lt;caption&gt;Container#getMapperByName&lt;/caption&gt; * // import { Container } from 'js-data'; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * // Container#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user'); * console.log(UserMapper === store.getMapper('user')); * console.log(UserMapper === store.as('user').getMapper()); * console.log(store.getMapper('profile')); // Does NOT throw an error * * @method Container#getMapperByName * @param {string} name {@link Mapper#name}. * @returns {Mapper} * @since 3.0.0 */ getMapperByName (name) { return this._mappers[name] }, /** * Register an adapter on this container under the given name. Adapters * registered on a container are shared by all mappers in the container. * * @example * import { Container } from 'js-data'; * import { RethinkDBAdapter } from 'js-data-rethinkdb'; * const store = new Container(); * store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); * * @method Container#registerAdapter * @param {string} name The name of the adapter to register. * @param {Adapter} adapter The adapter to register. * @param {object} [opts] Configuration options. * @param {boolean} [opts.default=false] Whether to make the adapter the * default adapter for all Mappers in this container. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/connecting-to-a-data-source\",\"Connecting to a data source\"] */ registerAdapter (name, adapter, opts) { opts || (opts = {}) this.getAdapters()[name] = adapter // Optionally make it the default adapter for the target. if (opts === true || opts.default) { this.mapperDefaults.defaultAdapter = name utils.forOwn(this._mappers, function (mapper) { mapper.defaultAdapter = name }) } } } proxiedMapperMethods.forEach(function (method) { props[method] = function (name, ...args) { return this.getMapper(name)[method](...args) } }) Component.extend(props) /** * Create a subclass of this Container: * @example &lt;caption&gt;Container.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomContainerClass extends Container { * foo () { return 'bar' } * static beep () { return 'boop' } * } * const customContainer = new CustomContainerClass(); * console.log(customContainer.foo()); * console.log(CustomContainerClass.beep()); * * // Extend the class using alternate method. * const OtherContainerClass = Container.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherContainer = new OtherContainerClass(); * console.log(otherContainer.foo()); * console.log(OtherContainerClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherContainerClass () { * Container.call(this); * this.created_at = new Date().getTime(); * } * Container.extend({ * constructor: AnotherContainerClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherContainer = new AnotherContainerClass(); * console.log(anotherContainer.created_at); * console.log(anotherContainer.foo()); * console.log(AnotherContainerClass.beep()); * * @method Container.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Container class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"DataStore.js.html":{"id":"DataStore.js.html","title":"Source: DataStore.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: DataStore.js import utils, { safeSetLink, safeSetProp } from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import SimpleStore from './SimpleStore' import LinkedCollection from './LinkedCollection' const DATASTORE_DEFAULTS = { /** * Whether in-memory relations should be unlinked from records after they are * destroyed. * * @default true * @name DataStore#unlinkOnDestroy * @since 3.0.0 * @type {boolean} */ unlinkOnDestroy: true } /** * The `DataStore` class is an extension of {@link SimpleStore}. Not only does * `DataStore` manage mappers and store data in collections, it uses the * {@link LinkedCollection} class to link related records together in memory. * * ```javascript * import { DataStore } from 'js-data'; * ``` * * @example * import { DataStore } from 'js-data'; * import HttpAdapter from 'js-data-http'; * const store = new DataStore(); * * // DataStore#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user'); * * // DataStore#as returns the store scoped to a particular Mapper. * const UserStore = store.as('user'); * * // Call \"find\" on \"UserMapper\" (Stateless ORM) * UserMapper.find(1).then((user) =&gt; { * // retrieved a \"user\" record via the http adapter, but that's it * * // Call \"find\" on \"store\" targeting \"user\" (Stateful DataStore) * return store.find('user', 1); // same as \"UserStore.find(1)\" * }).then((user) =&gt; { * // not only was a \"user\" record retrieved, but it was added to the * // store's \"user\" collection * const cachedUser = store.getCollection('user').get(1); * console.log(user === cachedUser); // true * }); * * @class DataStore * @extends SimpleStore * @param {object} [opts] Configuration options. See {@link SimpleStore}. * @param {boolean} [opts.collectionClass={@link LinkedCollection}] See {@link DataStore#collectionClass}. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @param {boolean} [opts.unlinkOnDestroy=true] See {@link DataStore#unlinkOnDestroy}. * @param {boolean|Function} [opts.usePendingFind=true] See {@link DataStore#usePendingFind}. * @param {boolean|Function} [opts.usePendingFindAll=true] See {@link DataStore#usePendingFindAll}. * @returns {DataStore} * @see SimpleStore * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore\",\"Components of JSData: DataStore\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/working-with-the-datastore\",\"Working with the DataStore\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/jsdata-and-the-browser\",\"Notes on using JSData in the Browser\"] */ function DataStore (opts) { utils.classCallCheck(this, DataStore) opts || (opts = {}) // Fill in any missing options with the defaults utils.fillIn(opts, DATASTORE_DEFAULTS) opts.collectionClass || (opts.collectionClass = LinkedCollection) SimpleStore.call(this, opts) } const props = { constructor: DataStore, defineMapper (name, opts) { // Complexity of this method is beyond simply using =&gt; functions to bind context const self = this const mapper = SimpleStore.prototype.defineMapper.call(self, name, opts) const idAttribute = mapper.idAttribute const collection = this.getCollection(name) mapper.relationList.forEach(function (def) { const relation = def.relation const localField = def.localField const path = `links.${localField}` const foreignKey = def.foreignKey const type = def.type const updateOpts = { index: foreignKey } let descriptor const getter = function () { return this._get(path) } if (type === belongsToType) { if (!collection.indexes[foreignKey]) { collection.createIndex(foreignKey) } descriptor = { get: getter, // e.g. profile.user = someUser // or comment.post = somePost set (record) { // e.g. const otherUser = profile.user const currentParent = this._get(path) // e.g. profile.user === someUser if (record === currentParent) { return currentParent } const id = utils.get(this, idAttribute) const inverseDef = def.getInverse(mapper) // e.g. profile.user !== someUser // or comment.post !== somePost if (currentParent &amp;&amp; inverseDef) { this.removeInverseRelation(currentParent, id, inverseDef, idAttribute) } if (record) { // e.g. profile.user = someUser const relatedIdAttribute = def.getRelation().idAttribute const relatedId = utils.get(record, relatedIdAttribute) // Prefer store record if (relatedId !== undefined &amp;&amp; this._get('$')) { record = self.get(relation, relatedId) || record } // Set locals // e.g. profile.user = someUser // or comment.post = somePost safeSetLink(this, localField, record) safeSetProp(this, foreignKey, relatedId) collection.updateIndex(this, updateOpts) if (inverseDef) { this.setupInverseRelation(record, id, inverseDef, idAttribute) } } else { // Unset in-memory link only // e.g. profile.user = undefined // or comment.post = undefined safeSetLink(this, localField, undefined) } return record } } let foreignKeyDescriptor = Object.getOwnPropertyDescriptor(mapper.recordClass.prototype, foreignKey) if (!foreignKeyDescriptor) { foreignKeyDescriptor = { enumerable: true } } const originalGet = foreignKeyDescriptor.get foreignKeyDescriptor.get = function () { if (originalGet) { return originalGet.call(this) } return this._get(`props.${foreignKey}`) } const originalSet = foreignKeyDescriptor.set foreignKeyDescriptor.set = function (value) { if (originalSet) { originalSet.call(this, value) } const currentParent = utils.get(this, localField) const id = utils.get(this, idAttribute) const inverseDef = def.getInverse(mapper) const currentParentId = currentParent ? utils.get(currentParent, def.getRelation().idAttribute) : undefined if (inverseDef &amp;&amp; currentParent &amp;&amp; currentParentId !== undefined &amp;&amp; currentParentId !== value) { if (inverseDef.type === hasOneType) { safeSetLink(currentParent, inverseDef.localField, undefined) } else if (inverseDef.type === hasManyType) { const children = utils.get(currentParent, inverseDef.localField) if (id === undefined) { utils.remove(children, (child) =&gt; child === this) } else { utils.remove(children, (child) =&gt; child === this || id === utils.get(child, idAttribute)) } } } safeSetProp(this, foreignKey, value) collection.updateIndex(this, updateOpts) if ((value === undefined || value === null)) { if (currentParentId !== undefined) { // Unset locals utils.set(this, localField, undefined) } } else if (this._get('$')) { const storeRecord = self.get(relation, value) if (storeRecord) { utils.set(this, localField, storeRecord) } } } Object.defineProperty(mapper.recordClass.prototype, foreignKey, foreignKeyDescriptor) } else if (type === hasManyType) { const localKeys = def.localKeys const foreignKeys = def.foreignKeys // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get () { let current = getter.call(this) if (!current) { this._set(path, []) } return getter.call(this) }, // e.g. post.comments = someComments // or user.groups = someGroups // or group.users = someUsers set (records) { if (records &amp;&amp; !utils.isArray(records)) { records = [records] } const id = utils.get(this, idAttribute) const relatedIdAttribute = def.getRelation().idAttribute const inverseDef = def.getInverse(mapper) const inverseLocalField = inverseDef.localField const current = this._get(path) || [] const toLink = [] const toLinkIds = {} if (records) { records.forEach((record) =&gt; { // e.g. comment.id const relatedId = utils.get(record, relatedIdAttribute) const currentParent = utils.get(record, inverseLocalField) if (currentParent &amp;&amp; currentParent !== this) { const currentChildrenOfParent = utils.get(currentParent, localField) // e.g. somePost.comments.remove(comment) if (relatedId === undefined) { utils.remove(currentChildrenOfParent, (child) =&gt; child === record) } else { utils.remove(currentChildrenOfParent, (child) =&gt; child === record || relatedId === utils.get(child, relatedIdAttribute)) } } if (relatedId !== undefined) { if (this._get('$')) { // Prefer store record record = self.get(relation, relatedId) || record } // e.g. toLinkIds[comment.id] = comment toLinkIds[relatedId] = record } toLink.push(record) }) } // e.g. post.comments = someComments if (foreignKey) { current.forEach((record) =&gt; { // e.g. comment.id const relatedId = utils.get(record, relatedIdAttribute) if ((relatedId === undefined &amp;&amp; toLink.indexOf(record) === -1) || (relatedId !== undefined &amp;&amp; !(relatedId in toLinkIds))) { // Update (unset) inverse relation if (records) { // e.g. comment.post_id = undefined safeSetProp(record, foreignKey, undefined) // e.g. CommentCollection.updateIndex(comment, { index: 'post_id' }) self.getCollection(relation).updateIndex(record, updateOpts) } // e.g. comment.post = undefined safeSetLink(record, inverseLocalField, undefined) } }) toLink.forEach((record) =&gt; { // Update (set) inverse relation // e.g. comment.post_id = post.id safeSetProp(record, foreignKey, id) // e.g. CommentCollection.updateIndex(comment, { index: 'post_id' }) self.getCollection(relation).updateIndex(record, updateOpts) // e.g. comment.post = post safeSetLink(record, inverseLocalField, this) }) } else if (localKeys) { // Update locals // e.g. group.users = someUsers // Update (set) inverse relation const ids = toLink.map((child) =&gt; utils.get(child, relatedIdAttribute)).filter((id) =&gt; id !== undefined) // e.g. group.user_ids = [1,2,3,...] utils.set(this, localKeys, ids) // Update (unset) inverse relation if (inverseDef.foreignKeys) { current.forEach((child) =&gt; { const relatedId = utils.get(child, relatedIdAttribute) if ((relatedId === undefined &amp;&amp; toLink.indexOf(child) === -1) || (relatedId !== undefined &amp;&amp; !(relatedId in toLinkIds))) { // Update inverse relation // safeSetLink(child, inverseLocalField, undefined) const parents = utils.get(child, inverseLocalField) || [] // e.g. someUser.groups.remove(group) if (id === undefined) { utils.remove(parents, (parent) =&gt; parent === this) } else { utils.remove(parents, (parent) =&gt; parent === this || id === utils.get(parent, idAttribute)) } } }) toLink.forEach((child) =&gt; { // Update (set) inverse relation const parents = utils.get(child, inverseLocalField) // e.g. someUser.groups.push(group) if (id === undefined) { utils.noDupeAdd(parents, this, (parent) =&gt; parent === this) } else { utils.noDupeAdd(parents, this, (parent) =&gt; parent === this || id === utils.get(parent, idAttribute)) } }) } } else if (foreignKeys) { // e.g. user.groups = someGroups // Update (unset) inverse relation current.forEach((parent) =&gt; { const ids = utils.get(parent, foreignKeys) || [] // e.g. someGroup.user_ids.remove(user.id) utils.remove(ids, (_key) =&gt; id === _key) const children = utils.get(parent, inverseLocalField) // e.g. someGroup.users.remove(user) if (id === undefined) { utils.remove(children, (child) =&gt; child === this) } else { utils.remove(children, (child) =&gt; child === this || id === utils.get(child, idAttribute)) } }) // Update (set) inverse relation toLink.forEach((parent) =&gt; { const ids = utils.get(parent, foreignKeys) || [] utils.noDupeAdd(ids, id, (_key) =&gt; id === _key) const children = utils.get(parent, inverseLocalField) if (id === undefined) { utils.noDupeAdd(children, this, (child) =&gt; child === this) } else { utils.noDupeAdd(children, this, (child) =&gt; child === this || id === utils.get(child, idAttribute)) } }) } this._set(path, toLink) return toLink } } } else if (type === hasOneType) { // TODO: Handle case when belongsTo relation isn't ever defined if (self._collections[relation] &amp;&amp; foreignKey &amp;&amp; !self.getCollection(relation).indexes[foreignKey]) { self.getCollection(relation).createIndex(foreignKey) } descriptor = { get: getter, // e.g. user.profile = someProfile set (record) { const current = this._get(path) if (record === current) { return current } const inverseLocalField = def.getInverse(mapper).localField // Update (unset) inverse relation if (current) { safeSetProp(current, foreignKey, undefined) self.getCollection(relation).updateIndex(current, updateOpts) safeSetLink(current, inverseLocalField, undefined) } if (record) { const relatedId = utils.get(record, def.getRelation().idAttribute) // Prefer store record if (relatedId !== undefined) { record = self.get(relation, relatedId) || record } // Set locals safeSetLink(this, localField, record) // Update (set) inverse relation safeSetProp(record, foreignKey, utils.get(this, idAttribute)) self.getCollection(relation).updateIndex(record, updateOpts) safeSetLink(record, inverseLocalField, this) } else { // Unset locals safeSetLink(this, localField, undefined) } return record } } } if (descriptor) { descriptor.enumerable = def.enumerable === undefined ? false : def.enumerable if (def.get) { let origGet = descriptor.get descriptor.get = function () { return def.get(def, this, (...args) =&gt; origGet.apply(this, args)) } } if (def.set) { let origSet = descriptor.set descriptor.set = function (related) { return def.set(def, this, related, (value) =&gt; origSet.call(this, value === undefined ? related : value)) } } Object.defineProperty(mapper.recordClass.prototype, localField, descriptor) } }) return mapper }, destroy (name, id, opts) { opts || (opts = {}) return SimpleStore.prototype.destroy.call(this, name, id, opts).then((result) =&gt; { let record if (opts.raw) { record = result.data } else { record = result } if (record &amp;&amp; this.unlinkOnDestroy) { const _opts = utils.plainCopy(opts) _opts.withAll = true utils.forEachRelation(this.getMapper(name), _opts, (def) =&gt; { utils.set(record, def.localField, undefined) }) } return result }) }, destroyAll (name, query, opts) { opts || (opts = {}) return SimpleStore.prototype.destroyAll.call(this, name, query, opts).then((result) =&gt; { let records if (opts.raw) { records = result.data } else { records = result } if (records &amp;&amp; records.length &amp;&amp; this.unlinkOnDestroy) { const _opts = utils.plainCopy(opts) _opts.withAll = true utils.forEachRelation(this.getMapper(name), _opts, (def) =&gt; { records.forEach((record) =&gt; { utils.set(record, def.localField, undefined) }) }) } return result }) } } export default SimpleStore.extend(props) /** * Create a subclass of this DataStore: * @example &lt;caption&gt;DataStore.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomDataStoreClass extends DataStore { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customDataStore = new CustomDataStoreClass(); * console.log(customDataStore.foo()); * console.log(CustomDataStoreClass.beep()); * * // Extend the class using alternate method. * const OtherDataStoreClass = DataStore.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherDataStore = new OtherDataStoreClass(); * console.log(otherDataStore.foo()); * console.log(OtherDataStoreClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherDataStoreClass () { * DataStore.call(this); * this.created_at = new Date().getTime(); * } * DataStore.extend({ * constructor: AnotherDataStoreClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherDataStore = new AnotherDataStoreClass(); * console.log(anotherDataStore.created_at); * console.log(anotherDataStore.foo()); * console.log(AnotherDataStoreClass.beep()); * * @method DataStore.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this DataStore class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"SimpleStore.js.html":{"id":"SimpleStore.js.html","title":"Source: SimpleStore.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: SimpleStore.js import utils from './utils' import { belongsToType, hasManyType, hasOneType } from './decorators' import {proxiedMapperMethods, Container} from './Container' import Collection from './Collection' const DOMAIN = 'SimpleStore' const proxiedCollectionMethods = [ /** * Wrapper for {@link Collection#add}. * * @example &lt;caption&gt;SimpleStore#add&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * store.defineMapper('book'); * * // Add one book to the in-memory store: * store.add('book', { id: 1, title: 'Respect your Data' }); * // Add multiple books to the in-memory store: * store.add('book', [ * { id: 2, title: 'Easy data recipes' }, * { id: 3, title: 'Active Record 101' } * ]); * * @fires SimpleStore#add * @method SimpleStore#add * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {(Object|Object[]|Record|Record[])} data See {@link Collection#add}. * @param {object} [opts] Configuration options. See {@link Collection#add}. * @returns {(Object|Object[]|Record|Record[])} See {@link Collection#add}. * @see Collection#add * @see Collection#add * @since 3.0.0 */ 'add', /** * Wrapper for {@link Collection#between}. * * @example * // Get all users ages 18 to 30 * const users = store.between('user', 18, 30, { index: 'age' }); * * @example * // Same as above * const users = store.between('user', [18], [30], { index: 'age' }); * * @method SimpleStore#between * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {array} leftKeys See {@link Collection#between}. * @param {array} rightKeys See {@link Collection#between}. * @param {object} [opts] Configuration options. See {@link Collection#between}. * @returns {Object[]|Record[]} See {@link Collection#between}. * @see Collection#between * @see Collection#between * @since 3.0.0 */ 'between', /** * Wrapper for {@link Collection#createIndex}. * * @example * // Index users by age * store.createIndex('user', 'age'); * * @example * // Index users by status and role * store.createIndex('user', 'statusAndRole', ['status', 'role']); * * @method SimpleStore#createIndex * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {string} name See {@link Collection#createIndex}. * @param {string[]} [fieldList] See {@link Collection#createIndex}. * @see Collection#createIndex * @see Collection#createIndex * @since 3.0.0 */ 'createIndex', /** * Wrapper for {@link Collection#filter}. * * @example &lt;caption&gt;SimpleStore#filter&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * store.defineMapper('post'); * store.add('post', [ * { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } * ]); * * // Get the draft posts created less than three months ago * let posts = store.filter('post', { * where: { * status: { * '==': 'draft' * }, * created_at_timestamp: { * '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago * } * } * }); * console.log(posts); * * // Use a custom filter function * posts = store.filter('post', function (post) { return post.id % 2 === 0 }); * * @method SimpleStore#filter * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {(Object|Function)} [queryOrFn={}] See {@link Collection#filter}. * @param {object} [thisArg] See {@link Collection#filter}. * @returns {Array} See {@link Collection#filter}. * @see Collection#filter * @see Collection#filter * @since 3.0.0 */ 'filter', /** * Wrapper for {@link Collection#get}. * * @example &lt;caption&gt;SimpleStore#get&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * store.defineMapper('post'); * store.add('post', [ * { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } * ]); * * console.log(store.get('post', 1)); // {...} * console.log(store.get('post', 2)); // undefined * * @method SimpleStore#get * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {(string|number)} id See {@link Collection#get}. * @returns {(Object|Record)} See {@link Collection#get}. * @see Collection#get * @see Collection#get * @since 3.0.0 */ 'get', /** * Wrapper for {@link Collection#getAll}. * * @example * // Get the posts where \"status\" is \"draft\" or \"inReview\" * const posts = store.getAll('post', 'draft', 'inReview', { index: 'status' }); * * @example * // Same as above * const posts = store.getAll('post', ['draft'], ['inReview'], { index: 'status' }); * * @method SimpleStore#getAll * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {...Array} [keyList] See {@link Collection#getAll}. * @param {object} [opts] See {@link Collection#getAll}. * @returns {Array} See {@link Collection#getAll}. * @see Collection#getAll * @see Collection#getAll * @since 3.0.0 */ 'getAll', /** * Wrapper for {@link Collection#prune}. * * @method SimpleStore#prune * @param {object} [opts] See {@link Collection#prune}. * @returns {Array} See {@link Collection#prune}. * @see Collection#prune * @see Collection#prune * @since 3.0.0 */ 'prune', /** * Wrapper for {@link Collection#query}. * * @example * // Grab page 2 of users between ages 18 and 30 * store.query('user') * .between(18, 30, { index: 'age' }) // between ages 18 and 30 * .skip(10) // second page * .limit(10) // page size * .run(); * * @method SimpleStore#query * @param {(string|number)} name Name of the {@link Mapper} to target. * @returns {Query} See {@link Collection#query}. * @see Collection#query * @see Collection#query * @since 3.0.0 */ 'query', /** * Wrapper for {@link Collection#toJSON}. * * @example * store.defineMapper('post', { * schema: { * properties: { * id: { type: 'number' }, * title: { type: 'string' } * } * } * }); * store.add('post', [ * { id: 1, status: 'published', title: 'Respect your Data' }, * { id: 2, status: 'draft', title: 'Connecting to a data source' } * ]); * console.log(store.toJSON('post')); * const draftsJSON = store.query('post') * .filter({ status: 'draft' }) * .mapCall('toJSON') * .run(); * * @method SimpleStore#toJSON * @param {(string|number)} name Name of the {@link Mapper} to target. * @param {object} [opts] See {@link Collection#toJSON}. * @returns {Array} See {@link Collection#toJSON}. * @see Collection#toJSON * @see Collection#toJSON * @since 3.0.0 */ 'toJSON', /** * Wrapper for {@link Collection#unsaved}. * * @method SimpleStore#unsaved * @returns {Array} See {@link Collection#unsaved}. * @see Collection#unsaved * @see Collection#unsaved * @since 3.0.0 */ 'unsaved' ] const ownMethodsForScoping = [ 'addToCache', 'cachedFind', 'cachedFindAll', 'cacheFind', 'cacheFindAll', 'hashQuery' ] const cachedFn = function (name, hashOrId, opts) { const cached = this._completedQueries[name][hashOrId] if (utils.isFunction(cached)) { return cached(name, hashOrId, opts) } return cached } const SIMPLESTORE_DEFAULTS = { /** * Whether to use the pending query if a `find` request for the specified * record is currently underway. Can be set to `true`, `false`, or to a * function that returns `true` or `false`. * * @default true * @name SimpleStore#usePendingFind * @since 3.0.0 * @type {boolean|Function} */ usePendingFind: true, /** * Whether to use the pending query if a `findAll` request for the given query * is currently underway. Can be set to `true`, `false`, or to a function that * returns `true` or `false`. * * @default true * @name SimpleStore#usePendingFindAll * @since 3.0.0 * @type {boolean|Function} */ usePendingFindAll: true } /** * The `SimpleStore` class is an extension of {@link Container}. Not only does * `SimpleStore` manage mappers, but also collections. `SimpleStore` implements the * asynchronous {@link Mapper} methods, such as {@link Mapper#find} and * {@link Mapper#create}. If you use the asynchronous `SimpleStore` methods * instead of calling them directly on the mappers, then the results of the * method calls will be inserted into the store's collections. You can think of * a `SimpleStore` as an [Identity Map](https://en.wikipedia.org/wiki/Identity_map_pattern) * for the [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping) * (the Mappers). * * ```javascript * import { SimpleStore } from 'js-data'; * ``` * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * const store = new SimpleStore(); * * // SimpleStore#defineMapper returns a direct reference to the newly created * // Mapper. * const UserMapper = store.defineMapper('user'); * * // SimpleStore#as returns the store scoped to a particular Mapper. * const UserStore = store.as('user'); * * // Call \"find\" on \"UserMapper\" (Stateless ORM) * UserMapper.find(1).then((user) =&gt; { * // retrieved a \"user\" record via the http adapter, but that's it * * // Call \"find\" on \"store\" targeting \"user\" (Stateful SimpleStore) * return store.find('user', 1); // same as \"UserStore.find(1)\" * }).then((user) =&gt; { * // not only was a \"user\" record retrieved, but it was added to the * // store's \"user\" collection * const cachedUser = store.getCollection('user').get(1); * console.log(user === cachedUser); // true * }); * * @class SimpleStore * @extends Container * @param {object} [opts] Configuration options. See {@link Container}. * @param {boolean} [opts.collectionClass={@link Collection}] See {@link SimpleStore#collectionClass}. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @param {boolean|Function} [opts.usePendingFind=true] See {@link SimpleStore#usePendingFind}. * @param {boolean|Function} [opts.usePendingFindAll=true] See {@link SimpleStore#usePendingFindAll}. * @returns {SimpleStore} * @see Container * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#SimpleStore\",\"Components of JSData: SimpleStore\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/working-with-the-SimpleStore\",\"Working with the SimpleStore\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/jsdata-and-the-browser\",\"Notes on using JSData in the Browser\"] */ function SimpleStore (opts) { utils.classCallCheck(this, SimpleStore) opts || (opts = {}) // Fill in any missing options with the defaults utils.fillIn(opts, SIMPLESTORE_DEFAULTS) Container.call(this, opts) this.collectionClass = this.collectionClass || Collection this._collections = {} this._pendingQueries = {} this._completedQueries = {} } const props = { constructor: SimpleStore, /** * Internal method used to handle Mapper responses. * * @method SimpleStore#_end * @private * @param {string} name Name of the {@link Collection} to which to * add the data. * @param {object} result The result from a Mapper. * @param {object} [opts] Configuration options. * @returns {(Object|Array)} Result. */ _end (name, result, opts) { let data = opts.raw ? result.data : result if (data &amp;&amp; utils.isFunction(this.addToCache)) { data = this.addToCache(name, data, opts) if (opts.raw) { result.data = data } else { result = data } } return result }, /** * Register a new event listener on this SimpleStore. * * Proxy for {@link Container#on}. If an event was emitted by a Mapper or * Collection in the SimpleStore, then the name of the Mapper or Collection will * be prepended to the arugments passed to the provided event handler. * * @example * // Listen for all \"afterCreate\" events in a SimpleStore * store.on('afterCreate', (mapperName, props, opts, result) =&gt; { * console.log(mapperName); // \"post\" * console.log(props.id); // undefined * console.log(result.id); // 1234 * }); * store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { * console.log(post.id); // 1234 * }); * * @example * // Listen for the \"add\" event on a collection * store.on('add', (mapperName, records) =&gt; { * console.log(records); // [...] * }); * * @example * // Listen for \"change\" events on a record * store.on('change', (mapperName, record, changes) =&gt; { * console.log(changes); // { changed: { title: 'Modeling your data' } } * }); * post.title = 'Modeling your data'; * * @method SimpleStore#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. */ /** * Used to bind to events emitted by collections in this store. * * @method SimpleStore#_onCollectionEvent * @private * @param {string} name Name of the collection that emitted the event. * @param {...*} [args] Args passed to {@link Collection#emit}. */ _onCollectionEvent (name, ...args) { const type = args.shift() this.emit(type, name, ...args) }, /** * This method takes the data received from {@link SimpleStore#find}, * {@link SimpleStore#findAll}, {@link SimpleStore#update}, etc., and adds the * data to the store. _You don't need to call this method directly._ * * If you're using the http adapter and your response data is in an unexpected * format, you may need to override this method so the right data gets added * to the store. * * @example * const store = new SimpleStore({ * addToCache (mapperName, data, opts) { * // Let's say for a particular Resource, response data is in a weird format * if (name === 'comment') { * // Re-assign the variable to add the correct records into the stores * data = data.items; * } * // Now perform default behavior * return SimpleStore.prototype.addToCache.call(this, mapperName, data, opts); * } * }); * * @example * // Extend using ES2015 class syntax. * class MyStore extends SimpleStore { * addToCache (mapperName, data, opts) { * // Let's say for a particular Resource, response data is in a weird format * if (name === 'comment') { * // Re-assign the variable to add the correct records into the stores * data = data.items; * } * // Now perform default behavior * return super.addToCache(mapperName, data, opts); * } * } * const store = new MyStore(); * * @method SimpleStore#addToCache * @param {string} name Name of the {@link Mapper} to target. * @param {*} data Data from which data should be selected for add. * @param {object} [opts] Configuration options. */ addToCache (name, data, opts) { return this.getCollection(name).add(data, opts) }, /** * Return the store scoped to a particular mapper/collection pair. * * @example &lt;caption&gt;SimpleStore.as&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * const UserMapper = store.defineMapper('user'); * const UserStore = store.as('user'); * * const user1 = store.createRecord('user', { name: 'John' }); * const user2 = UserStore.createRecord({ name: 'John' }); * const user3 = UserMapper.createRecord({ name: 'John' }); * console.log(user1 === user2); * console.log(user2 === user3); * console.log(user1 === user3); * * @method SimpleStore#as * @param {string} name Name of the {@link Mapper}. * @returns {Object} The store, scoped to a particular Mapper/Collection pair. * @since 3.0.0 */ as (name) { const props = {} const original = this const methods = ownMethodsForScoping .concat(proxiedMapperMethods) .concat(proxiedCollectionMethods) methods.forEach(function (method) { props[method] = { writable: true, value (...args) { return original[method](name, ...args) } } }) props.getMapper = { writable: true, value () { return original.getMapper(name) } } props.getCollection = { writable: true, value () { return original.getCollection(name) } } return Object.create(this, props) }, /** * Retrieve a cached `find` result, if any. This method is called during * {@link SimpleStore#find} to determine if {@link Mapper#find} needs to be * called. If this method returns `undefined` then {@link Mapper#find} will * be called. Otherwise {@link SimpleStore#find} will immediately resolve with * the return value of this method. * * When using {@link SimpleStore} in the browser, you can override this method * to implement your own cache-busting strategy. * * @example * const store = new SimpleStore({ * cachedFind (mapperName, id, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return undefined to trigger a Mapper#find call * return; * } * // Otherwise perform default behavior * return SimpleStore.prototype.cachedFind.call(this, mapperName, id, opts); * } * }); * * @example * // Extend using ES2015 class syntax. * class MyStore extends SimpleStore { * cachedFind (mapperName, id, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return undefined to trigger a Mapper#find call * return; * } * // Otherwise perform default behavior * return super.cachedFind(mapperName, id, opts); * } * } * const store = new MyStore(); * * @method SimpleStore#cachedFind * @param {string} name The `name` argument passed to {@link SimpleStore#find}. * @param {(string|number)} id The `id` argument passed to {@link SimpleStore#find}. * @param {object} opts The `opts` argument passed to {@link SimpleStore#find}. * @since 3.0.0 */ cachedFind: cachedFn, /** * Retrieve a cached `findAll` result, if any. This method is called during * {@link SimpleStore#findAll} to determine if {@link Mapper#findAll} needs to be * called. If this method returns `undefined` then {@link Mapper#findAll} will * be called. Otherwise {@link SimpleStore#findAll} will immediately resolve with * the return value of this method. * * When using {@link SimpleStore} in the browser, you can override this method * to implement your own cache-busting strategy. * * @example * const store = new SimpleStore({ * cachedFindAll (mapperName, hash, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return undefined to trigger a Mapper#findAll call * return undefined; * } * // Otherwise perform default behavior * return SimpleStore.prototype.cachedFindAll.call(this, mapperName, hash, opts); * } * }); * * @example * // Extend using ES2015 class syntax. * class MyStore extends SimpleStore { * cachedFindAll (mapperName, hash, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return undefined to trigger a Mapper#findAll call * return undefined; * } * // Otherwise perform default behavior * return super.cachedFindAll(mapperName, hash, opts); * } * } * const store = new MyStore(); * * @method SimpleStore#cachedFindAll * @param {string} name The `name` argument passed to {@link SimpleStore#findAll}. * @param {string} hash The result of calling {@link SimpleStore#hashQuery} on * the `query` argument passed to {@link SimpleStore#findAll}. * @param {object} opts The `opts` argument passed to {@link SimpleStore#findAll}. * @since 3.0.0 */ cachedFindAll: cachedFn, /** * Mark a {@link Mapper#find} result as cached by adding an entry to * {@link SimpleStore#_completedQueries}. By default, once a `find` entry is * added it means subsequent calls to the same Resource with the same `id` * argument will immediately resolve with the result of calling * {@link SimpleStore#get} instead of delegating to {@link Mapper#find}. * * As part of implementing your own caching strategy, you may choose to * override this method. * * @example * const store = new SimpleStore({ * cacheFind (mapperName, data, id, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return without saving an entry to SimpleStore#_completedQueries * return; * } * // Otherwise perform default behavior * return SimpleStore.prototype.cacheFind.call(this, mapperName, data, id, opts); * } * }); * * @example * // Extend using ES2015 class syntax. * class MyStore extends SimpleStore { * cacheFind (mapperName, data, id, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return without saving an entry to SimpleStore#_completedQueries * return; * } * // Otherwise perform default behavior * return super.cacheFind(mapperName, data, id, opts); * } * } * const store = new MyStore(); * * @method SimpleStore#cacheFind * @param {string} name The `name` argument passed to {@link SimpleStore#find}. * @param {*} data The result to cache. * @param {(string|number)} id The `id` argument passed to {@link SimpleStore#find}. * @param {object} opts The `opts` argument passed to {@link SimpleStore#find}. * @since 3.0.0 */ cacheFind (name, data, id, opts) { this._completedQueries[name][id] = (name, id, opts) =&gt; this.get(name, id) }, /** * Mark a {@link Mapper#findAll} result as cached by adding an entry to * {@link SimpleStore#_completedQueries}. By default, once a `findAll` entry is * added it means subsequent calls to the same Resource with the same `query` * argument will immediately resolve with the result of calling * {@link SimpleStore#filter} instead of delegating to {@link Mapper#findAll}. * * As part of implementing your own caching strategy, you may choose to * override this method. * * @example * const store = new SimpleStore({ * cachedFindAll (mapperName, data, hash, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return without saving an entry to SimpleStore#_completedQueries * return; * } * // Otherwise perform default behavior. * return SimpleStore.prototype.cachedFindAll.call(this, mapperName, data, hash, opts); * } * }); * * @example * // Extend using ES2015 class syntax. * class MyStore extends SimpleStore { * cachedFindAll (mapperName, data, hash, opts) { * // Let's say for a particular Resource, we always want to pull fresh from the server * if (mapperName === 'schedule') { * // Return without saving an entry to SimpleStore#_completedQueries * return; * } * // Otherwise perform default behavior. * return super.cachedFindAll(mapperName, data, hash, opts); * } * } * const store = new MyStore(); * * @method SimpleStore#cacheFindAll * @param {string} name The `name` argument passed to {@link SimpleStore#findAll}. * @param {*} data The result to cache. * @param {string} hash The result of calling {@link SimpleStore#hashQuery} on * the `query` argument passed to {@link SimpleStore#findAll}. * @param {object} opts The `opts` argument passed to {@link SimpleStore#findAll}. * @since 3.0.0 */ cacheFindAll (name, data, hash, opts) { this._completedQueries[name][hash] = (name, hash, opts) =&gt; this.filter(name, utils.fromJson(hash)) }, /** * Remove __all__ records from the in-memory store and reset * {@link SimpleStore#_completedQueries}. * * @method SimpleStore#clear * @returns {Object} Object containing all records that were in the store. * @see SimpleStore#remove * @see SimpleStore#removeAll * @since 3.0.0 */ clear () { const removed = {} utils.forOwn(this._collections, (collection, name) =&gt; { removed[name] = collection.removeAll() this._completedQueries[name] = {} }) return removed }, /** * Fired during {@link SimpleStore#create}. See * {@link SimpleStore~beforeCreateListener} for how to listen for this event. * * @event SimpleStore#beforeCreate * @see SimpleStore~beforeCreateListener * @see SimpleStore#create */ /** * Callback signature for the {@link SimpleStore#event:beforeCreate} event. * * @example * function onBeforeCreate (mapperName, props, opts) { * // do something * } * store.on('beforeCreate', onBeforeCreate); * * @callback SimpleStore~beforeCreateListener * @param {string} name The `name` argument received by {@link Mapper#beforeCreate}. * @param {object} props The `props` argument received by {@link Mapper#beforeCreate}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeCreate}. * @see SimpleStore#event:beforeCreate * @see SimpleStore#create * @since 3.0.0 */ /** * Fired during {@link SimpleStore#create}. See * {@link SimpleStore~afterCreateListener} for how to listen for this event. * * @event SimpleStore#afterCreate * @see SimpleStore~afterCreateListener * @see SimpleStore#create */ /** * Callback signature for the {@link SimpleStore#event:afterCreate} event. * * @example * function onAfterCreate (mapperName, props, opts, result) { * // do something * } * store.on('afterCreate', onAfterCreate); * * @callback SimpleStore~afterCreateListener * @param {string} name The `name` argument received by {@link Mapper#afterCreate}. * @param {object} props The `props` argument received by {@link Mapper#afterCreate}. * @param {object} opts The `opts` argument received by {@link Mapper#afterCreate}. * @param {object} result The `result` argument received by {@link Mapper#afterCreate}. * @see SimpleStore#event:afterCreate * @see SimpleStore#create * @since 3.0.0 */ /** * Wrapper for {@link Mapper#create}. Adds the created record to the store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('book'); * * // Since this example uses the http adapter, we'll get something like: * // * // POST /book {\"author_id\":1234,...} * store.create('book', { * author_id: 1234, * edition: 'First Edition', * title: 'Respect your Data' * }).then((book) =&gt; { * console.log(book.id); // 120392 * console.log(book.title); // \"Respect your Data\" * }); * * @fires SimpleStore#beforeCreate * @fires SimpleStore#afterCreate * @fires SimpleStore#add * @method SimpleStore#create * @param {string} name Name of the {@link Mapper} to target. * @param {object} record Passed to {@link Mapper#create}. * @param {object} [opts] Passed to {@link Mapper#create}. See * {@link Mapper#create} for more configuration options. * @returns {Promise} Resolves with the result of the create. * @since 3.0.0 */ create (name, record, opts) { opts || (opts = {}) return Container.prototype.create.call(this, name, record, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Fired during {@link SimpleStore#createMany}. See * {@link SimpleStore~beforeCreateManyListener} for how to listen for this event. * * @event SimpleStore#beforeCreateMany * @see SimpleStore~beforeCreateManyListener * @see SimpleStore#createMany */ /** * Callback signature for the {@link SimpleStore#event:beforeCreateMany} event. * * @example * function onBeforeCreateMany (mapperName, records, opts) { * // do something * } * store.on('beforeCreateMany', onBeforeCreateMany); * * @callback SimpleStore~beforeCreateManyListener * @param {string} name The `name` argument received by {@link Mapper#beforeCreateMany}. * @param {object} records The `records` argument received by {@link Mapper#beforeCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeCreateMany}. * @see SimpleStore#event:beforeCreateMany * @see SimpleStore#createMany * @since 3.0.0 */ /** * Fired during {@link SimpleStore#createMany}. See * {@link SimpleStore~afterCreateManyListener} for how to listen for this event. * * @event SimpleStore#afterCreateMany * @see SimpleStore~afterCreateManyListener * @see SimpleStore#createMany */ /** * Callback signature for the {@link SimpleStore#event:afterCreateMany} event. * * @example * function onAfterCreateMany (mapperName, records, opts, result) { * // do something * } * store.on('afterCreateMany', onAfterCreateMany); * * @callback SimpleStore~afterCreateManyListener * @param {string} name The `name` argument received by {@link Mapper#afterCreateMany}. * @param {object} records The `records` argument received by {@link Mapper#afterCreateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterCreateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterCreateMany}. * @see SimpleStore#event:afterCreateMany * @see SimpleStore#createMany * @since 3.0.0 */ /** * Wrapper for {@link Mapper#createMany}. Adds the created records to the * store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('book'); * * // Since this example uses the http adapter, we'll get something like: * // * // POST /book [{\"author_id\":1234,...},{...}] * store.createMany('book', [{ * author_id: 1234, * edition: 'First Edition', * title: 'Respect your Data' * }, { * author_id: 1234, * edition: 'Second Edition', * title: 'Respect your Data' * }]).then((books) =&gt; { * console.log(books[0].id); // 142394 * console.log(books[0].title); // \"Respect your Data\" * }); * * @fires SimpleStore#beforeCreateMany * @fires SimpleStore#afterCreateMany * @fires SimpleStore#add * @method SimpleStore#createMany * @param {string} name Name of the {@link Mapper} to target. * @param {array} records Passed to {@link Mapper#createMany}. * @param {object} [opts] Passed to {@link Mapper#createMany}. See * {@link Mapper#createMany} for more configuration options. * @returns {Promise} Resolves with the result of the create. * @since 3.0.0 */ createMany (name, records, opts) { opts || (opts = {}) return Container.prototype.createMany.call(this, name, records, opts) .then((result) =&gt; this._end(name, result, opts)) }, defineMapper (name, opts) { const self = this const mapper = Container.prototype.defineMapper.call(self, name, opts) self._pendingQueries[name] = {} self._completedQueries[name] = {} mapper.relationList || Object.defineProperty(mapper, 'relationList', { value: [] }) let collectionOpts = { // Make sure the collection has somewhere to store \"added\" timestamps _added: {}, // Give the collection a reference to this SimpleStore datastore: self, // The mapper tied to the collection mapper } if (opts &amp;&amp; ('onConflict' in opts)) { collectionOpts.onConflict = opts.onConflict } // The SimpleStore uses a subclass of Collection that is \"SimpleStore-aware\" const collection = self._collections[name] = new self.collectionClass(null, collectionOpts) // eslint-disable-line const schema = mapper.schema || {} const properties = schema.properties || {} // TODO: Make it possible index nested properties? utils.forOwn(properties, function (opts, prop) { if (opts.indexed) { collection.createIndex(prop) } }) // Create a secondary index on the \"added\" timestamps of records in the // collection collection.createIndex('addedTimestamps', ['$'], { fieldGetter (obj) { return collection._added[collection.recordId(obj)] } }) collection.on('all', function (...args) { self._onCollectionEvent(name, ...args) }) return mapper }, /** * Fired during {@link SimpleStore#destroy}. See * {@link SimpleStore~beforeDestroyListener} for how to listen for this event. * * @event SimpleStore#beforeDestroy * @see SimpleStore~beforeDestroyListener * @see SimpleStore#destroy */ /** * Callback signature for the {@link SimpleStore#event:beforeDestroy} event. * * @example * function onBeforeDestroy (mapperName, id, opts) { * // do something * } * store.on('beforeDestroy', onBeforeDestroy); * * @callback SimpleStore~beforeDestroyListener * @param {string} name The `name` argument received by {@link Mapper#beforeDestroy}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeDestroy}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeDestroy}. * @see SimpleStore#event:beforeDestroy * @see SimpleStore#destroy * @since 3.0.0 */ /** * Fired during {@link SimpleStore#destroy}. See * {@link SimpleStore~afterDestroyListener} for how to listen for this event. * * @event SimpleStore#afterDestroy * @see SimpleStore~afterDestroyListener * @see SimpleStore#destroy */ /** * Callback signature for the {@link SimpleStore#event:afterDestroy} event. * * @example * function onAfterDestroy (mapperName, id, opts, result) { * // do something * } * store.on('afterDestroy', onAfterDestroy); * * @callback SimpleStore~afterDestroyListener * @param {string} name The `name` argument received by {@link Mapper#afterDestroy}. * @param {string|number} id The `id` argument received by {@link Mapper#afterDestroy}. * @param {object} opts The `opts` argument received by {@link Mapper#afterDestroy}. * @param {object} result The `result` argument received by {@link Mapper#afterDestroy}. * @see SimpleStore#event:afterDestroy * @see SimpleStore#destroy * @since 3.0.0 */ /** * Wrapper for {@link Mapper#destroy}. Removes any destroyed record from the * in-memory store. Clears out any {@link SimpleStore#_completedQueries} entries * associated with the provided `id`. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('book'); * * store.add('book', { id: 1234, title: 'Data Management is Hard' }); * * // Since this example uses the http adapter, we'll get something like: * // * // DELETE /book/1234 * store.destroy('book', 1234).then(() =&gt; { * // The book record is no longer in the in-memory store * console.log(store.get('book', 1234)); // undefined * * return store.find('book', 1234); * }).then((book) { * // The book was deleted from the database too * console.log(book); // undefined * }); * * @fires SimpleStore#beforeDestroy * @fires SimpleStore#afterDestroy * @fires SimpleStore#remove * @method SimpleStore#destroy * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#destroy}. * @param {object} [opts] Passed to {@link Mapper#destroy}. See * {@link Mapper#destroy} for more configuration options. * @returns {Promise} Resolves when the destroy operation completes. * @since 3.0.0 */ destroy (name, id, opts) { opts || (opts = {}) return Container.prototype.destroy.call(this, name, id, opts).then((result) =&gt; { const record = this.getCollection(name).remove(id, opts) if (opts.raw) { result.data = record } else { result = record } delete this._pendingQueries[name][id] delete this._completedQueries[name][id] return result }) }, /** * Fired during {@link SimpleStore#destroyAll}. See * {@link SimpleStore~beforeDestroyAllListener} for how to listen for this event. * * @event SimpleStore#beforeDestroyAll * @see SimpleStore~beforeDestroyAllListener * @see SimpleStore#destroyAll */ /** * Callback signature for the {@link SimpleStore#event:beforeDestroyAll} event. * * @example * function onBeforeDestroyAll (mapperName, query, opts) { * // do something * } * store.on('beforeDestroyAll', onBeforeDestroyAll); * * @callback SimpleStore~beforeDestroyAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeDestroyAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeDestroyAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeDestroyAll}. * @see SimpleStore#event:beforeDestroyAll * @see SimpleStore#destroyAll * @since 3.0.0 */ /** * Fired during {@link SimpleStore#destroyAll}. See * {@link SimpleStore~afterDestroyAllListener} for how to listen for this event. * * @event SimpleStore#afterDestroyAll * @see SimpleStore~afterDestroyAllListener * @see SimpleStore#destroyAll */ /** * Callback signature for the {@link SimpleStore#event:afterDestroyAll} event. * * @example * function onAfterDestroyAll (mapperName, query, opts, result) { * // do something * } * store.on('afterDestroyAll', onAfterDestroyAll); * * @callback SimpleStore~afterDestroyAllListener * @param {string} name The `name` argument received by {@link Mapper#afterDestroyAll}. * @param {object} query The `query` argument received by {@link Mapper#afterDestroyAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterDestroyAll}. * @param {object} result The `result` argument received by {@link Mapper#afterDestroyAll}. * @see SimpleStore#event:afterDestroyAll * @see SimpleStore#destroyAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#destroyAll}. Removes any destroyed records from * the in-memory store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('book'); * * store.add('book', { id: 1234, title: 'Data Management is Hard' }); * * // Since this example uses the http adapter, we'll get something like: * // * // DELETE /book/1234 * store.destroy('book', 1234).then(() =&gt; { * // The book record is gone from the in-memory store * console.log(store.get('book', 1234)); // undefined * return store.find('book', 1234); * }).then((book) { * // The book was deleted from the database too * console.log(book); // undefined * }); * * @fires SimpleStore#beforeDestroyAll * @fires SimpleStore#afterDestroyAll * @fires SimpleStore#remove * @method SimpleStore#destroyAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} [query] Passed to {@link Mapper#destroyAll}. * @param {object} [opts] Passed to {@link Mapper#destroyAll}. See * {@link Mapper#destroyAll} for more configuration options. * @returns {Promise} Resolves when the delete completes. * @since 3.0.0 */ destroyAll (name, query, opts) { opts || (opts = {}) return Container.prototype.destroyAll.call(this, name, query, opts).then((result) =&gt; { const records = this.getCollection(name).removeAll(query, opts) if (opts.raw) { result.data = records } else { result = records } const hash = this.hashQuery(name, query, opts) delete this._pendingQueries[name][hash] delete this._completedQueries[name][hash] return result }) }, eject (name, id, opts) { console.warn('DEPRECATED: \"eject\" is deprecated, use \"remove\" instead') return this.remove(name, id, opts) }, ejectAll (name, query, opts) { console.warn('DEPRECATED: \"ejectAll\" is deprecated, use \"removeAll\" instead') return this.removeAll(name, query, opts) }, /** * Fired during {@link SimpleStore#find}. See * {@link SimpleStore~beforeFindListener} for how to listen for this event. * * @event SimpleStore#beforeFind * @see SimpleStore~beforeFindListener * @see SimpleStore#find */ /** * Callback signature for the {@link SimpleStore#event:beforeFind} event. * * @example * function onBeforeFind (mapperName, id, opts) { * // do something * } * store.on('beforeFind', onBeforeFind); * * @callback SimpleStore~beforeFindListener * @param {string} name The `name` argument received by {@link Mapper#beforeFind}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeFind}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeFind}. * @see SimpleStore#event:beforeFind * @see SimpleStore#find * @since 3.0.0 */ /** * Fired during {@link SimpleStore#find}. See * {@link SimpleStore~afterFindListener} for how to listen for this event. * * @event SimpleStore#afterFind * @see SimpleStore~afterFindListener * @see SimpleStore#find */ /** * Callback signature for the {@link SimpleStore#event:afterFind} event. * * @example * function onAfterFind (mapperName, id, opts, result) { * // do something * } * store.on('afterFind', onAfterFind); * * @callback SimpleStore~afterFindListener * @param {string} name The `name` argument received by {@link Mapper#afterFind}. * @param {string|number} id The `id` argument received by {@link Mapper#afterFind}. * @param {object} opts The `opts` argument received by {@link Mapper#afterFind}. * @param {object} result The `result` argument received by {@link Mapper#afterFind}. * @see SimpleStore#event:afterFind * @see SimpleStore#find * @since 3.0.0 */ /** * Wrapper for {@link Mapper#find}. Adds any found record to the store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('book'); * * // Since this example uses the http adapter, we'll get something like: * // * // GET /book/1234 * store.find('book', 1234).then((book) =&gt; { * // The book record is now in the in-memory store * console.log(store.get('book', 1234) === book); // true * }); * * @fires SimpleStore#beforeFind * @fires SimpleStore#afterFind * @fires SimpleStore#add * @method SimpleStore#find * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#find}. * @param {object} [opts] Passed to {@link Mapper#find}. * @param {boolean} [opts.force] Bypass cacheFind * @param {boolean|Function} [opts.usePendingFind] See {@link SimpleStore#usePendingFind} * @returns {Promise} Resolves with the result, if any. * @since 3.0.0 */ find (name, id, opts) { opts || (opts = {}) const mapper = this.getMapper(name) const pendingQuery = this._pendingQueries[name][id] const usePendingFind = opts.usePendingFind === undefined ? this.usePendingFind : opts.usePendingFind utils._(opts, mapper) if (pendingQuery &amp;&amp; (utils.isFunction(usePendingFind) ? usePendingFind.call(this, name, id, opts) : usePendingFind)) { return pendingQuery } const item = this.cachedFind(name, id, opts) if (opts.force || !item) { const promise = this._pendingQueries[name][id] = Container.prototype.find.call(this, name, id, opts) return promise .then((result) =&gt; { delete this._pendingQueries[name][id] result = this._end(name, result, opts) this.cacheFind(name, result, id, opts) return result }, (err) =&gt; { delete this._pendingQueries[name][id] return utils.reject(err) }) } return utils.resolve(item) }, /** * Fired during {@link SimpleStore#findAll}. See * {@link SimpleStore~beforeFindAllListener} for how to listen for this event. * * @event SimpleStore#beforeFindAll * @see SimpleStore~beforeFindAllListener * @see SimpleStore#findAll */ /** * Callback signature for the {@link SimpleStore#event:beforeFindAll} event. * * @example * function onBeforeFindAll (mapperName, query, opts) { * // do something * } * store.on('beforeFindAll', onBeforeFindAll); * * @callback SimpleStore~beforeFindAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeFindAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeFindAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeFindAll}. * @see SimpleStore#event:beforeFindAll * @see SimpleStore#findAll * @since 3.0.0 */ /** * Fired during {@link SimpleStore#findAll}. See * {@link SimpleStore~afterFindAllListener} for how to listen for this event. * * @event SimpleStore#afterFindAll * @see SimpleStore~afterFindAllListener * @see SimpleStore#findAll */ /** * Callback signature for the {@link SimpleStore#event:afterFindAll} event. * * @example * function onAfterFindAll (mapperName, query, opts, result) { * // do something * } * store.on('afterFindAll', onAfterFindAll); * * @callback SimpleStore~afterFindAllListener * @param {string} name The `name` argument received by {@link Mapper#afterFindAll}. * @param {object} query The `query` argument received by {@link Mapper#afterFindAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterFindAll}. * @param {object} result The `result` argument received by {@link Mapper#afterFindAll}. * @see SimpleStore#event:afterFindAll * @see SimpleStore#findAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#findAll}. Adds any found records to the store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('movie'); * * // Since this example uses the http adapter, we'll get something like: * // * // GET /movie?rating=PG * store.find('movie', { rating: 'PG' }).then((movies) =&gt; { * // The movie records are now in the in-memory store * console.log(store.filter('movie')); * }); * * @fires SimpleStore#beforeFindAll * @fires SimpleStore#afterFindAll * @fires SimpleStore#add * @method SimpleStore#findAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} [query] Passed to {@link Mapper.findAll}. * @param {object} [opts] Passed to {@link Mapper.findAll}. * @param {boolean} [opts.force] Bypass cacheFindAll * @param {boolean|Function} [opts.usePendingFindAll] See {@link SimpleStore#usePendingFindAll} * @returns {Promise} Resolves with the result, if any. * @since 3.0.0 */ findAll (name, query, opts) { opts || (opts = {}) const mapper = this.getMapper(name) const hash = this.hashQuery(name, query, opts) const pendingQuery = this._pendingQueries[name][hash] const usePendingFindAll = opts.usePendingFindAll === undefined ? this.usePendingFindAll : opts.usePendingFindAll utils._(opts, mapper) if (pendingQuery &amp;&amp; (utils.isFunction(usePendingFindAll) ? usePendingFindAll.call(this, name, query, opts) : usePendingFindAll)) { return pendingQuery } const items = this.cachedFindAll(name, hash, opts) if (opts.force || !items) { const promise = this._pendingQueries[name][hash] = Container.prototype.findAll.call(this, name, query, opts) return promise .then((result) =&gt; { delete this._pendingQueries[name][hash] result = this._end(name, result, opts) this.cacheFindAll(name, result, hash, opts) return result }, (err) =&gt; { delete this._pendingQueries[name][hash] return utils.reject(err) }) } return utils.resolve(items) }, /** * Return the {@link Collection} with the given name, if for some * reason you need a direct reference to the collection. * * @method SimpleStore#getCollection * @param {string} name Name of the {@link Collection} to retrieve. * @returns {Collection} * @since 3.0.0 * @throws {Error} Thrown if the specified {@link Collection} does not * exist. */ getCollection (name) { const collection = this._collections[name] if (!collection) { throw utils.err(`${DOMAIN}#getCollection`, name)(404, 'collection') } return collection }, /** * Hashing function used to cache {@link SimpleStore#find} and * {@link SimpleStore#findAll} requests. This method simply JSONifies the * `query` argument passed to {@link SimpleStore#find} or * {@link SimpleStore#findAll}. * * Override this method for custom hashing behavior. * @method SimpleStore#hashQuery * @param {string} name The `name` argument passed to {@link SimpleStore#find} * or {@link SimpleStore#findAll}. * @param {object} query The `query` argument passed to {@link SimpleStore#find} * or {@link SimpleStore#findAll}. * @returns {string} The JSONified `query`. * @since 3.0.0 */ hashQuery (name, query, opts) { return utils.toJson(query || {}) }, inject (name, records, opts) { console.warn('DEPRECATED: \"inject\" is deprecated, use \"add\" instead') return this.add(name, records, opts) }, /** * Wrapper for {@link Collection#remove}. Removes the specified * {@link Record} from the store. * * @example &lt;caption&gt;SimpleStore#remove&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * store.defineMapper('book'); * console.log(store.getAll('book').length); * store.add('book', { id: 1234 }); * console.log(store.getAll('book').length); * store.remove('book', 1234); * console.log(store.getAll('book').length); * * @fires SimpleStore#remove * @method SimpleStore#remove * @param {string} name The name of the {@link Collection} to target. * @param {string|number} id The primary key of the {@link Record} to remove. * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record} to also * remove from the store. * @returns {Record} The removed {@link Record}, if any. * @see Collection#add * @see Collection#add * @since 3.0.0 */ remove (name, id, opts) { const record = this.getCollection(name).remove(id, opts) if (record) { this.removeRelated(name, [record], opts) } return record }, /** * Wrapper for {@link Collection#removeAll}. Removes the selected * {@link Record}s from the store. * * @example &lt;caption&gt;SimpleStore#removeAll&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new SimpleStore(); * store.defineMapper('movie'); * console.log(store.getAll('movie').length); * store.add('movie', [{ id: 3, rating: 'R' }, { id: 4, rating: 'PG-13' }); * console.log(store.getAll('movie').length); * store.removeAll('movie', { rating: 'R' }); * console.log(store.getAll('movie').length); * * @fires SimpleStore#remove * @method SimpleStore#removeAll * @param {string} name The name of the {@link Collection} to target. * @param {object} [query={}] Selection query. See {@link query}. * @param {object} [query.where] See {@link query.where}. * @param {number} [query.offset] See {@link query.offset}. * @param {number} [query.limit] See {@link query.limit}. * @param {string|Array[]} [query.orderBy] See {@link query.orderBy}. * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record} to also * remove from the store. * @returns {Record} The removed {@link Record}s, if any. * @see Collection#add * @see Collection#add * @since 3.0.0 */ removeAll (name, query, opts) { if (!query || !Object.keys(query).length) { this._completedQueries[name] = {} } else { this._completedQueries[name][this.hashQuery(name, query, opts)] = undefined } const records = this.getCollection(name).removeAll(query, opts) if (records.length) { this.removeRelated(name, records, opts) } return records }, /** * Remove from the store {@link Record}s that are related to the provided * {@link Record}(s). * * @fires SimpleStore#remove * @method SimpleStore#removeRelated * @param {string} name The name of the {@link Collection} to target. * @param {Record|Record[]} records {@link Record}s whose relations are to be * removed. * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Relations of the {@link Record}(s) to remove * from the store. * @since 3.0.0 */ removeRelated (name, records, opts) { if (!utils.isArray(records)) { records = [records] } utils.forEachRelation(this.getMapper(name), opts, (def, optsCopy) =&gt; { records.forEach((record) =&gt; { let relatedData let query if (def.foreignKey &amp;&amp; (def.type === hasOneType || def.type === hasManyType)) { query = { [def.foreignKey]: def.getForeignKey(record) } } else if (def.type === hasManyType &amp;&amp; def.localKeys) { query = { where: { [def.getRelation().idAttribute]: { 'in': utils.get(record, def.localKeys) } } } } else if (def.type === hasManyType &amp;&amp; def.foreignKeys) { query = { where: { [def.foreignKeys]: { 'contains': def.getForeignKey(record) } } } } else if (def.type === belongsToType) { relatedData = this.remove(def.relation, def.getForeignKey(record), optsCopy) } if (query) { relatedData = this.removeAll(def.relation, query, optsCopy) } if (relatedData) { if (utils.isArray(relatedData) &amp;&amp; !relatedData.length) { return } if (def.type === hasOneType) { relatedData = relatedData[0] } def.setLocalField(record, relatedData) } }) }) }, /** * Fired during {@link SimpleStore#update}. See * {@link SimpleStore~beforeUpdateListener} for how to listen for this event. * * @event SimpleStore#beforeUpdate * @see SimpleStore~beforeUpdateListener * @see SimpleStore#update */ /** * Callback signature for the {@link SimpleStore#event:beforeUpdate} event. * * @example * function onBeforeUpdate (mapperName, id, props, opts) { * // do something * } * store.on('beforeUpdate', onBeforeUpdate); * * @callback SimpleStore~beforeUpdateListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdate}. * @param {string|number} id The `id` argument received by {@link Mapper#beforeUpdate}. * @param {object} props The `props` argument received by {@link Mapper#beforeUpdate}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdate}. * @see SimpleStore#event:beforeUpdate * @see SimpleStore#update * @since 3.0.0 */ /** * Fired during {@link SimpleStore#update}. See * {@link SimpleStore~afterUpdateListener} for how to listen for this event. * * @event SimpleStore#afterUpdate * @see SimpleStore~afterUpdateListener * @see SimpleStore#update */ /** * Callback signature for the {@link SimpleStore#event:afterUpdate} event. * * @example * function onAfterUpdate (mapperName, id, props, opts, result) { * // do something * } * store.on('afterUpdate', onAfterUpdate); * * @callback SimpleStore~afterUpdateListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdate}. * @param {string|number} id The `id` argument received by {@link Mapper#afterUpdate}. * @param {object} props The `props` argument received by {@link Mapper#afterUpdate}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdate}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdate}. * @see SimpleStore#event:afterUpdate * @see SimpleStore#update * @since 3.0.0 */ /** * Wrapper for {@link Mapper#update}. Adds the updated {@link Record} to the * store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('post'); * * // Since this example uses the http adapter, we'll get something like: * // * // PUT /post/1234 {\"status\":\"published\"} * store.update('post', 1, { status: 'published' }).then((post) =&gt; { * // The post record has also been updated in the in-memory store * console.log(store.get('post', 1234)); * }); * * @fires SimpleStore#beforeUpdate * @fires SimpleStore#afterUpdate * @fires SimpleStore#add * @method SimpleStore#update * @param {string} name Name of the {@link Mapper} to target. * @param {(string|number)} id Passed to {@link Mapper#update}. * @param {object} record Passed to {@link Mapper#update}. * @param {object} [opts] Passed to {@link Mapper#update}. See * {@link Mapper#update} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ update (name, id, record, opts) { opts || (opts = {}) return Container.prototype.update.call(this, name, id, record, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Fired during {@link SimpleStore#updateAll}. See * {@link SimpleStore~beforeUpdateAllListener} for how to listen for this event. * * @event SimpleStore#beforeUpdateAll * @see SimpleStore~beforeUpdateAllListener * @see SimpleStore#updateAll */ /** * Callback signature for the {@link SimpleStore#event:beforeUpdateAll} event. * * @example * function onBeforeUpdateAll (mapperName, props, query, opts) { * // do something * } * store.on('beforeUpdateAll', onBeforeUpdateAll); * * @callback SimpleStore~beforeUpdateAllListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} props The `props` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#beforeUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateAll}. * @see SimpleStore#event:beforeUpdateAll * @see SimpleStore#updateAll * @since 3.0.0 */ /** * Fired during {@link SimpleStore#updateAll}. See * {@link SimpleStore~afterUpdateAllListener} for how to listen for this event. * * @event SimpleStore#afterUpdateAll * @see SimpleStore~afterUpdateAllListener * @see SimpleStore#updateAll */ /** * Callback signature for the {@link SimpleStore#event:afterUpdateAll} event. * * @example * function onAfterUpdateAll (mapperName, props, query, opts, result) { * // do something * } * store.on('afterUpdateAll', onAfterUpdateAll); * * @callback SimpleStore~afterUpdateAllListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdateAll}. * @param {object} props The `props` argument received by {@link Mapper#afterUpdateAll}. * @param {object} query The `query` argument received by {@link Mapper#afterUpdateAll}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateAll}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateAll}. * @see SimpleStore#event:afterUpdateAll * @see SimpleStore#updateAll * @since 3.0.0 */ /** * Wrapper for {@link Mapper#updateAll}. Adds the updated {@link Record}s to * the store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('post'); * * // Since this example uses the http adapter, we'll get something like: * // * // PUT /post?author_id=1234 {\"status\":\"published\"} * store.updateAll('post', { author_id: 1234 }, { status: 'published' }).then((posts) =&gt; { * // The post records have also been updated in the in-memory store * console.log(store.filter('posts', { author_id: 1234 })); * }); * * @fires SimpleStore#beforeUpdateAll * @fires SimpleStore#afterUpdateAll * @fires SimpleStore#add * @method SimpleStore#updateAll * @param {string} name Name of the {@link Mapper} to target. * @param {object} props Passed to {@link Mapper#updateAll}. * @param {object} [query] Passed to {@link Mapper#updateAll}. * @param {object} [opts] Passed to {@link Mapper#updateAll}. See * {@link Mapper#updateAll} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ updateAll (name, props, query, opts) { opts || (opts = {}) return Container.prototype.updateAll.call(this, name, props, query, opts) .then((result) =&gt; this._end(name, result, opts)) }, /** * Fired during {@link SimpleStore#updateMany}. See * {@link SimpleStore~beforeUpdateManyListener} for how to listen for this event. * * @event SimpleStore#beforeUpdateMany * @see SimpleStore~beforeUpdateManyListener * @see SimpleStore#updateMany */ /** * Callback signature for the {@link SimpleStore#event:beforeUpdateMany} event. * * @example * function onBeforeUpdateMany (mapperName, records, opts) { * // do something * } * store.on('beforeUpdateMany', onBeforeUpdateMany); * * @callback SimpleStore~beforeUpdateManyListener * @param {string} name The `name` argument received by {@link Mapper#beforeUpdateMany}. * @param {object} records The `records` argument received by {@link Mapper#beforeUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#beforeUpdateMany}. * @see SimpleStore#event:beforeUpdateMany * @see SimpleStore#updateMany * @since 3.0.0 */ /** * Fired during {@link SimpleStore#updateMany}. See * {@link SimpleStore~afterUpdateManyListener} for how to listen for this event. * * @event SimpleStore#afterUpdateMany * @see SimpleStore~afterUpdateManyListener * @see SimpleStore#updateMany */ /** * Callback signature for the {@link SimpleStore#event:afterUpdateMany} event. * * @example * function onAfterUpdateMany (mapperName, records, opts, result) { * // do something * } * store.on('afterUpdateMany', onAfterUpdateMany); * * @callback SimpleStore~afterUpdateManyListener * @param {string} name The `name` argument received by {@link Mapper#afterUpdateMany}. * @param {object} records The `records` argument received by {@link Mapper#afterUpdateMany}. * @param {object} opts The `opts` argument received by {@link Mapper#afterUpdateMany}. * @param {object} result The `result` argument received by {@link Mapper#afterUpdateMany}. * @see SimpleStore#event:afterUpdateMany * @see SimpleStore#updateMany * @since 3.0.0 */ /** * Wrapper for {@link Mapper#updateMany}. Adds the updated {@link Record}s to * the store. * * @example * import { SimpleStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const store = new SimpleStore(); * store.registerAdapter('http', new HttpAdapter(), { default: true }); * * store.defineMapper('post'); * * // Since this example uses the http adapter, we'll get something like: * // * // PUT /post [{\"id\":3,status\":\"published\"},{\"id\":4,status\":\"published\"}] * store.updateMany('post', [ * { id: 3, status: 'published' }, * { id: 4, status: 'published' } * ]).then((posts) =&gt; { * // The post records have also been updated in the in-memory store * console.log(store.getAll('post', 3, 4)); * }); * * @fires SimpleStore#beforeUpdateMany * @fires SimpleStore#afterUpdateMany * @fires SimpleStore#add * @method SimpleStore#updateMany * @param {string} name Name of the {@link Mapper} to target. * @param {(Object[]|Record[])} records Passed to {@link Mapper#updateMany}. * @param {object} [opts] Passed to {@link Mapper#updateMany}. See * {@link Mapper#updateMany} for more configuration options. * @returns {Promise} Resolves with the result of the update. * @since 3.0.0 */ updateMany (name, records, opts) { opts || (opts = {}) return Container.prototype.updateMany.call(this, name, records, opts) .then((result) =&gt; this._end(name, result, opts)) } } proxiedCollectionMethods.forEach(function (method) { props[method] = function (name, ...args) { return this.getCollection(name)[method](...args) } }) export default Container.extend(props) /** * Fired when a record changes. Only works for records that have tracked fields. * See {@link SimpleStore~changeListener} on how to listen for this event. * * @event SimpleStore#change * @see SimpleStore~changeListener */ /** * Callback signature for the {@link SimpleStore#event:change} event. * * @example * function onChange (mapperName, record, changes) { * // do something * } * store.on('change', onChange); * * @callback SimpleStore~changeListener * @param {string} name The name of the associated {@link Mapper}. * @param {Record} record The Record that changed. * @param {object} changes The changes. * @see SimpleStore#event:change * @since 3.0.0 */ /** * Fired when one or more records are added to the in-memory store. See * {@link SimpleStore~addListener} on how to listen for this event. * * @event SimpleStore#add * @see SimpleStore~addListener * @see SimpleStore#event:add * @see SimpleStore#add * @see SimpleStore#create * @see SimpleStore#createMany * @see SimpleStore#find * @see SimpleStore#findAll * @see SimpleStore#update * @see SimpleStore#updateAll * @see SimpleStore#updateMany */ /** * Callback signature for the {@link SimpleStore#event:add} event. * * @example * function onAdd (mapperName, recordOrRecords) { * // do something * } * store.on('add', onAdd); * * @callback SimpleStore~addListener * @param {string} name The name of the associated {@link Mapper}. * @param {Record|Record[]} The Record or Records that were added. * @see SimpleStore#event:add * @see SimpleStore#add * @see SimpleStore#create * @see SimpleStore#createMany * @see SimpleStore#find * @see SimpleStore#findAll * @see SimpleStore#update * @see SimpleStore#updateAll * @see SimpleStore#updateMany * @since 3.0.0 */ /** * Fired when one or more records are removed from the in-memory store. See * {@link SimpleStore~removeListener} for how to listen for this event. * * @event SimpleStore#remove * @see SimpleStore~removeListener * @see SimpleStore#event:remove * @see SimpleStore#clear * @see SimpleStore#destroy * @see SimpleStore#destroyAll * @see SimpleStore#remove * @see SimpleStore#removeAll */ /** * Callback signature for the {@link SimpleStore#event:remove} event. * * @example * function onRemove (mapperName, recordsOrRecords) { * // do something * } * store.on('remove', onRemove); * * @callback SimpleStore~removeListener * @param {string} name The name of the associated {@link Mapper}. * @param {Record|Record[]} Record or Records that were removed. * @see SimpleStore#event:remove * @see SimpleStore#clear * @see SimpleStore#destroy * @see SimpleStore#destroyAll * @see SimpleStore#remove * @see SimpleStore#removeAll * @since 3.0.0 */ /** * Create a subclass of this SimpleStore: * @example &lt;caption&gt;SimpleStore.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { SimpleStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomSimpleStoreClass extends SimpleStore { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customSimpleStore = new CustomSimpleStoreClass(); * console.log(customSimpleStore.foo()); * console.log(CustomSimpleStoreClass.beep()); * * // Extend the class using alternate method. * const OtherSimpleStoreClass = SimpleStore.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const otherSimpleStore = new OtherSimpleStoreClass(); * console.log(otherSimpleStore.foo()); * console.log(OtherSimpleStoreClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherSimpleStoreClass () { * SimpleStore.call(this) * this.created_at = new Date().getTime() * } * SimpleStore.extend({ * constructor: AnotherSimpleStoreClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherSimpleStore = new AnotherSimpleStoreClass(); * console.log(anotherSimpleStore.created_at); * console.log(anotherSimpleStore.foo()); * console.log(AnotherSimpleStoreClass.beep()); * * @method SimpleStore.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this SimpleStore class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.js.html":{"id":"LinkedCollection.js.html","title":"Source: LinkedCollection.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: LinkedCollection.js import utils from './utils' import './decorators' import Collection from './Collection' const DOMAIN = 'LinkedCollection' /** * Extends {@link Collection}. Used by a {@link DataStore} to implement an * Identity Map. * * ```javascript * import {LinkedCollection} from 'js-data' * ``` * * @class LinkedCollection * @extends Collection * @param {array} [records] Initial set of records to insert into the * collection. See {@link Collection}. * @param {object} [opts] Configuration options. See {@link Collection}. * @returns {Mapper} */ function LinkedCollection (records, opts) { utils.classCallCheck(this, LinkedCollection) // Make sure this collection has somewhere to store \"added\" timestamps Object.defineProperties(this, { _added: { value: {} }, datastore: { writable: true, value: undefined } }) Collection.call(this, records, opts) // Make sure this collection has a reference to a datastore if (!this.datastore) { throw utils.err(`new ${DOMAIN}`, 'opts.datastore')(400, 'DataStore', this.datastore) } } export default Collection.extend({ constructor: LinkedCollection, _addMeta (record, timestamp) { // Track when this record was added this._added[this.recordId(record)] = timestamp if (utils.isFunction(record._set)) { record._set('$', timestamp) } }, _clearMeta (record) { delete this._added[this.recordId(record)] if (utils.isFunction(record._set)) { record._set('$') // unset } }, _onRecordEvent (...args) { Collection.prototype._onRecordEvent.apply(this, args) const event = args[0] // This is a very brute force method // Lots of room for optimization if (utils.isString(event) &amp;&amp; event.indexOf('change') === 0) { this.updateIndexes(args[1]) } }, add (records, opts) { const mapper = this.mapper const timestamp = new Date().getTime() const singular = utils.isObject(records) &amp;&amp; !utils.isArray(records) if (singular) { records = [records] } records = Collection.prototype.add.call(this, records, opts) if (mapper.relationList.length &amp;&amp; records.length) { // Check the currently visited record for relations that need to be // inserted into their respective collections. mapper.relationList.forEach(function (def) { def.addLinkedRecords(records) }) } records.forEach((record) =&gt; this._addMeta(record, timestamp)) return singular ? records[0] : records }, remove (idOrRecord, opts) { const mapper = this.mapper const record = Collection.prototype.remove.call(this, idOrRecord, opts) if (record) { this._clearMeta(record) } if (mapper.relationList.length &amp;&amp; record) { mapper.relationList.forEach(function (def) { def.removeLinkedRecords(mapper, [record]) }) } return record }, removeAll (query, opts) { const mapper = this.mapper const records = Collection.prototype.removeAll.call(this, query, opts) records.forEach(this._clearMeta, this) if (mapper.relationList.length &amp;&amp; records.length) { mapper.relationList.forEach(function (def) { def.removeLinkedRecords(mapper, records) }) } return records } }) /** * Create a subclass of this LinkedCollection: * * @example &lt;caption&gt;LinkedCollection.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { LinkedCollection } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomLinkedCollectionClass extends LinkedCollection { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customLinkedCollection = new CustomLinkedCollectionClass(); * console.log(customLinkedCollection.foo()); * console.log(CustomLinkedCollectionClass.beep()); * * // Extend the class using alternate method. * const OtherLinkedCollectionClass = LinkedCollection.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherLinkedCollection = new OtherLinkedCollectionClass(); * console.log(otherLinkedCollection.foo()); * console.log(OtherLinkedCollectionClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherLinkedCollectionClass () { * LinkedCollection.call(this); * this.created_at = new Date().getTime(); * } * LinkedCollection.extend({ * constructor: AnotherLinkedCollectionClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherLinkedCollection = new AnotherLinkedCollectionClass(); * console.log(anotherLinkedCollection.created_at); * console.log(anotherLinkedCollection.foo()); * console.log(AnotherLinkedCollectionClass.beep()); * * @method LinkedCollection.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this LinkedCollection class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: index.js /** * Registered as `js-data` in NPM and Bower. * * Also available from CDN.JS and JSDelivr. * * @module js-data * * @example &lt;caption&gt;Install from NPM&lt;/caption&gt; * npm i --save js-data@beta * @example &lt;caption&gt;Install from Bower&lt;/caption&gt; * bower i --save js-data@3.0.0-beta.1 * @example &lt;caption&gt;Install from CDN.JS&lt;/caption&gt; * &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; * @example &lt;caption&gt;Install from JSDelivr&lt;/caption&gt; * &lt;script src=\"https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; * @example &lt;caption&gt;Load into your app via script tag&lt;/caption&gt; * &lt;script src=\"/path/to/js-data.min.js\"&gt;&lt;/script&gt; * &lt;script&gt; * console.log(JSData.version.full); // \"3.0.0-beta.1\" * &lt;/script&gt; * @example &lt;caption&gt;Load into your app via CommonJS&lt;/caption&gt; * var JSData = require('js-data'); * @example &lt;caption&gt;Load into your app via ES2015 Modules&lt;/caption&gt; * import * as JSData from 'js-data'; * @example &lt;caption&gt;Load into your app via AMD&lt;/caption&gt; * define('myApp', ['js-data'], function (JSData) { ... }); */ /** * JSData's utility methods. * * @example * import { utils } from 'js-data'; * console.log(utils.isString('foo')); // true * * @name module:js-data.utils * @property {Function} Promise See {@link utils.Promise}. * @see utils * @since 3.0.0 * @type {Object} */ import utils from './utils' /** * JSData's {@link Collection} class. * * @example * import { Collection } from 'js-data'; * const collection = new Collection(); * * @name module:js-data.Collection * @see Collection * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#collection\",\"Components of JSData: Collection\"] * @type {Constructor} */ import Collection from './Collection' /** * JSData's {@link Component} class. Most components in JSData extend this * class. * * @example * import { Component } from 'js-data'; * // Make a custom component. * const MyComponent = Component.extend({ * myMethod (someArg) { ... } * }); * * @name module:js-data.Component * @see Component * @since 3.0.0 * @type {Constructor} */ import Component from './Component' /** * JSData's {@link Container} class. Defines and manages {@link Mapper}s. Used * in Node.js and in the browser, though in the browser you may want to use * {@link DataStore} instead. * * @example * import { Container } from 'js-data'; * const store = new Container(); * * @name module:js-data.Container * @see Container * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#container\",\"Components of JSData: Container\"] * @type {Constructor} */ import {Container} from './Container' /** * JSData's {@link DataStore} class. Primarily for use in the browser. In * Node.js you probably want to use {@link Container} instead. * * @example * import { DataStore } from 'js-data'; * const store = new DataStore(); * * @name module:js-data.DataStore * @see DataStore * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#datastore\",\"Components of JSData: DataStore\"] * @type {Constructor} */ import DataStore from './DataStore' /** * JSData's {@link Index} class, based on [mindex]{@link https://github.com/internalfx/mindex}. * * @name module:js-data.Index * @see Index * @since 3.0.0 * @type {Constructor} */ import Index from '../lib/mindex/index' /** * JSData's {@link LinkedCollection} class. Used by the {@link DataStore} * component. If you need to create a collection manually, you should probably * use the {@link Collection} class. * * @name module:js-data.LinkedCollection * @see DataStore * @see LinkedCollection * @since 3.0.0 * @type {Constructor} */ import LinkedCollection from './LinkedCollection' /** * JSData's {@link Mapper} class. The core of the ORM. * * @example &lt;caption&gt;Recommended use&lt;/caption&gt; * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('user'); * * @example &lt;caption&gt;Create Mapper manually&lt;/caption&gt; * import { Mapper } from 'js-data'; * const UserMapper = new Mapper({ name: 'user' }); * * @name module:js-data.Mapper * @see Container * @see Mapper * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/modeling-your-data\",\"Modeling your data\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper\",\"Components of JSData: Mapper\"] * @type {Constructor} */ import Mapper from './Mapper' /** * JSData's {@link Query} class. Used by the {@link Collection} component. * * @name module:js-data.Query * @see Query * @since 3.0.0 * @type {Constructor} */ import Query from './Query' /** * JSData's {@link Record} class. * * @example * import { Container } from 'js-data'; * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user'); * * @name module:js-data.Record * @see Record * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#record\",\"Components of JSData: Record\"] * @type {Constructor} */ import Record from './Record' /** * JSData's {@link Schema} class. Implements http://json-schema.org/draft-04. * * @example * import { Container, Schema } from 'js-data'; * const userSchema = new Schema({ * properties: { * id: { type: 'string' }, * name: { type: 'string' } * } * }); * const store = new Container(); * store.defineMapper('user', { * schema: userSchema * }); * * @name module:js-data.Schema * @see Schema * @see http://json-schema.org/ * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#schema\",\"Components of JSData: schema\"] * @tutorial [\"http://www.js-data.io/v3.0/docs/schemas\",\"JSData's Schema Syntax\"] * @type {Constructor} */ import Schema from './Schema' /** * JSData's {@link Settable} class. * * @example * import { Settable } from 'js-data'; * const obj = new Settable(); * obj.set('secret', 'value'); * console.log(JSON.stringify(obj)); // {} * * @name module:js-data.Settable * @see Settable * @since 3.0.0 * @type {Constructor} */ import Settable from './Settable' /** * JSData's {@link SimpleStore} class. Primarily for use in the browser. In * Node.js you probably want to use {@link Container} instead. * * @example * import { SimpleStore } from 'js-data'; * const store = new SimpleStore(); * * @name module:js-data.SimpleStore * @see SimpleStore * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/components-of-jsdata#SimpleStore\",\"Components of JSData: SimpleStore\"] * @type {Constructor} */ import SimpleStore from './SimpleStore' /** * Describes the version of this `JSData` object. * * @example * console.log(JSData.version.full); // \"3.0.0-beta.1\" * * @name version * @memberof module:js-data * @property {string} full The full semver value. * @property {number} major The major version number. * @property {number} minor The minor version number. * @property {number} patch The patch version number. * @property {(string|boolean)} alpha The alpha version value, otherwise `false` * if the current version is not alpha. * @property {(string|boolean)} beta The beta version value, otherwise `false` * if the current version is not beta. * @since 2.0.0 * @type {Object} */ export const version = '&lt;%= version %&gt;' export * from './decorators' export { Collection, Component, Container, DataStore, Index, LinkedCollection, Mapper, Query, Record, Schema, Settable, SimpleStore, utils } × Search results Close api.js-data.io • js-data.io "},"decorators.js.html":{"id":"decorators.js.html","title":"Source: decorators.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: decorators.js import { Relation } from './relations' export { belongsToType, hasManyType, hasOneType } from './relations' /** * BelongsTo relation decorator. You probably won't use this directly. * * @name module:js-data.belongsTo * @method * @param {Mapper} related The relation the target belongs to. * @param {object} opts Configuration options. * @param {string} opts.foreignKey The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const belongsTo = function (related, opts) { return function (mapper) { Relation.belongsTo(related, opts).assignTo(mapper) } } /** * HasMany relation decorator. You probably won't use this directly. * * @name module:js-data.hasMany * @method * @param {Mapper} related The relation of which the target has many. * @param {object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasMany = function (related, opts) { return function (mapper) { Relation.hasMany(related, opts).assignTo(mapper) } } /** * HasOne relation decorator. You probably won't use this directly. * * @name module:js-data.hasOne * @method * @param {Mapper} related The relation of which the target has one. * @param {object} opts Configuration options. * @param {string} [opts.foreignKey] The field that holds the primary key of the * related record. * @param {string} opts.localField The field that holds a reference to the * related record object. * @returns {Function} Invocation function, which accepts the target as the only * parameter. */ export const hasOne = function (related, opts) { return function (mapper) { Relation.hasOne(related, opts).assignTo(mapper) } } × Search results Close api.js-data.io • js-data.io "},"Query.js.html":{"id":"Query.js.html","title":"Source: Query.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Query.js import utils from './utils' import Component from './Component' const DOMAIN = 'Query' const INDEX_ERR = 'Index inaccessible after first operation' // Reserved words used by JSData's Query Syntax const reserved = { limit: '', offset: '', orderBy: '', skip: '', sort: '', where: '' } // Used by our JavaScript implementation of the LIKE operator const escapeRegExp = /([.*+?^=!:${}()|[\\]/\\\\])/g const percentRegExp = /%/g const underscoreRegExp = /_/g const escape = function (pattern) { return pattern.replace(escapeRegExp, '\\\\$1') } /** * A class used by the {@link Collection} class to build queries to be executed * against the collection's data. An instance of `Query` is returned by * {@link Collection#query}. Query instances are typically short-lived, and you * shouldn't have to create them yourself. Just use {@link Collection#query}. * * ```javascript * import { Query } from 'js-data'; * ``` * * @example &lt;caption&gt;Query intro&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'draft', id: 2 }, * { author: 'Mike', age: 32, status: 'draft', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'draft', id: 5 } * ] * store.add('post', posts); * const drafts = store.query('post').filter({ status: 'draft' }).limit(2).run(); * console.log(drafts); * * @class Query * @extends Component * @param {Collection} collection The collection on which this query operates. * @since 3.0.0 */ function Query (collection) { utils.classCallCheck(this, Query) /** * The {@link Collection} on which this query operates. * * @name Query#collection * @since 3.0.0 * @type {Collection} */ this.collection = collection /** * The current data result of this query. * * @name Query#data * @since 3.0.0 * @type {Array} */ this.data = null } export default Component.extend({ constructor: Query, _applyWhereFromObject (where) { const fields = [] const ops = [] const predicates = [] utils.forOwn(where, (clause, field) =&gt; { if (!utils.isObject(clause)) { clause = { '==': clause } } utils.forOwn(clause, (expr, op) =&gt; { fields.push(field) ops.push(op) predicates.push(expr) }) }) return { fields, ops, predicates } }, _applyWhereFromArray (where) { const groups = [] where.forEach((_where, i) =&gt; { if (utils.isString(_where)) { return } const prev = where[i - 1] const parser = utils.isArray(_where) ? this._applyWhereFromArray : this._applyWhereFromObject const group = parser.call(this, _where) if (prev === 'or') { group.isOr = true } groups.push(group) }) groups.isArray = true return groups }, _testObjectGroup (keep, first, group, item) { let i const fields = group.fields const ops = group.ops const predicates = group.predicates const len = ops.length for (i = 0; i &lt; len; i++) { let op = ops[i] const isOr = op.charAt(0) === '|' op = isOr ? op.substr(1) : op const expr = this.evaluate(utils.get(item, fields[i]), op, predicates[i]) if (expr !== undefined) { keep = first ? expr : (isOr ? keep || expr : keep &amp;&amp; expr) } first = false } return { keep, first } }, _testArrayGroup (keep, first, groups, item) { let i const len = groups.length for (i = 0; i &lt; len; i++) { const group = groups[i] const parser = group.isArray ? this._testArrayGroup : this._testObjectGroup const result = parser.call(this, true, true, group, item) if (groups[i - 1]) { if (group.isOr) { keep = keep || result.keep } else { keep = keep &amp;&amp; result.keep } } else { keep = result.keep } first = result.first } return { keep, first } }, /** * Find all entities between two boundaries. * * @example &lt;caption&gt;Get the users ages 18 to 30.&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('user'); * const users = [ * { name: 'Peter', age: 25, id: 1 }, * { name: 'Jim', age: 19, id: 2 }, * { name: 'Mike', age: 17, id: 3 }, * { name: 'Alan', age: 29, id: 4 }, * { name: 'Katie', age: 33, id: 5 } * ]; * store.add('user', users) * const filteredUsers = store * .query('user') * .between(18, 30, { index: 'age' }) * .run(); * console.log(filteredUsers); * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('user'); * const users = [ * { name: 'Peter', age: 25, id: 1 }, * { name: 'Jim', age: 19, id: 2 }, * { name: 'Mike', age: 17, id: 3 }, * { name: 'Alan', age: 29, id: 4 }, * { name: 'Katie', age: 33, id: 5 } * ]; * store.add('user', users) * const filteredUsers = store * .query('user') * .between([18], [30], { index: 'age' }) * .run(); * console.log(filteredUsers); * * @method Query#between * @param {array} leftKeys Keys defining the left boundary. * @param {array} rightKeys Keys defining the right boundary. * @param {object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @param {boolean} [opts.leftInclusive=true] Whether to include entities * on the left boundary. * @param {boolean} [opts.rightInclusive=false] Whether to include entities * on the left boundary. * @param {boolean} [opts.limit] Limit the result to a certain number. * @param {boolean} [opts.offset] The number of resulting entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ between (leftKeys, rightKeys, opts) { opts || (opts = {}) if (this.data) { throw utils.err(`${DOMAIN}#between`)(500, 'Cannot access index') } this.data = this.collection.getIndex(opts.index).between(leftKeys, rightKeys, opts) return this }, /** * The comparison function used by the {@link Query} class. * * @method Query#compare * @param {array} orderBy An orderBy clause used for sorting and sub-sorting. * @param {number} index The index of the current orderBy clause being used. * @param {*} a The first item in the comparison. * @param {*} b The second item in the comparison. * @returns {number} -1 if `b` should preceed `a`. 0 if `a` and `b` are equal. * 1 if `a` should preceed `b`. * @since 3.0.0 */ compare (orderBy, index, a, b) { const def = orderBy[index] let cA = utils.get(a, def[0]) let cB = utils.get(b, def[0]) if (cA &amp;&amp; utils.isString(cA)) { cA = cA.toUpperCase() } if (cB &amp;&amp; utils.isString(cB)) { cB = cB.toUpperCase() } if (a === undefined) { a = null } if (b === undefined) { b = null } if (def[1].toUpperCase() === 'DESC') { const temp = cB cB = cA cA = temp } if (cA &lt; cB) { return -1 } else if (cA &gt; cB) { return 1 } else { if (index &lt; orderBy.length - 1) { return this.compare(orderBy, index + 1, a, b) } else { return 0 } } }, /** * Predicate evaluation function used by the {@link Query} class. * * @method Query#evaluate * @param {*} value The value to evaluate. * @param {string} op The operator to use in this evaluation. * @param {*} predicate The predicate to use in this evaluation. * @returns {boolean} Whether the value passed the evaluation or not. * @since 3.0.0 */ evaluate (value, op, predicate) { const ops = this.constructor.ops if (ops[op]) { return ops[op](value, predicate) } if (op.indexOf('like') === 0) { return this.like(predicate, op.substr(4)).exec(value) !== null } else if (op.indexOf('notLike') === 0) { return this.like(predicate, op.substr(7)).exec(value) === null } }, /** * Find the record or records that match the provided query or are accepted by * the provided filter function. * * @example &lt;caption&gt;Get the draft posts by authors younger than 30&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post') * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'draft', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * { author: 'Peter', age: 25, status: 'deleted', id: 6 }, * { author: 'Sally', age: 21, status: 'draft', id: 7 }, * { author: 'Jim', age: 27, status: 'draft', id: 8 }, * { author: 'Jim', age: 27, status: 'published', id: 9 }, * { author: 'Jason', age: 55, status: 'published', id: 10 } * ]; * store.add('post', posts); * const results = store * .query('post') * .filter({ * where: { * status: { * '==': 'draft' * }, * age: { * '&lt;': 30 * } * } * }) * .run(); * console.log(results); * * @example &lt;caption&gt;Use a custom filter function&lt;/caption&gt; * const posts = query * .filter(function (post) { * return post.isReady(); * }) * .run(); * * @method Query#filter * @param {(Object|Function)} [queryOrFn={}] Selection query or filter * function. * @param {Function} [thisArg] Context to which to bind `queryOrFn` if * `queryOrFn` is a function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ filter (query, thisArg) { /** * Selection query as defined by JSData's [Query Syntax][querysyntax]. * * [querysyntax]: http://www.js-data.io/v3.0/docs/query-syntax * * @example &lt;caption&gt;Empty \"findAll\" query&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post') * store.findAll('post').then((posts) =&gt; { * console.log(posts); // [...] * }); * * @example &lt;caption&gt;Empty \"filter\" query&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = store.filter('post'); * console.log(posts); // [...] * * @example &lt;caption&gt;Complex \"filter\" query&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * const PAGE_SIZE = 2; * let currentPage = 3; * * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'draft', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * { author: 'Peter', age: 25, status: 'deleted', id: 6 }, * { author: 'Sally', age: 21, status: 'draft', id: 7 }, * { author: 'Jim', age: 27, status: 'draft', id: 8 }, * { author: 'Jim', age: 27, status: 'published', id: 9 }, * { author: 'Jason', age: 55, status: 'published', id: 10 } * ]; * store.add('post', posts); * // Retrieve a filtered page of blog posts * // Would typically replace filter with findAll * const results = store.filter('post', { * where: { * status: { * // WHERE status = 'published' * '==': 'published' * }, * author: { * // AND author IN ('bob', 'alice') * 'in': ['bob', 'alice'], * // OR author IN ('karen') * '|in': ['karen'] * } * }, * orderBy: [ * // ORDER BY date_published DESC, * ['date_published', 'DESC'], * // ORDER BY title ASC * ['title', 'ASC'] * ], * // LIMIT 2 * limit: PAGE_SIZE, * // SKIP 4 * offset: PAGE_SIZE * (currentPage - 1) * }); * console.log(results); * * @namespace query * @property {number} [limit] See {@link query.limit}. * @property {number} [offset] See {@link query.offset}. * @property {string|Array[]} [orderBy] See {@link query.orderBy}. * @property {number} [skip] Alias for {@link query.offset}. * @property {string|Array[]} [sort] Alias for {@link query.orderBy}. * @property {Object} [where] See {@link query.where}. * @since 3.0.0 * @tutorial [\"http://www.js-data.io/v3.0/docs/query-syntax\",\"JSData's Query Syntax\"] */ query || (query = {}) this.getData() if (utils.isObject(query)) { let where = {} /** * Filtering criteria. Records that do not meet this criteria will be exluded * from the result. * * @example &lt;caption&gt;Return posts where author is at least 32 years old&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post') * const posts = [ * { author: 'John', age: 30, id: 5 }, * { author: 'Sally', age: 31, id: 6 }, * { author: 'Mike', age: 32, id: 7 }, * { author: 'Adam', age: 33, id: 8 }, * { author: 'Adam', age: 33, id: 9 } * ]; * store.add('post', posts); * const results = store.filter('post', { * where: { * age: { * '&gt;=': 30 * } * } * }); * console.log(results); * * @name query.where * @type {Object} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isObject(query.where) || utils.isArray(query.where)) { where = query.where } utils.forOwn(query, function (value, key) { if (!(key in reserved) &amp;&amp; !(key in where)) { where[key] = { '==': value } } }) let groups // Apply filter for each field if (utils.isObject(where) &amp;&amp; Object.keys(where).length !== 0) { groups = this._applyWhereFromArray([where]) } else if (utils.isArray(where)) { groups = this._applyWhereFromArray(where) } if (groups) { this.data = this.data.filter((item, i) =&gt; this._testArrayGroup(true, true, groups, item).keep) } // Sort let orderBy = query.orderBy || query.sort if (utils.isString(orderBy)) { orderBy = [ [orderBy, 'ASC'] ] } if (!utils.isArray(orderBy)) { orderBy = null } /** * Determines how records should be ordered in the result. * * @example &lt;caption&gt;Order posts by `author` then by `id` descending &lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post') * const posts = [ * { author: 'John', age: 30, id: 5 }, * { author: 'Sally', age: 31, id: 6 }, * { author: 'Mike', age: 32, id: 7 }, * { author: 'Adam', age: 33, id: 8 }, * { author: 'Adam', age: 33, id: 9 } * ]; * store.add('post', posts); * const results = store.filter('post', { * orderBy:[['author','ASC'],['id','DESC']] * }); * console.log(results); * * @name query.orderBy * @type {string|Array[]} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (orderBy) { let index = 0 orderBy.forEach(function (def, i) { if (utils.isString(def)) { orderBy[i] = [def, 'ASC'] } }) this.data.sort((a, b) =&gt; this.compare(orderBy, index, a, b)) } /** * Number of records to skip. * * @example &lt;caption&gt;Retrieve the first \"page\" of blog posts using findAll&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const PAGE_SIZE = 10; * let currentPage = 1; * store.findAll('post', { * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }); * * @example &lt;caption&gt;Retrieve the last \"page\" of blog posts using filter&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * * const PAGE_SIZE = 5; * let currentPage = 2; * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, id: 1 }, * { author: 'Sally', age: 31, id: 2 }, * { author: 'Mike', age: 32, id: 3 }, * { author: 'Adam', age: 33, id: 4 }, * { author: 'Adam', age: 33, id: 5 }, * { author: 'Peter', age: 25, id: 6 }, * { author: 'Sally', age: 21, id: 7 }, * { author: 'Jim', age: 27, id: 8 }, * { author: 'Jim', age: 27, id: 9 }, * { author: 'Jason', age: 55, id: 10 } * ]; * store.add('post', posts); * const results = store.filter('post', { * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }); * console.log(results) * * @name query.offset * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.skip)) { this.skip(query.skip) } else if (utils.isNumber(query.offset)) { this.skip(query.offset) } /** * Maximum number of records to retrieve. * * @example &lt;caption&gt;Retrieve the first \"page\" of blog posts using findAll&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * * const PAGE_SIZE = 10 * let currentPage = 1 * store.findAll('post', { * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }); * * @example &lt;caption&gt;Retrieve the last \"page\" of blog posts using filter&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * * const PAGE_SIZE = 5 * let currentPage = 2 * store.defineMapper('post') * const posts = [ * { author: 'John', age: 30, id: 1 }, * { author: 'Sally', age: 31, id: 2 }, * { author: 'Mike', age: 32, id: 3 }, * { author: 'Adam', age: 33, id: 4 }, * { author: 'Adam', age: 33, id: 5 }, * { author: 'Peter', age: 25, id: 6 }, * { author: 'Sally', age: 21, id: 7 }, * { author: 'Jim', age: 27, id: 8 }, * { author: 'Jim', age: 27, id: 9 }, * { author: 'Jason', age: 55, id: 10 } * ]; * store.add('post', posts); * const results = store.filter('post', { * offset: PAGE_SIZE * (currentPage 1) * limit: PAGE_SIZE * }); * console.log(results) * * @name query.limit * @type {number} * @see http://www.js-data.io/v3.0/docs/query-syntax * @since 3.0.0 */ if (utils.isNumber(query.limit)) { this.limit(query.limit) } } else if (utils.isFunction(query)) { this.data = this.data.filter(query, thisArg) } return this }, /** * Iterate over all entities. * * @method Query#forEach * @param {Function} forEachFn Iteration function. * @param {*} [thisArg] Context to which to bind `forEachFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ forEach (forEachFn, thisArg) { this.getData().forEach(forEachFn, thisArg) return this }, /** * Find the entity or entities that match the provided key. * * @example &lt;caption&gt;Get the entity whose primary key is 25.&lt;/caption&gt; * const entities = query.get(25).run(); * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const entities = query.get([25]).run(); * * @example &lt;caption&gt;Get all users who are active and have the \"admin\" role.&lt;/caption&gt; * const activeAdmins = query.get(['active', 'admin'], { * index: 'activityAndRoles' * }).run(); * * @example &lt;caption&gt;Get all entities that match a certain weather condition.&lt;/caption&gt; * const niceDays = query.get(['sunny', 'humid', 'calm'], { * index: 'weatherConditions' * }).run(); * * @method Query#get * @param {array} keyList Key(s) defining the entity to retrieve. If * `keyList` is not an array (i.e. for a single-value key), it will be * wrapped in an array. * @param {object} [opts] Configuration options. * @param {string} [opts.string] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ get (keyList, opts) { keyList || (keyList = []) opts || (opts = {}) if (this.data) { throw utils.err(`${DOMAIN}#get`)(500, INDEX_ERR) } if (keyList &amp;&amp; !utils.isArray(keyList)) { keyList = [keyList] } if (!keyList.length) { this.getData() return this } this.data = this.collection.getIndex(opts.index).get(keyList) return this }, /** * Find the entity or entities that match the provided keyLists. * * @example &lt;caption&gt;Get the posts where \"status\" is \"draft\" or \"inReview\".&lt;/caption&gt; * const posts = query.getAll('draft', 'inReview', { index: 'status' }).run(); * * @example &lt;caption&gt;Same as above.&lt;/caption&gt; * const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run(); * * @method Query#getAll * @param {...Array} [keyList] Provide one or more keyLists, and all * entities matching each keyList will be retrieved. If no keyLists are * provided, all entities will be returned. * @param {object} [opts] Configuration options. * @param {string} [opts.index] Name of the secondary index to use in the * query. If no index is specified, the main index is used. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ getAll (...args) { let opts = {} if (this.data) { throw utils.err(`${DOMAIN}#getAll`)(500, INDEX_ERR) } if (!args.length || (args.length === 1 &amp;&amp; utils.isObject(args[0]))) { this.getData() return this } else if (args.length &amp;&amp; utils.isObject(args[args.length - 1])) { opts = args[args.length - 1] args.pop() } const collection = this.collection const index = collection.getIndex(opts.index) this.data = [] args.forEach((keyList) =&gt; { this.data = this.data.concat(index.get(keyList)) }) return this }, /** * Return the current data result of this query. * * @method Query#getData * @returns {Array} The data in this query. * @since 3.0.0 */ getData () { if (!this.data) { this.data = this.collection.index.getAll() } return this.data }, /** * Implementation used by the `like` operator. Takes a pattern and flags and * returns a `RegExp` instance that can test strings. * * @method Query#like * @param {string} pattern Testing pattern. * @param {string} flags Flags for the regular expression. * @returns {RegExp} Regular expression for testing strings. * @since 3.0.0 */ like (pattern, flags) { return new RegExp(`^${(escape(pattern).replace(percentRegExp, '.*').replace(underscoreRegExp, '.'))}$`, flags) }, /** * Limit the result. * * @example &lt;caption&gt;Get only the first 2 posts.&lt;/caption&gt; * const store = new JSData.DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'draft', id: 2 }, * { author: 'Mike', age: 32, status: 'draft', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'draft', id: 5 } * ]; * store.add('post', posts); * const results = store.query('post').limit(2).run(); * console.log(results); * * @method Query#limit * @param {number} num The maximum number of entities to keep in the result. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ limit (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#limit`, 'num')(400, 'number', num) } const data = this.getData() this.data = data.slice(0, Math.min(data.length, num)) return this }, /** * Apply a mapping function to the result data. * * @example * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('user'); * const users = [ * { name: 'Peter', age: 25, id: 1 }, * { name: 'Jim', age: 19, id: 2 }, * { name: 'Mike', age: 17, id: 3 }, * { name: 'Alan', age: 29, id: 4 }, * { name: 'Katie', age: 33, id: 5 } * ]; * store.add('user', users); * const ages = store * .query('user') * .map(function (user) { * return user.age; * }) * .run(); * console.log(ages); * * @method Query#map * @param {Function} mapFn Mapping function. * @param {*} [thisArg] Context to which to bind `mapFn`. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ map (mapFn, thisArg) { this.data = this.getData().map(mapFn, thisArg) return this }, /** * Return the result of calling the specified function on each item in this * collection's main index. * * @example * const stringAges = UserCollection.query().mapCall('toString').run(); * * @method Query#mapCall * @param {string} funcName Name of function to call * @parama {...*} [args] Remaining arguments to be passed to the function. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ mapCall (funcName, ...args) { this.data = this.getData().map(function (item) { return item[funcName](...args) }) return this }, /** * Complete the execution of the query and return the resulting data. * * @method Query#run * @returns {Array} The result of executing this query. * @since 3.0.0 */ run () { const data = this.data this.data = null return data }, /** * Skip a number of results. * * @example &lt;caption&gt;Get all but the first 2 posts.&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'draft', id: 2 }, * { author: 'Mike', age: 32, status: 'draft', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'draft', id: 5 } * ]; * store.add('post', posts); * const results = store.query('post').skip(2).run(); * console.log(results); * * @method Query#skip * @param {number} num The number of entities to skip. * @returns {Query} A reference to itself for chaining. * @since 3.0.0 */ skip (num) { if (!utils.isNumber(num)) { throw utils.err(`${DOMAIN}#skip`, 'num')(400, 'number', num) } const data = this.getData() if (num &lt; data.length) { this.data = data.slice(num) } else { this.data = [] } return this } }, { /** * The filtering operators supported by {@link Query#filter}, and which are * implemented by adapters (for the most part). * * @example &lt;caption&gt;Variant 1&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'published', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * ]; * store.add('post', posts); * const publishedPosts = store.filter('post', { * status: 'published', * limit: 2 * }); * console.log(publishedPosts); * * * @example &lt;caption&gt;Variant 2&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post') * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'published', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * ]; * store.add('post', posts); * const publishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * } * }, * limit: 2 * }); * console.log(publishedPosts); * * @example &lt;caption&gt;Variant 3&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'published', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * ]; * store.add('post', posts); * const publishedPosts = store * .query('post') * .filter({ status: 'published' }) * .limit(2) * .run(); * console.log(publishedPosts); * * @example &lt;caption&gt;Variant 4&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'published', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * ]; * store.add('post', posts); * const publishedPosts = store * .query('post') * .filter({ * where: { * status: { * '==': 'published' * } * } * }) * .limit(2) * .run(); * console.log(publishedPosts); * * @example &lt;caption&gt;Multiple operators&lt;/caption&gt; * const JSData = require('js-data'); * const { DataStore } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new DataStore(); * store.defineMapper('post'); * const posts = [ * { author: 'John', age: 30, status: 'published', id: 1 }, * { author: 'Sally', age: 31, status: 'published', id: 2 }, * { author: 'Mike', age: 32, status: 'published', id: 3 }, * { author: 'Adam', age: 33, status: 'deleted', id: 4 }, * { author: 'Adam', age: 33, status: 'published', id: 5 } * ]; * store.add('post', posts); * * const myPublishedPosts = store.filter('post', { * where: { * status: { * '==': 'published' * }, * user_id: { * '==': currentUser.id * } * } * }); * * console.log(myPublishedPosts); * * @name Query.ops * @property {Function} == Equality operator. * @property {Function} != Inequality operator. * @property {Function} &gt; Greater than operator. * @property {Function} &gt;= Greater than (inclusive) operator. * @property {Function} &lt; Less than operator. * @property {Function} &lt;= Less than (inclusive) operator. * @property {Function} isectEmpty Operator that asserts that the intersection * between two arrays is empty. * @property {Function} isectNotEmpty Operator that asserts that the * intersection between two arrays is __not__ empty. * @property {Function} in Operator that asserts whether a value is in an * array. * @property {Function} notIn Operator that asserts whether a value is __not__ * in an array. * @property {Function} contains Operator that asserts whether an array * contains a value. * @property {Function} notContains Operator that asserts whether an array * does __not__ contain a value. * @since 3.0.0 * @type {Object} */ ops: { '=': function (value, predicate) { return value == predicate // eslint-disable-line }, '==': function (value, predicate) { return value == predicate // eslint-disable-line }, '===': function (value, predicate) { return value === predicate }, '!=': function (value, predicate) { return value != predicate // eslint-disable-line }, '!==': function (value, predicate) { return value !== predicate }, '&gt;': function (value, predicate) { return value &gt; predicate }, '&gt;=': function (value, predicate) { return value &gt;= predicate }, '&lt;': function (value, predicate) { return value &lt; predicate }, '&lt;=': function (value, predicate) { return value &lt;= predicate }, 'isectEmpty': function (value, predicate) { return !utils.intersection((value || []), (predicate || [])).length }, 'isectNotEmpty': function (value, predicate) { return utils.intersection((value || []), (predicate || [])).length }, 'in': function (value, predicate) { return predicate.indexOf(value) !== -1 }, 'notIn': function (value, predicate) { return predicate.indexOf(value) === -1 }, 'contains': function (value, predicate) { return (value || []).indexOf(predicate) !== -1 }, 'notContains': function (value, predicate) { return (value || []).indexOf(predicate) === -1 } } }) /** * Create a subclass of this Query: * @example &lt;caption&gt;Query.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Query } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomQueryClass extends Query { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customQuery = new CustomQueryClass(); * console.log(customQuery.foo()); * console.log(CustomQueryClass.beep()); * * // Extend the class using alternate method. * const OtherQueryClass = Query.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherQuery = new OtherQueryClass(); * console.log(otherQuery.foo()); * console.log(OtherQueryClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherQueryClass (collection) { * Query.call(this, collection); * this.created_at = new Date().getTime(); * } * Query.extend({ * constructor: AnotherQueryClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherQuery = new AnotherQueryClass(); * console.log(anotherQuery.created_at); * console.log(anotherQuery.foo()); * console.log(AnotherQueryClass.beep()); * * @method Query.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Query class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Record.js.html":{"id":"Record.js.html","title":"Source: Record.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Record.js import utils, { safeSetLink } from './utils' import Component from './Component' import Settable from './Settable' import { hasManyType, hasOneType } from './decorators' const DOMAIN = 'Record' const superMethod = function (mapper, name) { const store = mapper.datastore if (store &amp;&amp; store[name]) { return function (...args) { return store[name](mapper.name, ...args) } } return mapper[name].bind(mapper) } // Cache these strings const creatingPath = 'creating' const noValidatePath = 'noValidate' const keepChangeHistoryPath = 'keepChangeHistory' const previousPath = 'previous' /** * js-data's Record class. An instance of `Record` corresponds to an in-memory * representation of a single row or document in a database, Firebase, * localstorage, etc. Basically, a `Record` instance represents whatever kind of * entity in your persistence layer that has a primary key. * * ```javascript * import {Record} from 'js-data' * ``` * * @example &lt;caption&gt;Record#constructor&lt;/caption&gt; * const JSData = require('js-data'); * const { Record } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Instantiate a plain record * let record = new Record(); * console.log('record: ' + JSON.stringify(record)); * * // You can supply properties on instantiation * record = new Record({ name: 'John' }); * console.log('record: ' + JSON.stringify(record)); * * @example &lt;caption&gt;Record#constructor2&lt;/caption&gt; * const JSData = require('js-data'); * const { Mapper } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Instantiate a record that's associated with a Mapper: * const UserMapper = new Mapper({ name: 'user' }); * const User = UserMapper.recordClass; * const user = UserMapper.createRecord({ name: 'John' }); * const user2 = new User({ name: 'Sally' }); * console.log('user: ' + JSON.stringify(user)); * console.log('user2: ' + JSON.stringify(user2)); * * @example &lt;caption&gt;Record#constructor3&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.defineMapper('user'); * * // Instantiate a record that's associated with a store's Mapper * const user = store.createRecord('user', { name: 'John' }); * console.log('user: ' + JSON.stringify(user)); * * @example &lt;caption&gt;Record#constructor4&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.defineMapper('user', { * schema: { * properties: { * name: { type: 'string' } * } * } * }); * * // Validate on instantiation * const user = store.createRecord('user', { name: 1234 }); * console.log('user: ' + JSON.stringify(user)); * * @example &lt;caption&gt;Record#constructor5&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.defineMapper('user', { * schema: { * properties: { * name: { type: 'string' } * } * } * }); * * // Skip validation on instantiation * const user = store.createRecord('user', { name: 1234 }, { noValidate: true }); * console.log('user: ' + JSON.stringify(user)); * console.log('user.isValid(): ' + user.isValid()); * * @class Record * @extends Component * @param {object} [props] The initial properties of the new Record instance. * @param {object} [opts] Configuration options. * @param {boolean} [opts.noValidate=false] Whether to skip validation on the * initial properties. * @param {boolean} [opts.validateOnSet=true] Whether to enable setter * validation on properties after the Record has been initialized. * @since 3.0.0 */ function Record (props, opts) { utils.classCallCheck(this, Record) Settable.call(this) props || (props = {}) opts || (opts = {}) const _set = this._set const mapper = this.constructor.mapper _set(creatingPath, true) _set(noValidatePath, !!opts.noValidate) _set(keepChangeHistoryPath, opts.keepChangeHistory === undefined ? (mapper ? mapper.keepChangeHistory : true) : opts.keepChangeHistory) // Set the idAttribute value first, if it exists. const id = mapper ? utils.get(props, mapper.idAttribute) : undefined if (id !== undefined) { utils.set(this, mapper.idAttribute, id) } utils.fillIn(this, props) _set(creatingPath, false) if (opts.validateOnSet !== undefined) { _set(noValidatePath, !opts.validateOnSet) } else if (mapper &amp;&amp; mapper.validateOnSet !== undefined) { _set(noValidatePath, !mapper.validateOnSet) } else { _set(noValidatePath, false) } _set(previousPath, mapper ? mapper.toJSON(props) : utils.plainCopy(props)) } export default Component.extend({ constructor: Record, /** * Returns the {@link Mapper} paired with this record's class, if any. * * @method Record#_mapper * @returns {Mapper} The {@link Mapper} paired with this record's class, if any. * @since 3.0.0 */ _mapper () { const mapper = this.constructor.mapper if (!mapper) { throw utils.err(`${DOMAIN}#_mapper`, '')(404, 'mapper') } return mapper }, /** * Lifecycle hook. * * @method Record#afterLoadRelations * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}. * @param {object} opts The `opts` argument passed to {@link Record#loadRelations}. * @since 3.0.0 */ afterLoadRelations () {}, /** * Lifecycle hook. * * @method Record#beforeLoadRelations * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}. * @param {object} opts The `opts` argument passed to {@link Record#loadRelations}. * @since 3.0.0 */ beforeLoadRelations () {}, /** * Return the change history of this record since it was instantiated or * {@link Record#commit} was called. * * @method Record#changeHistory * @since 3.0.0 */ changeHistory () { return (this._get('history') || []).slice() }, /** * Return changes to this record since it was instantiated or * {@link Record#commit} was called. * * @example &lt;caption&gt;Record#changes&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user'); * console.log('user changes: ' + JSON.stringify(user.changes())); * user.name = 'John'; * console.log('user changes: ' + JSON.stringify(user.changes())); * * @method Record#changes * @param [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {Object} Object describing the changes to this record since it was * instantiated or its {@link Record#commit} method was last called. * @since 3.0.0 */ changes (opts) { opts || (opts = {}) return utils.diffObjects(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts) }, /** * Make the record's current in-memory state it's only state, with any * previous property values being set to current values. * * @example &lt;caption&gt;Record#commit&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user'); * console.log('user hasChanges: ' + user.hasChanges()); * user.name = 'John'; * console.log('user hasChanges: ' + user.hasChanges()); * user.commit(); * console.log('user hasChanges: ' + user.hasChanges()); * * @method Record#commit * @param {object} [opts] Configuration options. Passed to {@link Record#toJSON}. * @since 3.0.0 */ commit (opts) { this._set('changed') // unset this._set('changing', false) this._set('history', []) // clear history this._set('previous', this.toJSON(opts)) }, /** * Call {@link Mapper#destroy} using this record's primary key. * * @example * import { Container } from 'js-data'; * import { RethinkDBAdapter } from 'js-data-rethinkdb'; * * const store = new Container(); * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); * store.defineMapper('user'); * store.find('user', 1234).then((user) =&gt; { * console.log(user.id); // 1234 * * // Destroy this user from the database * return user.destroy(); * }); * * @method Record#destroy * @param {object} [opts] Configuration options passed to {@link Mapper#destroy}. * @returns {Promise} The result of calling {@link Mapper#destroy} with the * primary key of this record. * @since 3.0.0 */ destroy (opts) { opts || (opts = {}) const mapper = this._mapper() return superMethod(mapper, 'destroy')(utils.get(this, mapper.idAttribute), opts) }, /** * Return the value at the given path for this instance. * * @example &lt;caption&gt;Record#get&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * * const user = store.createRecord('user', { name: 'Bob' }); * console.log('user.get(\"name\"): ' + user.get('name')); * * @method Record#get * @param {string} key Path of value to retrieve. * @returns {*} Value at path. * @since 3.0.0 */ 'get' (key) { return utils.get(this, key) }, /** * Return whether this record has changed since it was instantiated or * {@link Record#commit} was called. * * @example &lt;caption&gt;Record#hasChanges&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user'); * console.log('user hasChanges: ' + user.hasChanges()); * user.name = 'John'; * console.log('user hasChanges: ' + user.hasChanges()); * user.commit(); * console.log('user hasChanges: ' + user.hasChanges()); * * @method Record#hasChanges * @param [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {boolean} Return whether the record has changed since it was * instantiated or since its {@link Record#commit} method was called. * @since 3.0.0 */ hasChanges (opts) { const quickHasChanges = !!(this._get('changed') || []).length return quickHasChanges || utils.areDifferent(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts) }, /** * Return whether the record is unsaved. Records that have primary keys are * considered \"saved\". Records without primary keys are considered \"unsaved\". * * @example &lt;caption&gt;Record#isNew&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user', { * id: 1234 * }); * const user2 = store.createRecord('user'); * console.log('user isNew: ' + user.isNew()); // false * console.log('user2 isNew: ' + user2.isNew()); // true * * @method Record#isNew * @returns {boolean} Whether the record is unsaved. * @since 3.0.0 */ isNew (opts) { return utils.get(this, this._mapper().idAttribute) === undefined }, /** * Return whether the record in its current state passes validation. * * @example &lt;caption&gt;Record#isValid&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user', { * schema: { * properties: { * name: { type: 'string' } * } * } * }); * const user = store.createRecord('user', { * name: 1234 * }, { * noValidate: true // this allows us to put the record into an invalid state * }); * console.log('user isValid: ' + user.isValid()); * user.name = 'John'; * console.log('user isValid: ' + user.isValid()); * * @method Record#isValid * @param {object} [opts] Configuration options. Passed to {@link Mapper#validate}. * @returns {boolean} Whether the record in its current state passes * validation. * @since 3.0.0 */ isValid (opts) { return !this._mapper().validate(this, opts) }, removeInverseRelation (currentParent, id, inverseDef, idAttribute) { if (inverseDef.type === hasOneType) { safeSetLink(currentParent, inverseDef.localField, undefined) } else if (inverseDef.type === hasManyType) { // e.g. remove comment from otherPost.comments const children = utils.get(currentParent, inverseDef.localField) if (id === undefined) { utils.remove(children, (child) =&gt; child === this) } else { utils.remove(children, (child) =&gt; child === this || id === utils.get(child, idAttribute)) } } }, setupInverseRelation (record, id, inverseDef, idAttribute) { // Update (set) inverse relation if (inverseDef.type === hasOneType) { // e.g. someUser.profile = profile safeSetLink(record, inverseDef.localField, this) } else if (inverseDef.type === hasManyType) { // e.g. add comment to somePost.comments const children = utils.get(record, inverseDef.localField) if (id === undefined) { utils.noDupeAdd(children, this, (child) =&gt; child === this) } else { utils.noDupeAdd(children, this, (child) =&gt; child === this || id === utils.get(child, idAttribute)) } } }, /** * Lazy load relations of this record, to be attached to the record once their * loaded. * * @example * import { Container } from 'js-data'; * import { RethinkDBAdapter } from 'js-data-rethinkdb'; * * const store = new Container(); * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); * store.defineMapper('user', { * relations: { * hasMany: { * post: { * localField: 'posts', * foreignKey: 'user_id' * } * } * } * }); * store.defineMapper('post', { * relations: { * belongsTo: { * user: { * localField: 'user', * foreignKey: 'user_id' * } * } * } * }); * store.find('user', 1234).then((user) =&gt; { * console.log(user.id); // 1234 * * // Load the user's post relations * return user.loadRelations(['post']); * }).then((user) =&gt; { * console.log(user.posts); // [{...}, {...}, ...] * }); * * @method Record#loadRelations * @param {string[]} [relations] List of relations to load. Can use localField * names or Mapper names to pick relations. * @param {object} [opts] Configuration options. * @returns {Promise} Resolves with the record, with the loaded relations now * attached. * @since 3.0.0 */ loadRelations (relations, opts) { let op const mapper = this._mapper() // Default values for arguments relations || (relations = []) if (utils.isString(relations)) { relations = [relations] } opts || (opts = {}) opts.with = relations // Fill in \"opts\" with the Model's configuration utils._(opts, mapper) opts.adapter = mapper.getAdapterName(opts) // beforeLoadRelations lifecycle hook op = opts.op = 'beforeLoadRelations' return utils.resolve(this[op](relations, opts)).then(() =&gt; { // Now delegate to the adapter op = opts.op = 'loadRelations' mapper.dbg(op, this, relations, opts) let tasks = [] let task utils.forEachRelation(mapper, opts, (def, optsCopy) =&gt; { const relatedMapper = def.getRelation() optsCopy.raw = false if (utils.isFunction(def.load)) { task = def.load(mapper, def, this, opts) } else if (def.type === 'hasMany' || def.type === 'hasOne') { if (def.foreignKey) { task = superMethod(relatedMapper, 'findAll')({ [def.foreignKey]: utils.get(this, mapper.idAttribute) }, optsCopy).then(function (relatedData) { if (def.type === 'hasOne') { return relatedData.length ? relatedData[0] : undefined } return relatedData }) } else if (def.localKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [relatedMapper.idAttribute]: { 'in': utils.get(this, def.localKeys) } } }) } else if (def.foreignKeys) { task = superMethod(relatedMapper, 'findAll')({ where: { [def.foreignKeys]: { 'contains': utils.get(this, mapper.idAttribute) } } }, opts) } } else if (def.type === 'belongsTo') { const key = utils.get(this, def.foreignKey) if (utils.isSorN(key)) { task = superMethod(relatedMapper, 'find')(key, optsCopy) } } if (task) { task = task.then((relatedData) =&gt; { def.setLocalField(this, relatedData) }) tasks.push(task) } }) return Promise.all(tasks) }).then(() =&gt; { // afterLoadRelations lifecycle hook op = opts.op = 'afterLoadRelations' return utils.resolve(this[op](relations, opts)).then(() =&gt; this) }) }, /** * Return the properties with which this record was instantiated. * * @example &lt;caption&gt;Record#previous&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user', { * name: 'William' * }); * console.log('user previous: ' + JSON.stringify(user.previous())); * user.name = 'Bob'; * console.log('user previous: ' + JSON.stringify(user.previous())); * user.commit(); * console.log('user previous: ' + JSON.stringify(user.previous())); * * @method Record#previous * @param {string} [key] If specified, return just the initial value of the * given key. * @returns {Object} The initial properties of this record. * @since 3.0.0 */ previous (key) { if (key) { return this._get(`previous.${key}`) } return this._get('previous') }, /** * Revert changes to this record back to the properties it had when it was * instantiated. * * @example &lt;caption&gt;Record#revert&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * const user = store.createRecord('user', { * name: 'William' * }); * console.log('user: ' + JSON.stringify(user)); * user.name = 'Bob'; * console.log('user: ' + JSON.stringify(user)); * user.revert(); * console.log('user: ' + JSON.stringify(user)); * * @method Record#revert * @param {object} [opts] Configuration options. * @param {string[]} [opts.preserve] Array of strings or Regular Expressions * denoting properties that should not be reverted. * @since 3.0.0 */ revert (opts) { const previous = this._get('previous') opts || (opts = {}) opts.preserve || (opts.preserve = []) utils.forOwn(this, (value, key) =&gt; { if (key !== this._mapper().idAttribute &amp;&amp; !previous.hasOwnProperty(key) &amp;&amp; this.hasOwnProperty(key) &amp;&amp; opts.preserve.indexOf(key) === -1) { delete this[key] } }) utils.forOwn(previous, (value, key) =&gt; { if (opts.preserve.indexOf(key) === -1) { this[key] = value } }) this.commit() }, /** * Delegates to {@link Mapper#create} or {@link Mapper#update}. * * @example * import { Container } from 'js-data'; * import { RethinkDBAdapter } from 'js-data-rethinkdb'; * * const store = new Container(); * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); * store.defineMapper('session'); * const session = store.createRecord('session', { topic: 'Node.js' }); * * // Create a new record in the database * session.save().then(() =&gt; { * console.log(session.id); // 1234 * * session.skill_level = 'beginner'; * * // Update the record in the database * return session.save(); * }); * * @method Record#save * @param {object} [opts] Configuration options. See {@link Mapper#create} and * {@link Mapper#update}. * @param {boolean} [opts.changesOnly] Equality function. Default uses `===`. * @param {Function} [opts.equalsFn] Passed to {@link Record#changes} when * `opts.changesOnly` is `true`. * @param {array} [opts.ignore] Passed to {@link Record#changes} when * `opts.changesOnly` is `true`. * @returns {Promise} The result of calling {@link Mapper#create} or * {@link Mapper#update}. * @since 3.0.0 */ save (opts) { opts || (opts = {}) const mapper = this._mapper() const id = utils.get(this, mapper.idAttribute) let props = this const postProcess = (result) =&gt; { const record = opts.raw ? result.data : result if (record) { utils.deepMixIn(this, record) this.commit() } return result } if (id === undefined) { return superMethod(mapper, 'create')(props, opts).then(postProcess) } if (opts.changesOnly) { const changes = this.changes(opts) props = {} utils.fillIn(props, changes.added) utils.fillIn(props, changes.changed) } return superMethod(mapper, 'update')(id, props, opts).then(postProcess) }, /** * Set the value for a given key, or the values for the given keys if \"key\" is * an object. Triggers change events on those properties that have `track: true` * in {@link Mapper#schema}. * * @example &lt;caption&gt;Record#set&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * * const user = store.createRecord('user'); * console.log('user: ' + JSON.stringify(user)); * * user.set('name', 'Bob'); * console.log('user: ' + JSON.stringify(user)); * * user.set({ age: 30, role: 'admin' }); * console.log('user: ' + JSON.stringify(user)); * * @fires Record#change * @method Record#set * @param {(string|Object)} key Key to set or hash of key-value pairs to set. * @param {*} [value] Value to set for the given key. * @param {object} [opts] Configuration options. * @param {boolean} [opts.silent=false] Whether to trigger change events. * @since 3.0.0 */ 'set' (key, value, opts) { if (utils.isObject(key)) { opts = value } opts || (opts = {}) if (opts.silent) { this._set('silent', true) } utils.set(this, key, value) if (!this._get('eventId')) { this._set('silent') // unset } }, /** * Return a plain object representation of this record. If the class from * which this record was created has a Mapper, then {@link Mapper#toJSON} will * be called with this record instead. * * @example &lt;caption&gt;Record#toJSON&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user', { * schema: { * properties: { * name: { type: 'string' } * } * } * }); * * const user = store.createRecord('user', { * name: 'John', * $$hashKey: '1234' * }); * console.log('user: ' + JSON.stringify(user.toJSON())); * * @method Record#toJSON * @param {object} [opts] Configuration options. * @param {string[]} [opts.with] Array of relation names or relation fields * to include in the representation. Only available as an option if the class * from which this record was created has a Mapper and this record resides in * an instance of {@link DataStore}. * @returns {Object} Plain object representation of this record. * @since 3.0.0 */ toJSON (opts) { const mapper = this.constructor.mapper if (mapper) { return mapper.toJSON(this, opts) } else { const json = {} utils.forOwn(this, (prop, key) =&gt; { json[key] = utils.plainCopy(prop) }) return json } }, /** * Unset the value for a given key. Triggers change events on those properties * that have `track: true` in {@link Mapper#schema}. * * @example &lt;caption&gt;Record#unset&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user'); * * const user = store.createRecord('user', { * name: 'John' * }); * console.log('user: ' + JSON.stringify(user)); * * user.unset('name'); * console.log('user: ' + JSON.stringify(user)); * * @method Record#unset * @param {string} key Key to unset. * @param {object} [opts] Configuration options. * @param {boolean} [opts.silent=false] Whether to trigger change events. * @since 3.0.0 */ unset (key, opts) { this.set(key, undefined, opts) }, /** * Validate this record based on its current properties. * * @example &lt;caption&gt;Record#validate&lt;/caption&gt; * const JSData = require('js-data'); * const { Container } = JSData; * console.log('Using JSData v' + JSData.version.full); * const store = new Container(); * store.defineMapper('user', { * schema: { * properties: { * name: { type: 'string' } * } * } * }); * const user = store.createRecord('user', { * name: 1234 * }, { * noValidate: true // this allows us to put the record into an invalid state * }); * console.log('user validation: ' + JSON.stringify(user.validate())); * user.name = 'John'; * console.log('user validation: ' + user.validate()); * * @method Record#validate * @param {object} [opts] Configuration options. Passed to {@link Mapper#validate}. * @returns {*} Array of errors or `undefined` if no errors. * @since 3.0.0 */ validate (opts) { return this._mapper().validate(this, opts) } }, { creatingPath, noValidatePath, keepChangeHistoryPath, previousPath }) /** * Allow records to emit events. * * An record's registered listeners are stored in the record's private data. */ utils.eventify( Record.prototype, function () { return this._get('events') }, function (value) { this._set('events', value) } ) /** * Fired when a record changes. Only works for records that have tracked fields. * See {@link Record~changeListener} on how to listen for this event. * * @event Record#change * @see Record~changeListener */ /** * Callback signature for the {@link Record#event:change} event. * * @example * function onChange (record, changes) { * // do something * } * record.on('change', onChange); * * @callback Record~changeListener * @param {Record} The Record that changed. * @param {object} The changes. * @see Record#event:change * @since 3.0.0 */ /** * Create a subclass of this Record: * @example &lt;caption&gt;Record.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Record } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomRecordClass extends Record { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customRecord = new CustomRecordClass(); * console.log(customRecord.foo()); * console.log(CustomRecordClass.beep()); * * // Extend the class using alternate method. * const OtherRecordClass = Record.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherRecord = new OtherRecordClass(); * console.log(otherRecord.foo()); * console.log(OtherRecordClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherRecordClass () { * Record.call(this); * this.created_at = new Date().getTime(); * } * Record.extend({ * constructor: AnotherRecordClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherRecord = new AnotherRecordClass(); * console.log(anotherRecord.created_at); * console.log(anotherRecord.foo()); * console.log(AnotherRecordClass.beep()); * * @method Record.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Record class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"Schema.js.html":{"id":"Schema.js.html","title":"Source: Schema.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: Schema.js import utils from './utils' import Component from './Component' const DOMAIN = 'Schema' /** * A function map for each of the seven primitive JSON types defined by the core specification. * Each function will check a given value and return true or false if the value is an instance of that type. * ``` * types.integer(1) // returns true * types.string({}) // returns false * ``` * http://json-schema.org/latest/json-schema-core.html#anchor8 * @name Schema.types * @type {object} */ const types = { array: utils.isArray, boolean: utils.isBoolean, integer: utils.isInteger, 'null': utils.isNull, number: utils.isNumber, object: utils.isObject, string: utils.isString } /** * @ignore */ const segmentToString = function (segment, prev) { let str = '' if (segment) { if (utils.isNumber(segment)) { str += `[${segment}]` } else if (prev) { str += `.${segment}` } else { str += `${segment}` } } return str } /** * @ignore */ const makePath = function (opts) { opts || (opts = {}) let path = '' const segments = opts.path || [] segments.forEach(function (segment) { path += segmentToString(segment, path) }) path += segmentToString(opts.prop, path) return path } /** * @ignore */ const makeError = function (actual, expected, opts) { return { expected, actual: '' + actual, path: makePath(opts) } } /** * @ignore */ const addError = function (actual, expected, opts, errors) { errors.push(makeError(actual, expected, opts)) } /** * @ignore */ const maxLengthCommon = function (keyword, value, schema, opts) { const max = schema[keyword] if (value.length &gt; max) { return makeError(value.length, `length no more than ${max}`, opts) } } /** * @ignore */ const minLengthCommon = function (keyword, value, schema, opts) { const min = schema[keyword] if (value.length &lt; min) { return makeError(value.length, `length no less than ${min}`, opts) } } /** * A map of all object member validation functions for each keyword defined in the JSON Schema. * @name Schema.validationKeywords * @type {object} */ const validationKeywords = { /** * Validates the provided value against all schemas defined in the Schemas `allOf` keyword. * The instance is valid against if and only if it is valid against all the schemas declared in the Schema's value. * * The value of this keyword MUST be an array. This array MUST have at least one element. * Each element of this array MUST be a valid JSON Schema. * * see http://json-schema.org/latest/json-schema-validation.html#anchor82 * * @name Schema.validationKeywords.allOf * @method * @param {*} value Value to be validated. * @param {object} schema Schema containing the `allOf` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ allOf (value, schema, opts) { let allErrors = [] schema.allOf.forEach(function (_schema) { allErrors = allErrors.concat(validate(value, _schema, opts) || []) }) return allErrors.length ? allErrors : undefined }, /** * Validates the provided value against all schemas defined in the Schemas `anyOf` keyword. * The instance is valid against this keyword if and only if it is valid against * at least one of the schemas in this keyword's value. * * The value of this keyword MUST be an array. This array MUST have at least one element. * Each element of this array MUST be an object, and each object MUST be a valid JSON Schema. * see http://json-schema.org/latest/json-schema-validation.html#anchor85 * * @name Schema.validationKeywords.anyOf * @method * @param {*} value Value to be validated. * @param {object} schema Schema containing the `anyOf` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ anyOf (value, schema, opts) { let validated = false let allErrors = [] schema.anyOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else { validated = true } }) return validated ? undefined : allErrors }, /** * http://json-schema.org/latest/json-schema-validation.html#anchor70 * * @name Schema.validationKeywords.dependencies * @method * @param {*} value TODO * @param {object} schema TODO * @param {object} opts TODO */ dependencies (value, schema, opts) { // TODO }, /** * Validates the provided value against an array of possible values defined by the Schema's `enum` keyword * Validation succeeds if the value is deeply equal to one of the values in the array. * see http://json-schema.org/latest/json-schema-validation.html#anchor76 * * @name Schema.validationKeywords.enum * @method * @param {*} value Value to validate * @param {object} schema Schema containing the `enum` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ enum (value, schema, opts) { const possibleValues = schema['enum'] if (utils.findIndex(possibleValues, (item) =&gt; utils.deepEqual(item, value)) === -1) { return makeError(value, `one of (${possibleValues.join(', ')})`, opts) } }, /** * Validates each of the provided array values against a schema or an array of schemas defined by the Schema's `items` keyword * see http://json-schema.org/latest/json-schema-validation.html#anchor37 for validation rules. * * @name Schema.validationKeywords.items * @method * @param {*} value Array to be validated. * @param {object} schema Schema containing the items keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ items (value, schema, opts) { opts || (opts = {}) // TODO: additionalItems let items = schema.items let errors = [] const checkingTuple = utils.isArray(items) const length = value.length for (var prop = 0; prop &lt; length; prop++) { if (checkingTuple) { // Validating a tuple, instead of just checking each item against the // same schema items = schema.items[prop] } opts.prop = prop errors = errors.concat(validate(value[prop], items, opts) || []) } return errors.length ? errors : undefined }, /** * Validates the provided number against a maximum value defined by the Schema's `maximum` keyword * Validation succeeds if the value is a number, and is less than, or equal to, the value of this keyword. * http://json-schema.org/latest/json-schema-validation.html#anchor17 * * @name Schema.validationKeywords.maximum * @method * @param {*} value Number to validate against the keyword. * @param {object} schema Schema containing the `maximum` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maximum (value, schema, opts) { // Must be a number const maximum = schema.maximum // Must be a boolean // Depends on maximum // default: false const exclusiveMaximum = schema.exclusiveMaximum if (typeof value === typeof maximum &amp;&amp; !(exclusiveMaximum ? maximum &gt; value : maximum &gt;= value)) { return exclusiveMaximum ? makeError(value, `no more than nor equal to ${maximum}`, opts) : makeError(value, `no more than ${maximum}`, opts) } }, /** * Validates the length of the provided array against a maximum value defined by the Schema's `maxItems` keyword. * Validation succeeds if the length of the array is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor42 * * @name Schema.validationKeywords.maxItems * @method * @param {*} value Array to be validated. * @param {object} schema Schema containing the `maxItems` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxItems (value, schema, opts) { if (utils.isArray(value)) { return maxLengthCommon('maxItems', value, schema, opts) } }, /** * Validates the length of the provided string against a maximum value defined in the Schema's `maxLength` keyword. * Validation succeeds if the length of the string is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor26 * * @name Schema.validationKeywords.maxLength * @method * @param {*} value String to be validated. * @param {object} schema Schema containing the `maxLength` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxLength (value, schema, opts) { return maxLengthCommon('maxLength', value, schema, opts) }, /** * Validates the count of the provided object's properties against a maximum value defined in the Schema's `maxProperties` keyword. * Validation succeeds if the object's property count is less than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor54 * * @name Schema.validationKeywords.maxProperties * @method * @param {*} value Object to be validated. * @param {object} schema Schema containing the `maxProperties` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ maxProperties (value, schema, opts) { // validate only objects if (!utils.isObject(value)) return const maxProperties = schema.maxProperties const length = Object.keys(value).length if (length &gt; maxProperties) { return makeError(length, `no more than ${maxProperties} properties`, opts) } }, /** * Validates the provided value against a minimum value defined by the Schema's `minimum` keyword * Validation succeeds if the value is a number and is greater than, or equal to, the value of this keyword. * http://json-schema.org/latest/json-schema-validation.html#anchor21 * * @name Schema.validationKeywords.minimum * @method * @param {*} value Number to validate against the keyword. * @param {object} schema Schema containing the `minimum` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minimum (value, schema, opts) { // Must be a number const minimum = schema.minimum // Must be a boolean // Depends on minimum // default: false const exclusiveMinimum = schema.exclusiveMinimum if (typeof value === typeof minimum &amp;&amp; !(exclusiveMinimum ? value &gt; minimum : value &gt;= minimum)) { return exclusiveMinimum ? makeError(value, `no less than nor equal to ${minimum}`, opts) : makeError(value, `no less than ${minimum}`, opts) } }, /** * Validates the length of the provided array against a minimum value defined by the Schema's `minItems` keyword. * Validation succeeds if the length of the array is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor45 * * @name Schema.validationKeywords.minItems * @method * @param {*} value Array to be validated. * @param {object} schema Schema containing the `minItems` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minItems (value, schema, opts) { if (utils.isArray(value)) { return minLengthCommon('minItems', value, schema, opts) } }, /** * Validates the length of the provided string against a minimum value defined in the Schema's `minLength` keyword. * Validation succeeds if the length of the string is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor29 * * @name Schema.validationKeywords.minLength * @method * @param {*} value String to be validated. * @param {object} schema Schema containing the `minLength` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minLength (value, schema, opts) { return minLengthCommon('minLength', value, schema, opts) }, /** * Validates the count of the provided object's properties against a minimum value defined in the Schema's `minProperties` keyword. * Validation succeeds if the object's property count is greater than, or equal to the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor57 * * @name Schema.validationKeywords.minProperties * @method * @param {*} value Object to be validated. * @param {object} schema Schema containing the `minProperties` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ minProperties (value, schema, opts) { // validate only objects if (!utils.isObject(value)) return const minProperties = schema.minProperties const length = Object.keys(value).length if (length &lt; minProperties) { return makeError(length, `no more than ${minProperties} properties`, opts) } }, /** * Validates the provided number is a multiple of the number defined in the Schema's `multipleOf` keyword. * Validation succeeds if the number can be divided equally into the value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor14 * * @name Schema.validationKeywords.multipleOf * @method * @param {*} value Number to be validated. * @param {object} schema Schema containing the `multipleOf` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ multipleOf (value, schema, opts) { const multipleOf = schema.multipleOf if (utils.isNumber(value)) { if ((value / multipleOf) % 1 !== 0) { return makeError(value, `multipleOf ${multipleOf}`, opts) } } }, /** * Validates the provided value is not valid with any of the schemas defined in the Schema's `not` keyword. * An instance is valid against this keyword if and only if it is NOT valid against the schemas in this keyword's value. * * see http://json-schema.org/latest/json-schema-validation.html#anchor91 * @name Schema.validationKeywords.not * @method * @param {*} value to be checked. * @param {object} schema Schema containing the not keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ not (value, schema, opts) { if (!validate(value, schema.not, opts)) { // TODO: better messaging return makeError('succeeded', 'should have failed', opts) } }, /** * Validates the provided value is valid with one and only one of the schemas defined in the Schema's `oneOf` keyword. * An instance is valid against this keyword if and only if it is valid against a single schemas in this keyword's value. * * see http://json-schema.org/latest/json-schema-validation.html#anchor88 * @name Schema.validationKeywords.oneOf * @method * @param {*} value to be checked. * @param {object} schema Schema containing the `oneOf` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ oneOf (value, schema, opts) { let validated = false let allErrors = [] schema.oneOf.forEach(function (_schema) { const errors = validate(value, _schema, opts) if (errors) { allErrors = allErrors.concat(errors) } else if (validated) { allErrors = [makeError('valid against more than one', 'valid against only one', opts)] validated = false return false } else { validated = true } }) return validated ? undefined : allErrors }, /** * Validates the provided string matches a pattern defined in the Schema's `pattern` keyword. * Validation succeeds if the string is a match of the regex value of this keyword. * * see http://json-schema.org/latest/json-schema-validation.html#anchor33 * @name Schema.validationKeywords.pattern * @method * @param {*} value String to be validated. * @param {object} schema Schema containing the `pattern` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ pattern (value, schema, opts) { const pattern = schema.pattern if (utils.isString(value) &amp;&amp; !value.match(pattern)) { return makeError(value, pattern, opts) } }, /** * Validates the provided object's properties against a map of values defined in the Schema's `properties` keyword. * Validation succeeds if the object's property are valid with each of the schema's in the provided map. * Validation also depends on the additionalProperties and or patternProperties. * * see http://json-schema.org/latest/json-schema-validation.html#anchor64 for more info. * * @name Schema.validationKeywords.properties * @method * @param {*} value Object to be validated. * @param {object} schema Schema containing the `properties` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ properties (value, schema, opts) { opts || (opts = {}) if (utils.isArray(value)) { return } // Can be a boolean or an object // Technically the default is an \"empty schema\", but here \"true\" is // functionally the same const additionalProperties = schema.additionalProperties === undefined ? true : schema.additionalProperties const validated = [] // \"p\": The property set from \"properties\". // Default is an object const properties = schema.properties || {} // \"pp\": The property set from \"patternProperties\". // Default is an object const patternProperties = schema.patternProperties || {} let errors = [] utils.forOwn(properties, function (_schema, prop) { opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) validated.push(prop) }) const toValidate = utils.omit(value, validated) utils.forOwn(patternProperties, function (_schema, pattern) { utils.forOwn(toValidate, function (undef, prop) { if (prop.match(pattern)) { opts.prop = prop errors = errors.concat(validate(value[prop], _schema, opts) || []) validated.push(prop) } }) }) const keys = Object.keys(utils.omit(value, validated)) // If \"s\" is not empty, validation fails if (additionalProperties === false) { if (keys.length) { const origProp = opts.prop opts.prop = '' addError(`extra fields: ${keys.join(', ')}`, 'no extra fields', opts, errors) opts.prop = origProp } } else if (utils.isObject(additionalProperties)) { // Otherwise, validate according to provided schema keys.forEach(function (prop) { opts.prop = prop errors = errors.concat(validate(value[prop], additionalProperties, opts) || []) }) } return errors.length ? errors : undefined }, /** * Validates the provided object's has all properties listed in the Schema's `properties` keyword array. * Validation succeeds if the object contains all properties provided in the array value of this keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor61 * * @name Schema.validationKeywords.required * @method * @param {*} value Object to be validated. * @param {object} schema Schema containing the `required` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ required (value, schema, opts) { opts || (opts = {}) const required = schema.required let errors = [] if (!opts.existingOnly) { required.forEach(function (prop) { if (utils.get(value, prop) === undefined) { const prevProp = opts.prop opts.prop = prop addError(undefined, 'a value', opts, errors) opts.prop = prevProp } }) } return errors.length ? errors : undefined }, /** * Validates the provided value's type is equal to the type, or array of types, defined in the Schema's `type` keyword. * see http://json-schema.org/latest/json-schema-validation.html#anchor79 * * @name Schema.validationKeywords.type * @method * @param {*} value Value to be validated. * @param {object} schema Schema containing the `type` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ type (value, schema, opts) { let type = schema.type let validType // Can be one of several types if (utils.isString(type)) { type = [type] } // Try to match the value against an expected type type.forEach(function (_type) { // TODO: throw an error if type is not defined if (types[_type](value, schema, opts)) { // Matched a type validType = _type return false } }) // Value did not match any expected type if (!validType) { return makeError(value !== undefined &amp;&amp; value !== null ? typeof value : '' + value, `one of (${type.join(', ')})`, opts) } // Run keyword validators for matched type // http://json-schema.org/latest/json-schema-validation.html#anchor12 const validator = typeGroupValidators[validType] if (validator) { return validator(value, schema, opts) } }, /** * Validates the provided array values are unique. * Validation succeeds if the items in the array are unique, but only if the value of this keyword is true * see http://json-schema.org/latest/json-schema-validation.html#anchor49 * * @name Schema.validationKeywords.uniqueItems * @method * @param {*} value Array to be validated. * @param {object} schema Schema containing the `uniqueItems` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ uniqueItems (value, schema, opts) { if (value &amp;&amp; value.length &amp;&amp; schema.uniqueItems) { const length = value.length let item, i, j // Check n - 1 items for (i = length - 1; i &gt; 0; i--) { item = value[i] // Only compare against unchecked items for (j = i - 1; j &gt;= 0; j--) { // Found a duplicate if (utils.deepEqual(item, value[j])) { return makeError(item, 'no duplicates', opts) } } } } } } /** * @ignore */ const runOps = function (ops, value, schema, opts) { let errors = [] ops.forEach(function (op) { if (schema[op] !== undefined) { errors = errors.concat(validationKeywords[op](value, schema, opts) || []) } }) return errors.length ? errors : undefined } /** * Validation keywords validated for any type: * * - `enum` * - `type` * - `allOf` * - `anyOf` * - `oneOf` * - `not` * * @name Schema.ANY_OPS * @type {string[]} */ const ANY_OPS = ['enum', 'type', 'allOf', 'anyOf', 'oneOf', 'not'] /** * Validation keywords validated for array types: * * - `items` * - `maxItems` * - `minItems` * - `uniqueItems` * * @name Schema.ARRAY_OPS * @type {string[]} */ const ARRAY_OPS = ['items', 'maxItems', 'minItems', 'uniqueItems'] /** * Validation keywords validated for numeric (number and integer) types: * * - `multipleOf` * - `maximum` * - `minimum` * * @name Schema.NUMERIC_OPS * @type {string[]} */ const NUMERIC_OPS = ['multipleOf', 'maximum', 'minimum'] /** * Validation keywords validated for object types: * * - `maxProperties` * - `minProperties` * - `required` * - `properties` * - `dependencies` * * @name Schema.OBJECT_OPS * @type {string[]} */ const OBJECT_OPS = ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] /** * Validation keywords validated for string types: * * - `maxLength` * - `minLength` * - `pattern` * * @name Schema.STRING_OPS * @type {string[]} */ const STRING_OPS = ['maxLength', 'minLength', 'pattern'] /** * http://json-schema.org/latest/json-schema-validation.html#anchor75 * @ignore */ const validateAny = function (value, schema, opts) { return runOps(ANY_OPS, value, schema, opts) } /** * Validates the provided value against a given Schema according to the http://json-schema.org/ v4 specification. * * @name Schema.validate * @method * @param {*} value Value to be validated. * @param {object} schema Valid Schema according to the http://json-schema.org/ v4 specification. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ const validate = function (value, schema, opts) { let errors = [] opts || (opts = {}) opts.ctx || (opts.ctx = { value, schema }) let shouldPop let prevProp = opts.prop if (schema === undefined) { return } if (!utils.isObject(schema)) { throw utils.err(`${DOMAIN}#validate`)(500, `Invalid schema at path: \"${opts.path}\"`) } if (opts.path === undefined) { opts.path = [] } // Track our location as we recurse if (opts.prop !== undefined) { shouldPop = true opts.path.push(opts.prop) opts.prop = undefined } // Validate against parent schema if (schema['extends']) { // opts.path = path // opts.prop = prop if (utils.isFunction(schema['extends'].validate)) { errors = errors.concat(schema['extends'].validate(value, opts) || []) } else { errors = errors.concat(validate(value, schema['extends'], opts) || []) } } if (value === undefined) { // Check if property is required if (schema.required === true &amp;&amp; !opts.existingOnly) { addError(value, 'a value', opts, errors) } if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } errors = errors.concat(validateAny(value, schema, opts) || []) if (shouldPop) { opts.path.pop() opts.prop = prevProp } return errors.length ? errors : undefined } // These strings are cached for optimal performance of the change detection // boolean - Whether a Record is changing in the current execution frame const changingPath = 'changing' // string[] - Properties that have changed in the current execution frame const changedPath = 'changed' // Object[] - History of change records const changeHistoryPath = 'history' // boolean - Whether a Record is currently being instantiated const creatingPath = 'creating' // number - The setTimeout change event id of a Record, if any const eventIdPath = 'eventId' // boolean - Whether to skip validation for a Record's currently changing property const noValidatePath = 'noValidate' // boolean - Whether to preserve Change History for a Record const keepChangeHistoryPath = 'keepChangeHistory' // boolean - Whether to skip change notification for a Record's currently // changing property const silentPath = 'silent' const validationFailureMsg = 'validation failed' /** * A map of validation functions grouped by type. * * @name Schema.typeGroupValidators * @type {object} */ const typeGroupValidators = { /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an array. * The validation keywords for the type `array` are: *``` * ['items', 'maxItems', 'minItems', 'uniqueItems'] *``` * see http://json-schema.org/latest/json-schema-validation.html#anchor25 * * @name Schema.typeGroupValidators.array * @method * @param {*} value Array to be validated. * @param {object} schema Schema containing at least one array keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ array: function (value, schema, opts) { return runOps(ARRAY_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an integer. * The validation keywords for the type `integer` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * @name Schema.typeGroupValidators.integer * @method * @param {*} value Number to be validated. * @param {object} schema Schema containing at least one `integer` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ integer: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an number. * The validation keywords for the type `number` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * @name Schema.typeGroupValidators.number * @method * @param {*} value Number to be validated. * @param {object} schema Schema containing at least one `number` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ number: function (value, schema, opts) { // Additional validations for numerics are the same return typeGroupValidators.numeric(value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of a number or integer. * The validation keywords for the type `numeric` are: *``` * ['multipleOf', 'maximum', 'minimum'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor13. * * @name Schema.typeGroupValidators.numeric * @method * @param {*} value Number to be validated. * @param {object} schema Schema containing at least one `numeric` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ numeric: function (value, schema, opts) { return runOps(NUMERIC_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an object. * The validation keywords for the type `object` are: *``` * ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor53. * * @name Schema.typeGroupValidators.object * @method * @param {*} value Object to be validated. * @param {object} schema Schema containing at least one `object` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ object: function (value, schema, opts) { return runOps(OBJECT_OPS, value, schema, opts) }, /** * Validates the provided value against the schema using all of the validation keywords specific to instances of an string. * The validation keywords for the type `string` are: *``` * ['maxLength', 'minLength', 'pattern'] *``` * See http://json-schema.org/latest/json-schema-validation.html#anchor25. * * @name Schema.typeGroupValidators.string * @method * @param {*} value String to be validated. * @param {object} schema Schema containing at least one `string` keyword. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ string: function (value, schema, opts) { return runOps(STRING_OPS, value, schema, opts) } } /** * js-data's Schema class. * * @example &lt;caption&gt;Schema#constructor&lt;/caption&gt; * const JSData = require('js-data'); * const { Schema } = JSData; * console.log('Using JSData v' + JSData.version.full); * * const PostSchema = new Schema({ * type: 'object', * properties: { * title: { type: 'string' } * } * }); * PostSchema.validate({ title: 1234 }); * * @class Schema * @extends Component * @param {object} definition Schema definition according to json-schema.org */ function Schema (definition) { definition || (definition = {}) // TODO: schema validation utils.fillIn(this, definition) if (this.type === 'object') { this.properties = this.properties || {} utils.forOwn(this.properties, (_definition, prop) =&gt; { if (!(_definition instanceof Schema)) { this.properties[prop] = new Schema(_definition) } }) } else if (this.type === 'array' &amp;&amp; this.items &amp;&amp; !(this.items instanceof Schema)) { this.items = new Schema(this.items) } if (this.extends &amp;&amp; !(this.extends instanceof Schema)) { this.extends = new Schema(this.extends) } ['allOf', 'anyOf', 'oneOf'].forEach((validationKeyword) =&gt; { if (this[validationKeyword]) { this[validationKeyword].forEach((_definition, i) =&gt; { if (!(_definition instanceof Schema)) { this[validationKeyword][i] = new Schema(_definition) } }) } }) } export default Component.extend({ constructor: Schema, /** * This adds ES5 getters/setters to the target based on the \"properties\" in * this Schema, which makes possible change tracking and validation on * property assignment. * * @name Schema#apply * @method * @param {object} target The prototype to which to apply this schema. */ apply (target, opts) { opts || (opts = {}) opts.getter || (opts.getter = '_get') opts.setter || (opts.setter = '_set') opts.unsetter || (opts.unsetter = '_unset') opts.track || (opts.track = this.track) const properties = this.properties || {} utils.forOwn(properties, (schema, prop) =&gt; { Object.defineProperty( target, prop, this.makeDescriptor(prop, schema, opts) ) }) }, /** * Apply default values to the target object for missing values. * * @name Schema#applyDefaults * @method * @param {object} target The target to which to apply values for missing values. */ applyDefaults (target) { if (!target) { return } const properties = this.properties || {} const hasSet = utils.isFunction(target.set) || utils.isFunction(target._set) utils.forOwn(properties, function (schema, prop) { if (schema.hasOwnProperty('default') &amp;&amp; utils.get(target, prop) === undefined) { if (hasSet) { target.set(prop, utils.plainCopy(schema['default']), { silent: true }) } else { utils.set(target, prop, utils.plainCopy(schema['default'])) } } if (schema.type === 'object' &amp;&amp; schema.properties) { if (hasSet) { const orig = target._get('noValidate') target._set('noValidate', true) utils.set(target, prop, utils.get(target, prop) || {}, { silent: true }) target._set('noValidate', orig) } else { utils.set(target, prop, utils.get(target, prop) || {}) } schema.applyDefaults(utils.get(target, prop)) } }) }, /** * Assemble a property descriptor for tracking and validating changes to * a property according to the given schema. This method is called when * {@link Mapper#applySchema} is set to `true`. * * @name Schema#makeDescriptor * @method * @param {string} prop The property name. * @param {(Schema|object)} schema The schema for the property. * @param {object} [opts] Optional configuration. * @param {function} [opts.getter] Custom getter function. * @param {function} [opts.setter] Custom setter function. * @param {function} [opts.track] Whether to track changes. * @returns {object} A property descriptor for the given schema. */ makeDescriptor (prop, schema, opts) { const descriptor = { // Better to allow configurability, but at the user's own risk configurable: true, // These properties are enumerable by default, but regardless of their // enumerability, they won't be \"own\" properties of individual records enumerable: schema.enumerable === undefined ? true : !!schema.enumerable } // Cache a few strings for optimal performance const keyPath = `props.${prop}` const previousPath = `previous.${prop}` const getter = opts.getter const setter = opts.setter const unsetter = opts.unsetter const track = utils.isBoolean(opts.track) ? opts.track : schema.track descriptor.get = function () { return this._get(keyPath) } if (utils.isFunction(schema.get)) { const originalGet = descriptor.get descriptor.get = function () { return schema.get.call(this, originalGet) } } descriptor.set = function (value) { // These are accessed a lot const _get = this[getter] const _set = this[setter] const _unset = this[unsetter] // Optionally check that the new value passes validation if (!_get(noValidatePath)) { const errors = schema.validate(value, { path: [prop] }) if (errors) { // Immediately throw an error, preventing the record from getting into // an invalid state const error = new Error(validationFailureMsg) error.errors = errors throw error } } // TODO: Make it so tracking can be turned on for all properties instead of // only per-property if (track &amp;&amp; !_get(creatingPath)) { // previous is versioned on database commit // props are versioned on set() const previous = _get(previousPath) const current = _get(keyPath) let changing = _get(changingPath) let changed = _get(changedPath) if (!changing) { // Track properties that are changing in the current event loop changed = [] } // Add changing properties to this array once at most const index = changed.indexOf(prop) if (current !== value &amp;&amp; index === -1) { changed.push(prop) } if (previous === value) { if (index &gt;= 0) { changed.splice(index, 1) } } // No changes in current event loop if (!changed.length) { changing = false _unset(changingPath) _unset(changedPath) // Cancel pending change event if (_get(eventIdPath)) { clearTimeout(_get(eventIdPath)) _unset(eventIdPath) } } // Changes detected in current event loop if (!changing &amp;&amp; changed.length) { _set(changedPath, changed) _set(changingPath, true) // Saving the timeout id allows us to batch all changes in the same // event loop into a single \"change\" // TODO: Optimize _set(eventIdPath, setTimeout(() =&gt; { // Previous event loop where changes were gathered has ended, so // notify any listeners of those changes and prepare for any new // changes _unset(changedPath) _unset(eventIdPath) _unset(changingPath) // TODO: Optimize if (!_get(silentPath)) { let i for (i = 0; i &lt; changed.length; i++) { this.emit('change:' + changed[i], this, utils.get(this, changed[i])) } const changes = utils.diffObjects({ [prop]: value }, { [prop]: current }) if (_get(keepChangeHistoryPath)) { const changeRecord = utils.plainCopy(changes) changeRecord.timestamp = new Date().getTime() let changeHistory = _get(changeHistoryPath) !changeHistory &amp;&amp; _set(changeHistoryPath, (changeHistory = [])) changeHistory.push(changeRecord) } this.emit('change', this, changes) } _unset(silentPath) }, 0)) } } _set(keyPath, value) return value } if (utils.isFunction(schema.set)) { const originalSet = descriptor.set descriptor.set = function (value) { return schema.set.call(this, value, originalSet) } } return descriptor }, /** * Create a copy of the given value that contains only the properties defined * in this schema. * * @name Schema#pick * @method * @param {*} value The value to copy. * @returns {*} The copy. */ pick (value) { if (value === undefined) { return } if (this.type === 'object') { let copy = {} const properties = this.properties if (properties) { utils.forOwn(properties, (_definition, prop) =&gt; { copy[prop] = _definition.pick(value[prop]) }) } if (this.extends) { utils.fillIn(copy, this.extends.pick(value)) } // Conditionally copy properties not defined in \"properties\" if (this.additionalProperties) { for (var key in value) { if (!properties[key]) { copy[key] = utils.plainCopy(value[key]) } } } return copy } else if (this.type === 'array') { return value.map((item) =&gt; { const _copy = this.items ? this.items.pick(item) : {} if (this.extends) { utils.fillIn(_copy, this.extends.pick(item)) } return _copy }) } return utils.plainCopy(value) }, /** * Validate the provided value against this schema. * * @name Schema#validate * @method * @param {*} value Value to validate. * @param {object} [opts] Configuration options. * @returns {(array|undefined)} Array of errors or `undefined` if valid. */ validate (value, opts) { return validate(value, this, opts) } }, { ANY_OPS, ARRAY_OPS, NUMERIC_OPS, OBJECT_OPS, STRING_OPS, typeGroupValidators, types, validate, validationKeywords }) /** * Create a subclass of this Schema: * @example &lt;caption&gt;Schema.extend&lt;/caption&gt; * const JSData = require('js-data'); * const { Schema } = JSData; * console.log('Using JSData v' + JSData.version.full); * * // Extend the class using ES2015 class syntax. * class CustomSchemaClass extends Schema { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customSchema = new CustomSchemaClass(); * console.log(customSchema.foo()); * console.log(CustomSchemaClass.beep()); * * // Extend the class using alternate method. * const OtherSchemaClass = Schema.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const otherSchema = new OtherSchemaClass(); * console.log(otherSchema.foo()); * console.log(OtherSchemaClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherSchemaClass () { * Schema.call(this); * this.created_at = new Date().getTime(); * } * Schema.extend({ * constructor: AnotherSchemaClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }); * const anotherSchema = new AnotherSchemaClass(); * console.log(anotherSchema.created_at); * console.log(anotherSchema.foo()); * console.log(AnotherSchemaClass.beep()); * * @method Schema.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Schema class. * @since 3.0.0 */ × Search results Close api.js-data.io • js-data.io "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Source: utils.js /** * Utility methods used by JSData. * * @example * import { utils } from 'js-data'; * console.log(utils.isString('foo')); // true * * @namespace utils * @type {Object} */ const DOMAIN = 'utils' const INFINITY = 1 / 0 const MAX_INTEGER = 1.7976931348623157e308 const BOOL_TAG = '[object Boolean]' const DATE_TAG = '[object Date]' const FUNC_TAG = '[object Function]' const NUMBER_TAG = '[object Number]' const OBJECT_TAG = '[object Object]' const REGEXP_TAG = '[object RegExp]' const STRING_TAG = '[object String]' const objToString = Object.prototype.toString const PATH = /^(.+)\\.(.+)$/ const ERRORS = { '400' () { return `expected: ${arguments[0]}, found: ${ arguments[2] ? arguments[1] : typeof arguments[1] }` }, '404' () { return `${arguments[0]} not found` } } const toInteger = function (value) { if (!value) { return 0 } // Coerce to number value = +value if (value === INFINITY || value === -INFINITY) { const sign = value &lt; 0 ? -1 : 1 return sign * MAX_INTEGER } const remainder = value % 1 return value === value ? (remainder ? value - remainder : value) : 0 // eslint-disable-line } const toStr = function (value) { return objToString.call(value) } const isPlainObject = function (value) { return !!value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === Object } const mkdirP = function (object, path) { if (!path) { return object } const parts = path.split('.') parts.forEach(function (key) { if (!object[key]) { object[key] = {} } object = object[key] }) return object } const utils = { /** * Reference to the Promise constructor used by JSData. Defaults to * `window.Promise` or `global.Promise`. * * @example &lt;caption&gt;Make JSData use a different `Promise` constructor&lt;/caption&gt; * import Promise from 'bluebird'; * import { utils } from 'js-data'; * utils.Promise = Promise; * * @name utils.Promise * @since 3.0.0 * @type {Function} */ Promise: Promise, /** * Shallow copy properties that meet the following criteria from `src` to * `dest`: * * - own enumerable * - not a function * - does not start with \"_\" * * @method utils._ * @param {object} dest Destination object. * @param {object} src Source object. * @private * @since 3.0.0 */ _ (dest, src) { utils.forOwn(src, function (value, key) { if ( key &amp;&amp; dest[key] === undefined &amp;&amp; !utils.isFunction(value) &amp;&amp; key.indexOf('_') !== 0 ) { dest[key] = value } }) }, /** * Recursively iterates over relations found in `opts.with`. * * @method utils._forRelation * @param {object} opts Configuration options. * @param {Relation} def Relation definition. * @param {Function} fn Callback function. * @param {*} [thisArg] Execution context for the callback function. * @private * @since 3.0.0 */ _forRelation (opts, def, fn, thisArg) { const relationName = def.relation let containedName = null let index opts || (opts = {}) opts.with || (opts.with = []) if ((index = utils._getIndex(opts.with, relationName)) &gt;= 0) { containedName = relationName } else if ((index = utils._getIndex(opts.with, def.localField)) &gt;= 0) { containedName = def.localField } if (opts.withAll) { fn.call(thisArg, def, {}) return } else if (!containedName) { return } let optsCopy = {} utils.fillIn(optsCopy, def.getRelation()) utils.fillIn(optsCopy, opts) optsCopy.with = opts.with.slice() optsCopy._activeWith = optsCopy.with.splice(index, 1)[0] optsCopy.with.forEach(function (relation, i) { if ( relation &amp;&amp; relation.indexOf(containedName) === 0 &amp;&amp; relation.length &gt;= containedName.length &amp;&amp; relation[containedName.length] === '.' ) { optsCopy.with[i] = relation.substr(containedName.length + 1) } else { optsCopy.with[i] = '' } }) fn.call(thisArg, def, optsCopy) }, /** * Find the index of a relation in the given list * * @method utils._getIndex * @param {string[]} list List to search. * @param {string} relation Relation to find. * @private * @returns {number} */ _getIndex (list, relation) { let index = -1 list.forEach(function (_relation, i) { if (_relation === relation) { index = i return false } else if (utils.isObject(_relation)) { if (_relation.relation === relation) { index = i return false } } }) return index }, /** * Define hidden (non-enumerable), writable properties on `target` from the * provided `props`. * * @example * import { utils } from 'js-data'; * function Cat () {} * utils.addHiddenPropsToTarget(Cat.prototype, { * say () { * console.log('meow'); * } * }); * const cat = new Cat(); * cat.say(); // \"meow\" * * @method utils.addHiddenPropsToTarget * @param {object} target That to which `props` should be added. * @param {object} props Properties to be added to `target`. * @since 3.0.0 */ addHiddenPropsToTarget (target, props) { const map = {} Object.keys(props).forEach(function (propName) { const descriptor = Object.getOwnPropertyDescriptor(props, propName) descriptor.enumerable = false map[propName] = descriptor }) Object.defineProperties(target, map) }, /** * Return whether the two objects are deeply different. * * @example * import { utils } from 'js-data'; * utils.areDifferent({}, {}); // false * utils.areDifferent({ a: 1 }, { a: 1 }); // false * utils.areDifferent({ foo: 'bar' }, {}); // true * * @method utils.areDifferent * @param {object} a Base object. * @param {object} b Comparison object. * @param {object} [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {boolean} Whether the two objects are deeply different. * @see utils.diffObjects * @since 3.0.0 */ areDifferent (newObject, oldObject, opts) { opts || (opts = {}) const diff = utils.diffObjects(newObject, oldObject, opts) const diffCount = Object.keys(diff.added).length + Object.keys(diff.removed).length + Object.keys(diff.changed).length return diffCount &gt; 0 }, /** * Verified that the given constructor is being invoked via `new`, as opposed * to just being called like a normal function. * * @example * import { utils } from 'js-data'; * function Cat () { * utils.classCallCheck(this, Cat); * } * const cat = new Cat(); // this is ok * Cat(); // this throws an error * * @method utils.classCallCheck * @param {*} instance Instance that is being constructed. * @param {Constructor} ctor Constructor function used to construct the * instance. * @since 3.0.0 * @throws {Error} Throws an error if the constructor is being improperly * invoked. */ classCallCheck (instance, ctor) { if (!(instance instanceof ctor)) { throw utils.err(`${ctor.name}`)(500, 'Cannot call a class as a function') } }, /** * Deep copy a value. * * @example * import { utils } from 'js-data'; * const a = { foo: { bar: 'baz' } }; * const b = utils.copy(a); * a === b; // false * utils.areDifferent(a, b); // false * * @param {*} from Value to deep copy. * @param {*} [to] Destination object for the copy operation. * @param {*} [stackFrom] For internal use. * @param {*} [stackTo] For internal use. * @param {string[]|RegExp[]} [blacklist] List of strings or RegExp of * properties to skip. * @param {boolean} [plain] Whether to make a plain copy (don't try to use * original prototype). * @returns {*} Deep copy of `from`. * @since 3.0.0 */ copy (from, to, stackFrom, stackTo, blacklist, plain) { if (!to) { to = from if (from) { if (utils.isArray(from)) { to = utils.copy(from, [], stackFrom, stackTo, blacklist, plain) } else if (utils.isDate(from)) { to = new Date(from.getTime()) } else if (utils.isRegExp(from)) { to = new RegExp(from.source, from.toString().match(/[^/]*$/)[0]) to.lastIndex = from.lastIndex } else if (utils.isObject(from)) { if (plain) { to = utils.copy(from, {}, stackFrom, stackTo, blacklist, plain) } else { to = utils.copy( from, Object.create(Object.getPrototypeOf(from)), stackFrom, stackTo, blacklist, plain ) } } } } else { if (from === to) { throw utils.err(`${DOMAIN}.copy`)( 500, 'Cannot copy! Source and destination are identical.' ) } stackFrom = stackFrom || [] stackTo = stackTo || [] if (utils.isObject(from)) { let index = stackFrom.indexOf(from) if (index !== -1) { return stackTo[index] } stackFrom.push(from) stackTo.push(to) } let result if (utils.isArray(from)) { let i to.length = 0 for (i = 0; i &lt; from.length; i++) { result = utils.copy( from[i], null, stackFrom, stackTo, blacklist, plain ) if (utils.isObject(from[i])) { stackFrom.push(from[i]) stackTo.push(result) } to.push(result) } } else { if (utils.isArray(to)) { to.length = 0 } else { utils.forOwn(to, function (value, key) { delete to[key] }) } for (var key in from) { if (from.hasOwnProperty(key)) { if (utils.isBlacklisted(key, blacklist)) { continue } result = utils.copy( from[key], null, stackFrom, stackTo, blacklist, plain ) if (utils.isObject(from[key])) { stackFrom.push(from[key]) stackTo.push(result) } to[key] = result } } } } return to }, /** * Recursively shallow fill in own enumerable properties from `source` to * `dest`. * * @example * import { utils } from 'js-data'; * const a = { foo: { bar: 'baz' }, beep: 'boop' }; * const b = { beep: 'bip' }; * utils.deepFillIn(b, a); * console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"bip\"} * * @method utils.deepFillIn * @param {object} dest The destination object. * @param {object} source The source object. * @see utils.fillIn * @see utils.deepMixIn * @since 3.0.0 */ deepFillIn (dest, source) { if (source) { utils.forOwn(source, function (value, key) { const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepFillIn(existing, value) } else if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) } return dest }, /** * Recursively shallow copy enumerable properties from `source` to `dest`. * * @example * import { utils } from 'js-data'; * const a = { foo: { bar: 'baz' }, beep: 'boop' }; * const b = { beep: 'bip' }; * utils.deepFillIn(b, a); * console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"boop\"} * * @method utils.deepMixIn * @param {object} dest The destination object. * @param {object} source The source object. * @see utils.fillIn * @see utils.deepFillIn * @since 3.0.0 */ deepMixIn (dest, source) { if (source) { for (var key in source) { const value = source[key] const existing = dest[key] if (isPlainObject(value) &amp;&amp; isPlainObject(existing)) { utils.deepMixIn(existing, value) } else { dest[key] = value } } } return dest }, /** * Return a diff of the base object to the comparison object. * * @example * import { utils } from 'js-data'; * const oldObject = { foo: 'bar', a: 1234 }; * const newObject = { beep: 'boop', a: 5678 }; * const diff = utils.diffObjects(oldObject, newObject); * console.log(diff.added); // {\"beep\":\"boop\"} * console.log(diff.changed); // {\"a\":5678} * console.log(diff.removed); // {\"foo\":undefined} * * @method utils.diffObjects * @param {object} newObject Comparison object. * @param {object} oldObject Base object. * @param {object} [opts] Configuration options. * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function. * @param {array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore. * @returns {Object} The diff from the base object to the comparison object. * @see utils.areDifferent * @since 3.0.0 */ diffObjects (newObject, oldObject, opts) { opts || (opts = {}) let equalsFn = opts.equalsFn let blacklist = opts.ignore const diff = { added: {}, changed: {}, removed: {} } if (!utils.isFunction(equalsFn)) { equalsFn = utils.deepEqual } const newKeys = Object.keys(newObject).filter(function (key) { return !utils.isBlacklisted(key, blacklist) }) const oldKeys = Object.keys(oldObject).filter(function (key) { return !utils.isBlacklisted(key, blacklist) }) // Check for properties that were added or changed newKeys.forEach(function (key) { const oldValue = oldObject[key] const newValue = newObject[key] if (equalsFn(oldValue, newValue)) { return } if (oldValue === undefined) { diff.added[key] = newValue } else { diff.changed[key] = newValue } }) // Check for properties that were removed oldKeys.forEach(function (key) { const oldValue = oldObject[key] const newValue = newObject[key] if (newValue === undefined &amp;&amp; oldValue !== undefined) { diff.removed[key] = undefined } }) return diff }, /** * Return whether the two values are equal according to the `==` operator. * * @example * import { utils } from 'js-data'; * console.log(utils.equal(1,1)); // true * console.log(utils.equal(1,'1')); // true * console.log(utils.equal(93, 66)); // false * * @method utils.equal * @param {*} a First value in the comparison. * @param {*} b Second value in the comparison. * @returns {boolean} Whether the two values are equal according to `==`. * @since 3.0.0 */ equal (a, b) { return a == b // eslint-disable-line }, /** * Produce a factory function for making Error objects with the provided * metadata. Used throughout the various js-data components. * * @example * import { utils } from 'js-data'; * const errorFactory = utils.err('domain', 'target'); * const error400 = errorFactory(400, 'expected type', 'actual type'); * console.log(error400); // [Error: [domain:target] expected: expected type, found: string http://www.js-data.io/v3.0/docs/errors#400] * @method utils.err * @param {string} domain Namespace. * @param {string} target Target. * @returns {Function} Factory function. * @since 3.0.0 */ err (domain, target) { return function (code) { const prefix = `[${domain}:${target}] ` let message = ERRORS[code].apply( null, Array.prototype.slice.call(arguments, 1) ) message = `${prefix}${message} http://www.js-data.io/v3.0/docs/errors#${code}` return new Error(message) } }, /** * Add eventing capabilities into the target object. * * @example * import { utils } from 'js-data'; * const user = { name: 'John' }; * utils.eventify(user); * user.on('foo', () =&gt; console.log(arguments)); * user.emit('foo', 1, 'bar'); // should log to console values (1, \"bar\") * * @method utils.eventify * @param {object} target Target object. * @param {Function} [getter] Custom getter for retrieving the object's event * listeners. * @param {Function} [setter] Custom setter for setting the object's event * listeners. * @since 3.0.0 */ eventify (target, getter, setter) { target = target || this let _events = {} if (!getter &amp;&amp; !setter) { getter = function () { return _events } setter = function (value) { _events = value } } Object.defineProperties(target, { emit: { value (...args) { const events = getter.call(this) || {} const type = args.shift() let listeners = events[type] || [] let i for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } listeners = events.all || [] args.unshift(type) for (i = 0; i &lt; listeners.length; i++) { listeners[i].f.apply(listeners[i].c, args) } } }, off: { value (type, func) { const events = getter.call(this) const listeners = events[type] if (!listeners) { setter.call(this, {}) } else if (func) { for (let i = 0; i &lt; listeners.length; i++) { if (listeners[i].f === func) { listeners.splice(i, 1) break } } } else { listeners.splice(0, listeners.length) } } }, on: { value (type, func, thisArg) { if (!getter.call(this)) { setter.call(this, {}) } const events = getter.call(this) events[type] = events[type] || [] events[type].push({ c: thisArg, f: func }) } } }) }, /** * Used for sublcassing. Invoke this method in the context of a superclass to * to produce a subclass based on `props` and `classProps`. * * @example * import { utils } from 'js-data'; * function Animal () {} * Animal.extend = utils.extend; * const Cat = Animal.extend({ * say () { * console.log('meow'); * } * }); * const cat = new Cat(); * cat instanceof Animal; // true * cat instanceof Cat; // true * cat.say(); // \"meow\" * * @method utils.extend * @param {object} props Instance properties for the subclass. * @param {object} [props.constructor] Provide a custom constructor function * to use as the subclass. * @param {object} props Static properties for the subclass. * @returns {Constructor} A new subclass. * @since 3.0.0 */ extend (props, classProps) { const superClass = this let subClass props || (props = {}) classProps || (classProps = {}) if (props.hasOwnProperty('constructor')) { subClass = props.constructor delete props.constructor } else { subClass = function (...args) { utils.classCallCheck(this, subClass) superClass.apply(this, args) } } // Setup inheritance of instance members subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { configurable: true, enumerable: false, value: subClass, writable: true } }) const obj = Object // Setup inheritance of static members if (obj.setPrototypeOf) { obj.setPrototypeOf(subClass, superClass) } else if (classProps.strictEs6Class) { subClass.__proto__ = superClass // eslint-disable-line } else { utils.forOwn(superClass, function (value, key) { subClass[key] = value }) } if (!subClass.hasOwnProperty('__super__')) { Object.defineProperty(subClass, '__super__', { configurable: true, value: superClass }) } utils.addHiddenPropsToTarget(subClass.prototype, props) utils.fillIn(subClass, classProps) return subClass }, /** * Shallow copy own enumerable properties from `src` to `dest` that are on * `src` but are missing from `dest. * * @example * import { utils } from 'js-data'; * const a = { foo: 'bar', beep: 'boop' }; * const b = { beep: 'bip' }; * utils.fillIn(b, a); * console.log(b); // {\"foo\":\"bar\",\"beep\":\"bip\"} * * @method utils.fillIn * @param {object} dest The destination object. * @param {object} source The source object. * @see utils.deepFillIn * @see utils.deepMixIn * @since 3.0.0 */ fillIn (dest, src) { utils.forOwn(src, function (value, key) { if (!dest.hasOwnProperty(key) || dest[key] === undefined) { dest[key] = value } }) }, /** * Find the last index of an item in an array according to the given checker function. * * @example * import { utils } from 'js-data'; * * const john = { name: 'John', age: 20 }; * const sara = { name: 'Sara', age: 25 }; * const dan = { name: 'Dan', age: 20 }; * const users = [john, sara, dan]; * * console.log(utils.findIndex(users, (user) =&gt; user.age === 25)); // 1 * console.log(utils.findIndex(users, (user) =&gt; user.age &gt; 19)); // 2 * console.log(utils.findIndex(users, (user) =&gt; user.name === 'John')); // 0 * console.log(utils.findIndex(users, (user) =&gt; user.name === 'Jimmy')); // -1 * * @method utils.findIndex * @param {array} array The array to search. * @param {Function} fn Checker function. * @returns {number} Index if found or -1 if not found. * @since 3.0.0 */ findIndex (array, fn) { let index = -1 if (!array) { return index } array.forEach(function (record, i) { if (fn(record)) { index = i return false } }) return index }, /** * Recursively iterate over a {@link Mapper}'s relations according to * `opts.with`. * * @method utils.forEachRelation * @param {Mapper} mapper Mapper. * @param {object} opts Configuration options. * @param {Function} fn Callback function. * @param {*} thisArg Execution context for the callback function. * @since 3.0.0 */ forEachRelation (mapper, opts, fn, thisArg) { const relationList = mapper.relationList || [] if (!relationList.length) { return } relationList.forEach(function (def) { utils._forRelation(opts, def, fn, thisArg) }) }, /** * Iterate over an object's own enumerable properties. * * @example * import { utils } from 'js-data'; * const a = { b: 1, c: 4 }; * let sum = 0; * utils.forOwn(a, function (value, key) { * sum += value; * }); * console.log(sum); // 5 * * @method utils.forOwn * @param {object} object The object whose properties are to be enumerated. * @param {Function} fn Iteration function. * @param {object} [thisArg] Content to which to bind `fn`. * @since 3.0.0 */ forOwn (obj, fn, thisArg) { const keys = Object.keys(obj) const len = keys.length let i for (i = 0; i &lt; len; i++) { if (fn.call(thisArg, obj[keys[i]], keys[i], obj) === false) { break } } }, /** * Proxy for `JSON.parse`. * * @example * import { utils } from 'js-data'; * * const a = utils.fromJson('{\"name\" : \"John\"}'); * console.log(a); // { name: 'John' } * * @method utils.fromJson * @param {string} json JSON to parse. * @returns {Object} Parsed object. * @see utils.toJson * @since 3.0.0 */ fromJson (json) { return utils.isString(json) ? JSON.parse(json) : json }, /** * Retrieve the specified property from the given object. Supports retrieving * nested properties. * * @example * import { utils } from 'js-data'; * const a = { foo: { bar: 'baz' }, beep: 'boop' }; * console.log(utils.get(a, 'beep')); // \"boop\" * console.log(utils.get(a, 'foo.bar')); // \"baz\" * * @method utils.get * @param {object} object Object from which to retrieve a property's value. * @param {string} prop Property to retrieve. * @returns {*} Value of the specified property. * @see utils.set * @since 3.0.0 */ get: function (object, prop) { if (!prop) { return } const parts = prop.split('.') const last = parts.pop() while ((prop = parts.shift())) { // eslint-disable-line object = object[prop] if (object == null) { // eslint-disable-line return } } return object[last] }, /** * Return the superclass for the given instance or subclass. If an instance is * provided, then finds the parent class of the instance's constructor. * * @example * import { utils } from 'js-data'; * // using ES2015 classes * class Foo {} * class Bar extends Foo {} * const barInstance = new Bar(); * let baseType = utils.getSuper(barInstance); * console.log(Foo === baseType); // true * * // using Function constructor with utils.extend * function Foo () {} * Foo.extend = utils.extend; * const Bar = Foo.extend(); * const barInstance = new Bar(); * let baseType = utils.getSuper(barInstance); * console.log(Foo === baseType); // true * * @method utils.getSuper * @param {Object|Function} instance Instance or constructor. * @param {boolean} [isCtor=false] Whether `instance` is a constructor. * @returns {Constructor} The superclass (grandparent constructor). * @since 3.0.0 */ getSuper (instance, isCtor) { const ctor = isCtor ? instance : instance.constructor if (ctor.hasOwnProperty('__super__')) { return ctor.__super__ } return Object.getPrototypeOf(ctor) || ctor.__proto__ // eslint-disable-line }, /** * Return the intersection of two arrays. * * @example * import { utils } from 'js-data'; * const arrA = ['green', 'red', 'blue', 'red']; * const arrB = ['green', 'yellow', 'red']; * const intersected = utils.intersection(arrA, arrB); * * console.log(intersected); // ['green', 'red']) * * @method utils.intersection * @param {array} array1 First array. * @param {array} array2 Second array. * @returns {Array} Array of elements common to both arrays. * @since 3.0.0 */ intersection (array1, array2) { if (!array1 || !array2) { return [] } array1 = Array.isArray(array1) ? array1 : [array1] array2 = Array.isArray(array2) ? array2 : [array2] const result = [] let item let i const len = array1.length for (i = 0; i &lt; len; i++) { item = array1[i] if (result.indexOf(item) !== -1) { continue } if (array2.indexOf(item) !== -1) { result.push(item) } } return result }, /** * Proxy for `Array.isArray`. * * @example * import { utils } from 'js-data'; * const a = [1,2,3,4,5]; * const b = { foo: \"bar\" }; * console.log(utils.isArray(a)); // true * console.log(utils.isArray(b)); // false * * @method utils.isArray * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an array. * @since 3.0.0 */ isArray: Array.isArray, /** * Return whether `prop` is matched by any string or regular expression in * `blacklist`. * * @example * import { utils } from 'js-data'; * const blacklist = [/^\\$hashKey/g, /^_/g, 'id']; * console.log(utils.isBlacklisted(\"$hashKey\", blacklist)); // true * console.log(utils.isBlacklisted(\"id\", blacklist)); // true * console.log(utils.isBlacklisted(\"_myProp\", blacklist)); // true * console.log(utils.isBlacklisted(\"my_id\", blacklist)); // false * * @method utils.isBlacklisted * @param {string} prop The name of a property to check. * @param {array} blacklist Array of strings and regular expressions. * @returns {boolean} Whether `prop` was matched. * @since 3.0.0 */ isBlacklisted (prop, blacklist) { if (!blacklist || !blacklist.length) { return false } let matches for (var i = 0; i &lt; blacklist.length; i++) { if ( (toStr(blacklist[i]) === REGEXP_TAG &amp;&amp; blacklist[i].test(prop)) || blacklist[i] === prop ) { matches = prop return !!matches } } return !!matches }, /** * Return whether the provided value is a boolean. * * @example * import { utils } from 'js-data'; * const a = true; * const b = { foo: \"bar\" }; * console.log(utils.isBoolean(a)); // true * console.log(utils.isBoolean(b)); // false * * @method utils.isBoolean * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a boolean. * @since 3.0.0 */ isBoolean (value) { return toStr(value) === BOOL_TAG }, /** * Return whether the provided value is a date. * * @example * import { utils } from 'js-data'; * const a = new Date(); * const b = { foo: \"bar\" }; * console.log(utils.isDate(a)); // true * console.log(utils.isDate(b)); // false * * @method utils.isDate * @param {*} value The value to test. * @returns {Date} Whether the provided value is a date. * @since 3.0.0 */ isDate (value) { return value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === DATE_TAG }, /** * Return whether the provided value is a function. * * @example * import { utils } from 'js-data'; * const a = function () { console.log('foo bar'); }; * const b = { foo: \"bar\" }; * console.log(utils.isFunction(a)); // true * console.log(utils.isFunction(b)); // false * * @method utils.isFunction * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a function. * @since 3.0.0 */ isFunction (value) { return typeof value === 'function' || (value &amp;&amp; toStr(value) === FUNC_TAG) }, /** * Return whether the provided value is an integer. * * @example * import { utils } from 'js-data'; * const a = 1; * const b = 1.25; * const c = '1'; * console.log(utils.isInteger(a)); // true * console.log(utils.isInteger(b)); // false * console.log(utils.isInteger(c)); // false * * @method utils.isInteger * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an integer. * @since 3.0.0 */ isInteger (value) { return toStr(value) === NUMBER_TAG &amp;&amp; value == toInteger(value) // eslint-disable-line }, /** * Return whether the provided value is `null`. * * @example * import { utils } from 'js-data'; * const a = null; * const b = { foo: \"bar\" }; * console.log(utils.isNull(a)); // true * console.log(utils.isNull(b)); // false * * @method utils.isNull * @param {*} value The value to test. * @returns {boolean} Whether the provided value is `null`. * @since 3.0.0 */ isNull (value) { return value === null }, /** * Return whether the provided value is a number. * * @example * import { utils } from 'js-data'; * const a = 1; * const b = -1.25; * const c = '1'; * console.log(utils.isNumber(a)); // true * console.log(utils.isNumber(b)); // true * console.log(utils.isNumber(c)); // false * * @method utils.isNumber * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a number. * @since 3.0.0 */ isNumber (value) { const type = typeof value return ( type === 'number' || (value &amp;&amp; type === 'object' &amp;&amp; toStr(value) === NUMBER_TAG) ) }, /** * Return whether the provided value is an object. * * @example * import { utils } from 'js-data'; * const a = { foo: \"bar\" }; * const b = 'foo bar'; * console.log(utils.isObject(a)); // true * console.log(utils.isObject(b)); // false * * @method utils.isObject * @param {*} value The value to test. * @returns {boolean} Whether the provided value is an object. * @since 3.0.0 */ isObject (value) { return toStr(value) === OBJECT_TAG }, /** * Return whether the provided value is a regular expression. * * @example * import { utils } from 'js-data'; * const a = /^\\$.+$/ig; * const b = new RegExp('^\\$.+$', 'ig'); * const c = { foo: \"bar\" }; * console.log(utils.isRegExp(a)); // true * console.log(utils.isRegExp(b)); // true * console.log(utils.isRegExp(c)); // false * * @method utils.isRegExp * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a regular expression. * @since 3.0.0 */ isRegExp (value) { return toStr(value) === REGEXP_TAG }, /** * Return whether the provided value is a string or a number. * * @example * import { utils } from 'js-data'; * console.log(utils.isSorN('')); // true * console.log(utils.isSorN(-1.65)); // true * console.log(utils.isSorN('my string')); // true * console.log(utils.isSorN({})); // false * console.log(utils.isSorN([1,2,4])); // false * * @method utils.isSorN * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a string or a number. * @since 3.0.0 */ isSorN (value) { return utils.isString(value) || utils.isNumber(value) }, /** * Return whether the provided value is a string. * * @example * import { utils } from 'js-data'; * console.log(utils.isString('')); // true * console.log(utils.isString('my string')); // true * console.log(utils.isString(100)); // false * console.log(utils.isString([1,2,4])); // false * * @method utils.isString * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a string. * @since 3.0.0 */ isString (value) { return ( typeof value === 'string' || (value &amp;&amp; typeof value === 'object' &amp;&amp; toStr(value) === STRING_TAG) ) }, /** * Return whether the provided value is a `undefined`. * * @example * import { utils } from 'js-data'; * const a = undefined; * const b = { foo: \"bar\"}; * console.log(utils.isUndefined(a)); // true * console.log(utils.isUndefined(b.baz)); // true * console.log(utils.isUndefined(b)); // false * console.log(utils.isUndefined(b.foo)); // false * * @method utils.isUndefined * @param {*} value The value to test. * @returns {boolean} Whether the provided value is a `undefined`. * @since 3.0.0 */ isUndefined (value) { return value === undefined }, /** * Mix in logging capabilities to the target. * * @example * import { utils } from 'js-data'; * const a = { foo: \"bar\"}; * * // Add standard logging to an object * utils.logify(a); * a.log('info', 'test log info'); // output 'test log info' to console. * * // Toggle debug output of an object * a.dbg('test debug output'); // does not output because debug is off. * a.debug = true; * a.dbg('test debug output'); // output 'test debug output' to console. * * @method utils.logify * @param {*} target The target. * @since 3.0.0 */ logify (target) { utils.addHiddenPropsToTarget(target, { dbg (...args) { if (utils.isFunction(this.log)) { this.log('debug', ...args) } }, log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (${this.name || this.constructor.name})` if (utils.isFunction(console[level])) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } } }) }, /** * Adds the given record to the provided array only if it's not already in the * array. * * @example * import { utils } from 'js-data'; * const colors = ['red', 'green', 'yellow']; * * console.log(colors.length); // 3 * utils.noDupeAdd(colors, 'red'); * console.log(colors.length); // 3, red already exists * * utils.noDupeAdd(colors, 'blue'); * console.log(colors.length); // 4, blue was added * * @method utils.noDupeAdd * @param {array} array The array. * @param {*} record The value to add. * @param {Function} fn Callback function passed to {@link utils.findIndex}. * @since 3.0.0 */ noDupeAdd (array, record, fn) { if (!array) { return } const index = this.findIndex(array, fn) if (index &lt; 0) { array.push(record) } }, /** * Return a shallow copy of the provided object, minus the properties * specified in `keys`. * * @example * import { utils } from 'js-data'; * const a = { name: 'John', $hashKey: 1214910 }; * * let b = utils.omit(a, ['$hashKey']); * console.log(b); // { name: 'John' } * * @method utils.omit * @param {object} props The object to copy. * @param {string[]} keys Array of strings, representing properties to skip. * @returns {Object} Shallow copy of `props`, minus `keys`. * @since 3.0.0 */ omit (props, keys) { const _props = {} utils.forOwn(props, function (value, key) { if (keys.indexOf(key) === -1) { _props[key] = value } }) return _props }, /** * Return a shallow copy of the provided object, but only include the * properties specified in `keys`. * * @example * import { utils } from 'js-data'; * const a = { name: 'John', $hashKey: 1214910 }; * * let b = utils.pick(a, ['$hashKey']); * console.log(b); // { $hashKey: 1214910 } * * @method utils.pick * @param {object} props The object to copy. * @param {string[]} keys Array of strings, representing properties to keep. * @returns {Object} Shallow copy of `props`, but only including `keys`. * @since 3.0.0 */ pick (props, keys) { return keys.reduce((map, key) =&gt; { map[key] = props[key] return map }, {}) }, /** * Return a plain copy of the given value. * * @example * import { utils } from 'js-data'; * const a = { name: 'John' }; * let b = utils.plainCopy(a); * console.log(a === b); // false * * @method utils.plainCopy * @param {*} value The value to copy. * @returns {*} Plain copy of `value`. * @see utils.copy * @since 3.0.0 */ plainCopy (value) { return utils.copy(value, undefined, undefined, undefined, undefined, true) }, /** * Shortcut for `utils.Promise.reject(value)`. * * @example * import { utils } from 'js-data'; * * utils.reject(\"Testing static reject\").then(function (data) { * // not called * }).catch(function (reason) { * console.log(reason); // \"Testing static reject\" * }); * * @method utils.reject * @param {*} [value] Value with which to reject the Promise. * @returns {Promise} Promise reject with `value`. * @see utils.Promise * @since 3.0.0 */ reject (value) { return utils.Promise.reject(value) }, /** * Remove the last item found in array according to the given checker function. * * @example * import { utils } from 'js-data'; * * const colors = ['red', 'green', 'yellow', 'red']; * utils.remove(colors, (color) =&gt; color === 'red'); * console.log(colors); // ['red', 'green', 'yellow'] * * @method utils.remove * @param {array} array The array to search. * @param {Function} fn Checker function. */ remove (array, fn) { if (!array || !array.length) { return } const index = this.findIndex(array, fn) if (index &gt;= 0) { array.splice(index, 1) // todo should this be recursive? } }, /** * Shortcut for `utils.Promise.resolve(value)`. * * @example * import { utils } from 'js-data'; * * utils.resolve(\"Testing static resolve\").then(function (data) { * console.log(data); // \"Testing static resolve\" * }).catch(function (reason) { * // not called * }); * * @param {*} [value] Value with which to resolve the Promise. * @returns {Promise} Promise resolved with `value`. * @see utils.Promise * @since 3.0.0 */ resolve (value) { return utils.Promise.resolve(value) }, /** * Set the value at the provided key or path. * * @example * import { utils } from 'js-data'; * * const john = { * name: 'John', * age: 25, * parent: { * name: 'John's Mom', * age: 50 * } * }; * // set value by key * utils.set(john, 'id', 98); * console.log(john.id); // 98 * * // set value by path * utils.set(john, 'parent.id', 20); * console.log(john.parent.id); // 20 * * // set value by path/value map * utils.set(john, { * 'id': 1098, * 'parent': { id: 1020 }, * 'parent.age': '55' * }); * console.log(john.id); // 1098 * console.log(john.parent.id); // 1020 * console.log(john.parent.age); // 55 * * @method utils.set * @param {object} object The object on which to set a property. * @param {(string|Object)} path The key or path to the property. Can also * pass in an object of path/value pairs, which will all be set on the target * object. * @param {*} [value] The value to set. */ set: function (object, path, value) { if (utils.isObject(path)) { utils.forOwn(path, function (value, _path) { utils.set(object, _path, value) }) } else { const parts = PATH.exec(path) if (parts) { mkdirP(object, parts[1])[parts[2]] = value } else { object[path] = value } } }, /** * Check whether the two provided objects are deeply equal. * * @example * import { utils } from 'js-data'; * * const objA = { * name: 'John', * id: 27, * nested: { * item: 'item 1', * colors: ['red', 'green', 'blue'] * } * }; * * const objB = { * name: 'John', * id: 27, * nested: { * item: 'item 1', * colors: ['red', 'green', 'blue'] * } * }; * * console.log(utils.deepEqual(a,b)); // true * objB.nested.colors.add('yellow'); // make a change to a nested object's array * console.log(utils.deepEqual(a,b)); // false * * @method utils.deepEqual * @param {object} a First object in the comparison. * @param {object} b Second object in the comparison. * @returns {boolean} Whether the two provided objects are deeply equal. * @see utils.equal * @since 3.0.0 */ deepEqual (a, b) { if (a === b) { return true } let _equal = true if (utils.isArray(a) &amp;&amp; utils.isArray(b)) { if (a.length !== b.length) { return false } for (let i = a.length; i--;) { if (!utils.deepEqual(a[i], b[i])) { // Exit loop early return false } } } else if (utils.isObject(a) &amp;&amp; utils.isObject(b)) { utils.forOwn(a, function (value, key) { if (!(_equal = utils.deepEqual(value, b[key]))) { // Exit loop early return false } }) if (_equal) { utils.forOwn(b, function (value, key) { if (!(_equal = utils.deepEqual(value, a[key]))) { // Exit loop early return false } }) } } else { return false } return _equal }, /** * Proxy for `JSON.stringify`. * * @example * import { utils } from 'js-data'; * * const a = { name: 'John' }; * let jsonVal = utils.toJson(a); * console.log(jsonVal); // '{\"name\" : \"John\"}' * * @method utils.toJson * @param {*} value Value to serialize to JSON. * @returns {string} JSON string. * @see utils.fromJson * @since 3.0.0 */ toJson: JSON.stringify, /** * Unset the value at the provided key or path. * * @example * import { utils } from 'js-data'; * * const john = { * name: 'John', * age: 25, * parent: { * name: 'John's Mom', * age: 50 * } * }; * * utils.unset(john, age); * utils.unset(john, parent.age); * * console.log(john.age); // null * console.log(john.parent.age); // null * * @method utils.unset * @param {object} object The object from which to delete the property. * @param {string} path The key or path to the property. * @see utils.set * @since 3.0.0 */ unset (object, path) { const parts = path.split('.') const last = parts.pop() while ((path = parts.shift())) { // eslint-disable-line object = object[path] if (object == null) { // eslint-disable-line return } } object[last] = undefined } } export const safeSetProp = function (record, field, value) { if (record &amp;&amp; record._set) { record._set(`props.${field}`, value) } else { utils.set(record, field, value) } } export const safeSetLink = function (record, field, value) { if (record &amp;&amp; record._set) { record._set(`links.${field}`, value) } else { utils.set(record, field, value) } } export default utils × Search results Close api.js-data.io • js-data.io "},"global.html":{"id":"global.html","title":"Global","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Global Details Methods _createOrAssignChildRecordIfRequired(props, context) Creates child record for relation types like HasOne or HasMany with foreignKey in order to satisfy foreignKey dependency (so called parent records). Method parameters: Name Type Description props Object See Mapper#create. context Object contains collected information. Properties Name Type Description opts Object See Mapper#create. parentRelationMap Object contains parent records map originalProps Object contains data passed into Mapper#create method Return value: Type Description Promise updated props Details Since Source See 3.0.0 Mapper.js, line 1086 Mapper#create _createParentRecordIfRequired(props, opts) Creates parent record for relation types like BelongsTo or HasMany with localKeys in order to satisfy foreignKey dependency (so called child records). Method parameters: Name Type Description props Object See Mapper#create. opts Object See Mapper#create. Return value: Type Description Object cached parent records map Details Since Source See 3.0.0 Mapper.js, line 1052 Mapper#create × Search results Close api.js-data.io • js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Modules Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Settable SimpleStore Namespaces query utils Events add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll afterCreate Fired during Container#create. See Container~afterCreateListener for how to listen for this event. Details Source See Container.js, line 58 Container~afterCreateListener Container#create afterCreateMany Fired during Container#createMany. See Container~afterCreateManyListener for how to listen for this event. Details Source See Container.js, line 139 Container~afterCreateManyListener Container#createMany afterDestroy Fired during Container#destroy. See Container~afterDestroyListener for how to listen for this event. Details Source See Container.js, line 247 Container~afterDestroyListener Container#destroy afterDestroyAll Fired during Container#destroyAll. See Container~afterDestroyAllListener for how to listen for this event. Details Source See Container.js, line 325 Container~afterDestroyAllListener Container#destroyAll afterFind Fired during Container#find. See Container~afterFindListener for how to listen for this event. Details Source See Container.js, line 403 Container~afterFindListener Container#find afterFindAll Fired during Container#findAll. See Container~afterFindAllListener for how to listen for this event. Details Source See Container.js, line 480 Container~afterFindAllListener Container#findAll afterUpdate Fired during Container#update. See Container~afterUpdateListener for how to listen for this event. Details Source See Container.js, line 660 Container~afterUpdateListener Container#update afterUpdateAll Fired during Container#updateAll. See Container~afterUpdateAllListener for how to listen for this event. Details Source See Container.js, line 744 Container~afterUpdateAllListener Container#updateAll afterUpdateMany Fired during Container#updateMany. See Container~afterUpdateManyListener for how to listen for this event. Details Source See Container.js, line 826 Container~afterUpdateManyListener Container#updateMany beforeCreate Fired during Container#create. See Container~beforeCreateListener for how to listen for this event. Details Source See Container.js, line 33 Container~beforeCreateListener Container#create beforeCreateMany Fired during Container#createMany. See Container~beforeCreateManyListener for how to listen for this event. Details Source See Container.js, line 114 Container~beforeCreateManyListener Container#createMany beforeDestroy Fired during Container#destroy. See Container~beforeDestroyListener for how to listen for this event. Details Source See Container.js, line 222 Container~beforeDestroyListener Container#destroy beforeDestroyAll Fired during Container#destroyAll. See Container~beforeDestroyAllListener for how to listen for this event. Details Source See Container.js, line 300 Container~beforeDestroyAllListener Container#destroyAll beforeFind Fired during Container#find. See Container~beforeFindListener for how to listen for this event. Details Source See Container.js, line 378 Container~beforeFindListener Container#find beforeFindAll Fired during Container#findAll. See Container~beforeFindAllListener for how to listen for this event. Details Source See Container.js, line 455 Container~beforeFindAllListener Container#findAll beforeUpdate Fired during Container#update. See Container~beforeUpdateListener for how to listen for this event. Details Source See Container.js, line 634 Container~beforeUpdateListener Container#update beforeUpdateAll Fired during Container#updateAll. See Container~beforeUpdateAllListener for how to listen for this event. Details Source See Container.js, line 718 Container~beforeUpdateAllListener Container#updateAll beforeUpdateMany Fired during Container#updateMany. See Container~beforeUpdateManyListener for how to listen for this event. Details Source See Container.js, line 801 Container~beforeUpdateManyListener Container#updateMany add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany Inherited From: SimpleStore#event:add afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 777 SimpleStore~afterCreateListener SimpleStore#create Inherited From: SimpleStore#event:afterCreate afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 869 SimpleStore~afterCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:afterCreateMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 1013 SimpleStore~afterDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:afterDestroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1120 SimpleStore~afterDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:afterDestroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1236 SimpleStore~afterFindListener SimpleStore#find Inherited From: SimpleStore#event:afterFind afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1348 SimpleStore~afterFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:afterFindAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1648 SimpleStore~afterUpdateListener SimpleStore#update Inherited From: SimpleStore#event:afterUpdate afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1740 SimpleStore~afterUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:afterUpdateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1831 SimpleStore~afterUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:afterUpdateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 752 SimpleStore~beforeCreateListener SimpleStore#create Inherited From: SimpleStore#event:beforeCreate beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 844 SimpleStore~beforeCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:beforeCreateMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 988 SimpleStore~beforeDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:beforeDestroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1095 SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:beforeDestroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1211 SimpleStore~beforeFindListener SimpleStore#find Inherited From: SimpleStore#event:beforeFind beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1323 SimpleStore~beforeFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:beforeFindAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1622 SimpleStore~beforeUpdateListener SimpleStore#update Inherited From: SimpleStore#event:beforeUpdate beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1714 SimpleStore~beforeUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:beforeUpdateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1806 SimpleStore~beforeUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:beforeUpdateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener Inherited From: SimpleStore#event:change remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll Inherited From: SimpleStore#event:remove add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add Inherited From: Collection#event:add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener Inherited From: Collection#event:change remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll Inherited From: Collection#event:remove afterCreate Fired during Mapper#create. See Mapper~afterCreateListener for how to listen for this event. Details Source See Mapper.js, line 910 Mapper~afterCreateListener Mapper#create afterCreateMany Fired during Mapper#createMany. See Mapper~afterCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1138 Mapper~afterCreateManyListener Mapper#createMany afterDestroy Fired during Mapper#destroy. See Mapper~afterDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1476 Mapper~afterDestroyListener Mapper#destroy afterDestroyAll Fired during Mapper#destroyAll. See Mapper~afterDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1563 Mapper~afterDestroyAllListener Mapper#destroyAll afterFind Fired during Mapper#find. See Mapper~afterFindListener for how to listen for this event. Details Source See Mapper.js, line 1664 Mapper~afterFindListener Mapper#find afterFindAll Fired during Mapper#findAll. See Mapper~afterFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1753 Mapper~afterFindAllListener Mapper#findAll afterUpdate Fired during Mapper#update. See Mapper~afterUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2135 Mapper~afterUpdateListener Mapper#update afterUpdateAll Fired during Mapper#updateAll. See Mapper~afterUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2224 Mapper~afterUpdateAllListener Mapper#updateAll afterUpdateMany Fired during Mapper#updateMany. See Mapper~afterUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2314 Mapper~afterUpdateManyListener Mapper#updateMany beforeCreate Fired during Mapper#create. See Mapper~beforeCreateListener for how to listen for this event. Details Source See Mapper.js, line 886 Mapper~beforeCreateListener Mapper#create beforeCreateMany Fired during Mapper#createMany. See Mapper~beforeCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1114 Mapper~beforeCreateManyListener Mapper#createMany beforeDestroy Fired during Mapper#destroy. See Mapper~beforeDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1452 Mapper~beforeDestroyListener Mapper#destroy beforeDestroyAll Fired during Mapper#destroyAll. See Mapper~beforeDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1539 Mapper~beforeDestroyAllListener Mapper#destroyAll beforeFind Fired during Mapper#find. See Mapper~beforeFindListener for how to listen for this event. Details Source See Mapper.js, line 1640 Mapper~beforeFindListener Mapper#find beforeFindAll Fired during Mapper#findAll. See Mapper~beforeFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1729 Mapper~beforeFindAllListener Mapper#findAll beforeUpdate Fired during Mapper#update. See Mapper~beforeUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2110 Mapper~beforeUpdateListener Mapper#update beforeUpdateAll Fired during Mapper#updateAll. See Mapper~beforeUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2199 Mapper~beforeUpdateAllListener Mapper#updateAll beforeUpdateMany Fired during Mapper#updateMany. See Mapper~beforeUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2290 Mapper~beforeUpdateManyListener Mapper#updateMany change Fired when a record changes. Only works for records that have tracked fields. See Record~changeListener on how to listen for this event. Details Source See Record.js, line 859 Record~changeListener add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 777 Container#event:afterCreate SimpleStore~afterCreateListener SimpleStore#create afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 869 Container#event:afterCreateMany SimpleStore~afterCreateManyListener SimpleStore#createMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1013 Container#event:afterDestroy SimpleStore~afterDestroyListener SimpleStore#destroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1120 Container#event:afterDestroyAll SimpleStore~afterDestroyAllListener SimpleStore#destroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1236 Container#event:afterFind SimpleStore~afterFindListener SimpleStore#find afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1348 Container#event:afterFindAll SimpleStore~afterFindAllListener SimpleStore#findAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1648 Container#event:afterUpdate SimpleStore~afterUpdateListener SimpleStore#update afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1740 Container#event:afterUpdateAll SimpleStore~afterUpdateAllListener SimpleStore#updateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1831 Container#event:afterUpdateMany SimpleStore~afterUpdateManyListener SimpleStore#updateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 752 Container#event:beforeCreate SimpleStore~beforeCreateListener SimpleStore#create beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 844 Container#event:beforeCreateMany SimpleStore~beforeCreateManyListener SimpleStore#createMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 988 Container#event:beforeDestroy SimpleStore~beforeDestroyListener SimpleStore#destroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1095 Container#event:beforeDestroyAll SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1211 Container#event:beforeFind SimpleStore~beforeFindListener SimpleStore#find beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1323 Container#event:beforeFindAll SimpleStore~beforeFindAllListener SimpleStore#findAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1622 Container#event:beforeUpdate SimpleStore~beforeUpdateListener SimpleStore#update beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1714 Container#event:beforeUpdateAll SimpleStore~beforeUpdateAllListener SimpleStore#updateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1806 Container#event:beforeUpdateMany SimpleStore~beforeUpdateManyListener SimpleStore#updateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll × Search results Close api.js-data.io • js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Classes Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Settable SimpleStore Namespaces query utils Events add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll afterCreate Fired during Container#create. See Container~afterCreateListener for how to listen for this event. Details Source See Container.js, line 58 Container~afterCreateListener Container#create afterCreateMany Fired during Container#createMany. See Container~afterCreateManyListener for how to listen for this event. Details Source See Container.js, line 139 Container~afterCreateManyListener Container#createMany afterDestroy Fired during Container#destroy. See Container~afterDestroyListener for how to listen for this event. Details Source See Container.js, line 247 Container~afterDestroyListener Container#destroy afterDestroyAll Fired during Container#destroyAll. See Container~afterDestroyAllListener for how to listen for this event. Details Source See Container.js, line 325 Container~afterDestroyAllListener Container#destroyAll afterFind Fired during Container#find. See Container~afterFindListener for how to listen for this event. Details Source See Container.js, line 403 Container~afterFindListener Container#find afterFindAll Fired during Container#findAll. See Container~afterFindAllListener for how to listen for this event. Details Source See Container.js, line 480 Container~afterFindAllListener Container#findAll afterUpdate Fired during Container#update. See Container~afterUpdateListener for how to listen for this event. Details Source See Container.js, line 660 Container~afterUpdateListener Container#update afterUpdateAll Fired during Container#updateAll. See Container~afterUpdateAllListener for how to listen for this event. Details Source See Container.js, line 744 Container~afterUpdateAllListener Container#updateAll afterUpdateMany Fired during Container#updateMany. See Container~afterUpdateManyListener for how to listen for this event. Details Source See Container.js, line 826 Container~afterUpdateManyListener Container#updateMany beforeCreate Fired during Container#create. See Container~beforeCreateListener for how to listen for this event. Details Source See Container.js, line 33 Container~beforeCreateListener Container#create beforeCreateMany Fired during Container#createMany. See Container~beforeCreateManyListener for how to listen for this event. Details Source See Container.js, line 114 Container~beforeCreateManyListener Container#createMany beforeDestroy Fired during Container#destroy. See Container~beforeDestroyListener for how to listen for this event. Details Source See Container.js, line 222 Container~beforeDestroyListener Container#destroy beforeDestroyAll Fired during Container#destroyAll. See Container~beforeDestroyAllListener for how to listen for this event. Details Source See Container.js, line 300 Container~beforeDestroyAllListener Container#destroyAll beforeFind Fired during Container#find. See Container~beforeFindListener for how to listen for this event. Details Source See Container.js, line 378 Container~beforeFindListener Container#find beforeFindAll Fired during Container#findAll. See Container~beforeFindAllListener for how to listen for this event. Details Source See Container.js, line 455 Container~beforeFindAllListener Container#findAll beforeUpdate Fired during Container#update. See Container~beforeUpdateListener for how to listen for this event. Details Source See Container.js, line 634 Container~beforeUpdateListener Container#update beforeUpdateAll Fired during Container#updateAll. See Container~beforeUpdateAllListener for how to listen for this event. Details Source See Container.js, line 718 Container~beforeUpdateAllListener Container#updateAll beforeUpdateMany Fired during Container#updateMany. See Container~beforeUpdateManyListener for how to listen for this event. Details Source See Container.js, line 801 Container~beforeUpdateManyListener Container#updateMany add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany Inherited From: SimpleStore#event:add afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 777 SimpleStore~afterCreateListener SimpleStore#create Inherited From: SimpleStore#event:afterCreate afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 869 SimpleStore~afterCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:afterCreateMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 1013 SimpleStore~afterDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:afterDestroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1120 SimpleStore~afterDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:afterDestroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1236 SimpleStore~afterFindListener SimpleStore#find Inherited From: SimpleStore#event:afterFind afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1348 SimpleStore~afterFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:afterFindAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1648 SimpleStore~afterUpdateListener SimpleStore#update Inherited From: SimpleStore#event:afterUpdate afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1740 SimpleStore~afterUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:afterUpdateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1831 SimpleStore~afterUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:afterUpdateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 752 SimpleStore~beforeCreateListener SimpleStore#create Inherited From: SimpleStore#event:beforeCreate beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 844 SimpleStore~beforeCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:beforeCreateMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 988 SimpleStore~beforeDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:beforeDestroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1095 SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:beforeDestroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1211 SimpleStore~beforeFindListener SimpleStore#find Inherited From: SimpleStore#event:beforeFind beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1323 SimpleStore~beforeFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:beforeFindAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1622 SimpleStore~beforeUpdateListener SimpleStore#update Inherited From: SimpleStore#event:beforeUpdate beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1714 SimpleStore~beforeUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:beforeUpdateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1806 SimpleStore~beforeUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:beforeUpdateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener Inherited From: SimpleStore#event:change remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll Inherited From: SimpleStore#event:remove add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add Inherited From: Collection#event:add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener Inherited From: Collection#event:change remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll Inherited From: Collection#event:remove afterCreate Fired during Mapper#create. See Mapper~afterCreateListener for how to listen for this event. Details Source See Mapper.js, line 910 Mapper~afterCreateListener Mapper#create afterCreateMany Fired during Mapper#createMany. See Mapper~afterCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1138 Mapper~afterCreateManyListener Mapper#createMany afterDestroy Fired during Mapper#destroy. See Mapper~afterDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1476 Mapper~afterDestroyListener Mapper#destroy afterDestroyAll Fired during Mapper#destroyAll. See Mapper~afterDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1563 Mapper~afterDestroyAllListener Mapper#destroyAll afterFind Fired during Mapper#find. See Mapper~afterFindListener for how to listen for this event. Details Source See Mapper.js, line 1664 Mapper~afterFindListener Mapper#find afterFindAll Fired during Mapper#findAll. See Mapper~afterFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1753 Mapper~afterFindAllListener Mapper#findAll afterUpdate Fired during Mapper#update. See Mapper~afterUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2135 Mapper~afterUpdateListener Mapper#update afterUpdateAll Fired during Mapper#updateAll. See Mapper~afterUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2224 Mapper~afterUpdateAllListener Mapper#updateAll afterUpdateMany Fired during Mapper#updateMany. See Mapper~afterUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2314 Mapper~afterUpdateManyListener Mapper#updateMany beforeCreate Fired during Mapper#create. See Mapper~beforeCreateListener for how to listen for this event. Details Source See Mapper.js, line 886 Mapper~beforeCreateListener Mapper#create beforeCreateMany Fired during Mapper#createMany. See Mapper~beforeCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1114 Mapper~beforeCreateManyListener Mapper#createMany beforeDestroy Fired during Mapper#destroy. See Mapper~beforeDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1452 Mapper~beforeDestroyListener Mapper#destroy beforeDestroyAll Fired during Mapper#destroyAll. See Mapper~beforeDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1539 Mapper~beforeDestroyAllListener Mapper#destroyAll beforeFind Fired during Mapper#find. See Mapper~beforeFindListener for how to listen for this event. Details Source See Mapper.js, line 1640 Mapper~beforeFindListener Mapper#find beforeFindAll Fired during Mapper#findAll. See Mapper~beforeFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1729 Mapper~beforeFindAllListener Mapper#findAll beforeUpdate Fired during Mapper#update. See Mapper~beforeUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2110 Mapper~beforeUpdateListener Mapper#update beforeUpdateAll Fired during Mapper#updateAll. See Mapper~beforeUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2199 Mapper~beforeUpdateAllListener Mapper#updateAll beforeUpdateMany Fired during Mapper#updateMany. See Mapper~beforeUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2290 Mapper~beforeUpdateManyListener Mapper#updateMany change Fired when a record changes. Only works for records that have tracked fields. See Record~changeListener on how to listen for this event. Details Source See Record.js, line 859 Record~changeListener add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 777 Container#event:afterCreate SimpleStore~afterCreateListener SimpleStore#create afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 869 Container#event:afterCreateMany SimpleStore~afterCreateManyListener SimpleStore#createMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1013 Container#event:afterDestroy SimpleStore~afterDestroyListener SimpleStore#destroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1120 Container#event:afterDestroyAll SimpleStore~afterDestroyAllListener SimpleStore#destroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1236 Container#event:afterFind SimpleStore~afterFindListener SimpleStore#find afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1348 Container#event:afterFindAll SimpleStore~afterFindAllListener SimpleStore#findAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1648 Container#event:afterUpdate SimpleStore~afterUpdateListener SimpleStore#update afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1740 Container#event:afterUpdateAll SimpleStore~afterUpdateAllListener SimpleStore#updateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1831 Container#event:afterUpdateMany SimpleStore~afterUpdateManyListener SimpleStore#updateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 752 Container#event:beforeCreate SimpleStore~beforeCreateListener SimpleStore#create beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 844 Container#event:beforeCreateMany SimpleStore~beforeCreateManyListener SimpleStore#createMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 988 Container#event:beforeDestroy SimpleStore~beforeDestroyListener SimpleStore#destroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1095 Container#event:beforeDestroyAll SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1211 Container#event:beforeFind SimpleStore~beforeFindListener SimpleStore#find beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1323 Container#event:beforeFindAll SimpleStore~beforeFindAllListener SimpleStore#findAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1622 Container#event:beforeUpdate SimpleStore~beforeUpdateListener SimpleStore#update beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1714 Container#event:beforeUpdateAll SimpleStore~beforeUpdateAllListener SimpleStore#updateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1806 Container#event:beforeUpdateMany SimpleStore~beforeUpdateManyListener SimpleStore#updateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll × Search results Close api.js-data.io • js-data.io "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Namespaces Details Classes Collection Component Container DataStore LinkedCollection Mapper Query Record Schema Settable SimpleStore Namespaces query utils Events add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll afterCreate Fired during Container#create. See Container~afterCreateListener for how to listen for this event. Details Source See Container.js, line 58 Container~afterCreateListener Container#create afterCreateMany Fired during Container#createMany. See Container~afterCreateManyListener for how to listen for this event. Details Source See Container.js, line 139 Container~afterCreateManyListener Container#createMany afterDestroy Fired during Container#destroy. See Container~afterDestroyListener for how to listen for this event. Details Source See Container.js, line 247 Container~afterDestroyListener Container#destroy afterDestroyAll Fired during Container#destroyAll. See Container~afterDestroyAllListener for how to listen for this event. Details Source See Container.js, line 325 Container~afterDestroyAllListener Container#destroyAll afterFind Fired during Container#find. See Container~afterFindListener for how to listen for this event. Details Source See Container.js, line 403 Container~afterFindListener Container#find afterFindAll Fired during Container#findAll. See Container~afterFindAllListener for how to listen for this event. Details Source See Container.js, line 480 Container~afterFindAllListener Container#findAll afterUpdate Fired during Container#update. See Container~afterUpdateListener for how to listen for this event. Details Source See Container.js, line 660 Container~afterUpdateListener Container#update afterUpdateAll Fired during Container#updateAll. See Container~afterUpdateAllListener for how to listen for this event. Details Source See Container.js, line 744 Container~afterUpdateAllListener Container#updateAll afterUpdateMany Fired during Container#updateMany. See Container~afterUpdateManyListener for how to listen for this event. Details Source See Container.js, line 826 Container~afterUpdateManyListener Container#updateMany beforeCreate Fired during Container#create. See Container~beforeCreateListener for how to listen for this event. Details Source See Container.js, line 33 Container~beforeCreateListener Container#create beforeCreateMany Fired during Container#createMany. See Container~beforeCreateManyListener for how to listen for this event. Details Source See Container.js, line 114 Container~beforeCreateManyListener Container#createMany beforeDestroy Fired during Container#destroy. See Container~beforeDestroyListener for how to listen for this event. Details Source See Container.js, line 222 Container~beforeDestroyListener Container#destroy beforeDestroyAll Fired during Container#destroyAll. See Container~beforeDestroyAllListener for how to listen for this event. Details Source See Container.js, line 300 Container~beforeDestroyAllListener Container#destroyAll beforeFind Fired during Container#find. See Container~beforeFindListener for how to listen for this event. Details Source See Container.js, line 378 Container~beforeFindListener Container#find beforeFindAll Fired during Container#findAll. See Container~beforeFindAllListener for how to listen for this event. Details Source See Container.js, line 455 Container~beforeFindAllListener Container#findAll beforeUpdate Fired during Container#update. See Container~beforeUpdateListener for how to listen for this event. Details Source See Container.js, line 634 Container~beforeUpdateListener Container#update beforeUpdateAll Fired during Container#updateAll. See Container~beforeUpdateAllListener for how to listen for this event. Details Source See Container.js, line 718 Container~beforeUpdateAllListener Container#updateAll beforeUpdateMany Fired during Container#updateMany. See Container~beforeUpdateManyListener for how to listen for this event. Details Source See Container.js, line 801 Container~beforeUpdateManyListener Container#updateMany add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany Inherited From: SimpleStore#event:add afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 777 SimpleStore~afterCreateListener SimpleStore#create Inherited From: SimpleStore#event:afterCreate afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 869 SimpleStore~afterCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:afterCreateMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 1013 SimpleStore~afterDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:afterDestroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1120 SimpleStore~afterDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:afterDestroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1236 SimpleStore~afterFindListener SimpleStore#find Inherited From: SimpleStore#event:afterFind afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1348 SimpleStore~afterFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:afterFindAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1648 SimpleStore~afterUpdateListener SimpleStore#update Inherited From: SimpleStore#event:afterUpdate afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1740 SimpleStore~afterUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:afterUpdateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1831 SimpleStore~afterUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:afterUpdateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 752 SimpleStore~beforeCreateListener SimpleStore#create Inherited From: SimpleStore#event:beforeCreate beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 844 SimpleStore~beforeCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:beforeCreateMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 988 SimpleStore~beforeDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:beforeDestroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1095 SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:beforeDestroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1211 SimpleStore~beforeFindListener SimpleStore#find Inherited From: SimpleStore#event:beforeFind beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1323 SimpleStore~beforeFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:beforeFindAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1622 SimpleStore~beforeUpdateListener SimpleStore#update Inherited From: SimpleStore#event:beforeUpdate beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1714 SimpleStore~beforeUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:beforeUpdateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1806 SimpleStore~beforeUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:beforeUpdateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener Inherited From: SimpleStore#event:change remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll Inherited From: SimpleStore#event:remove add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add Inherited From: Collection#event:add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener Inherited From: Collection#event:change remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll Inherited From: Collection#event:remove afterCreate Fired during Mapper#create. See Mapper~afterCreateListener for how to listen for this event. Details Source See Mapper.js, line 910 Mapper~afterCreateListener Mapper#create afterCreateMany Fired during Mapper#createMany. See Mapper~afterCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1138 Mapper~afterCreateManyListener Mapper#createMany afterDestroy Fired during Mapper#destroy. See Mapper~afterDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1476 Mapper~afterDestroyListener Mapper#destroy afterDestroyAll Fired during Mapper#destroyAll. See Mapper~afterDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1563 Mapper~afterDestroyAllListener Mapper#destroyAll afterFind Fired during Mapper#find. See Mapper~afterFindListener for how to listen for this event. Details Source See Mapper.js, line 1664 Mapper~afterFindListener Mapper#find afterFindAll Fired during Mapper#findAll. See Mapper~afterFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1753 Mapper~afterFindAllListener Mapper#findAll afterUpdate Fired during Mapper#update. See Mapper~afterUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2135 Mapper~afterUpdateListener Mapper#update afterUpdateAll Fired during Mapper#updateAll. See Mapper~afterUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2224 Mapper~afterUpdateAllListener Mapper#updateAll afterUpdateMany Fired during Mapper#updateMany. See Mapper~afterUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2314 Mapper~afterUpdateManyListener Mapper#updateMany beforeCreate Fired during Mapper#create. See Mapper~beforeCreateListener for how to listen for this event. Details Source See Mapper.js, line 886 Mapper~beforeCreateListener Mapper#create beforeCreateMany Fired during Mapper#createMany. See Mapper~beforeCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1114 Mapper~beforeCreateManyListener Mapper#createMany beforeDestroy Fired during Mapper#destroy. See Mapper~beforeDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1452 Mapper~beforeDestroyListener Mapper#destroy beforeDestroyAll Fired during Mapper#destroyAll. See Mapper~beforeDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1539 Mapper~beforeDestroyAllListener Mapper#destroyAll beforeFind Fired during Mapper#find. See Mapper~beforeFindListener for how to listen for this event. Details Source See Mapper.js, line 1640 Mapper~beforeFindListener Mapper#find beforeFindAll Fired during Mapper#findAll. See Mapper~beforeFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1729 Mapper~beforeFindAllListener Mapper#findAll beforeUpdate Fired during Mapper#update. See Mapper~beforeUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2110 Mapper~beforeUpdateListener Mapper#update beforeUpdateAll Fired during Mapper#updateAll. See Mapper~beforeUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2199 Mapper~beforeUpdateAllListener Mapper#updateAll beforeUpdateMany Fired during Mapper#updateMany. See Mapper~beforeUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2290 Mapper~beforeUpdateManyListener Mapper#updateMany change Fired when a record changes. Only works for records that have tracked fields. See Record~changeListener on how to listen for this event. Details Source See Record.js, line 859 Record~changeListener add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 777 Container#event:afterCreate SimpleStore~afterCreateListener SimpleStore#create afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 869 Container#event:afterCreateMany SimpleStore~afterCreateManyListener SimpleStore#createMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1013 Container#event:afterDestroy SimpleStore~afterDestroyListener SimpleStore#destroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1120 Container#event:afterDestroyAll SimpleStore~afterDestroyAllListener SimpleStore#destroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1236 Container#event:afterFind SimpleStore~afterFindListener SimpleStore#find afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1348 Container#event:afterFindAll SimpleStore~afterFindAllListener SimpleStore#findAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1648 Container#event:afterUpdate SimpleStore~afterUpdateListener SimpleStore#update afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1740 Container#event:afterUpdateAll SimpleStore~afterUpdateAllListener SimpleStore#updateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1831 Container#event:afterUpdateMany SimpleStore~afterUpdateManyListener SimpleStore#updateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 752 Container#event:beforeCreate SimpleStore~beforeCreateListener SimpleStore#create beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 844 Container#event:beforeCreateMany SimpleStore~beforeCreateManyListener SimpleStore#createMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 988 Container#event:beforeDestroy SimpleStore~beforeDestroyListener SimpleStore#destroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1095 Container#event:beforeDestroyAll SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1211 Container#event:beforeFind SimpleStore~beforeFindListener SimpleStore#find beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1323 Container#event:beforeFindAll SimpleStore~beforeFindAllListener SimpleStore#findAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1622 Container#event:beforeUpdate SimpleStore~beforeUpdateListener SimpleStore#update beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1714 Container#event:beforeUpdateAll SimpleStore~beforeUpdateAllListener SimpleStore#updateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1806 Container#event:beforeUpdateMany SimpleStore~beforeUpdateManyListener SimpleStore#updateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll × Search results Close api.js-data.io • js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired js-data 3.0.6 js-data v3 Browser tests Node.js tests Community &amp; Maintainers always welcome - message in #jsdata-core-discuss Slack channel if you want to help with issues, improvements, tests, documentation, tutorials, adapters, etc.. There are several adapters that could use minor maintenance as well as new adapters to be written. JSData is a framework-agnostic, datastore-agnostic ORM for Node.js and the Browser. Adapters allow JSData to connect to various data sources such as Firebase, MySql, RethinkDB, MongoDB, localStorage, Redis, a REST API, etc. With JSData you can re-use your data modeling code between environments, keep your data layer intact when transitioning between app frameworks, and work with a unified data API on the server and the client. JSData employs conventions for rapid development, but allows for endless customization in order to meet your particular needs. Just getting started? Start with the JSData Getting Started Tutorial or explore the API Reference Documentation. Need help? Please post a question on Stack Overflow. This is the preferred method. You can also chat with folks on the Slack Channel. If you end up getting your question answered, please still consider consider posting your question to Stack Overflow (then possibly answering it yourself). Thanks! Want to contribute? Awesome! You can get started over at the Contributing guide. And thank you! License The MIT License (MIT) Copyright (c) 2014-2017 js-data project authors × Search results Close api.js-data.io • js-data.io "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Collection Collection new Collection(records, opts) An ordered set of Record instances. Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge String &lt;optional&gt; See Collection#commitOnMerge. idAttribute String &lt;optional&gt; See Collection#idAttribute. onConflict String &lt;optional&gt; \"merge\" See Collection#onConflict. mapper String &lt;optional&gt; See Collection#mapper. Details Since Source 3.0.0 Collection.js, line 73 Example Try it out // import { Collection, Record } from 'js-data'; const JSData = require('js-data'); const {Collection, Record} = JSData; console.log('Using JSData v' + JSData.version.full); const user1 = new Record({ id: 1 }); const user2 = new Record({ id: 2 }); const UserCollection = new Collection([user1, user2]); console.log(UserCollection.get(1) === user1); // import { Collection, Record } from 'js-data'; const JSData = require('js-data'); const {Collection, Record} = JSData; console.log('Using JSData v' + JSData.version.full); const user1 = new Record({ id: 1 }); const user2 = new Record({ id: 2 }); const UserCollection = new Collection([user1, user2]); console.log(UserCollection.get(1) === user1); Extends This class extends the Component class. Members commitOnMerge Whether to call Record#commit on records that are added to the collection and already exist in the collection. Details Type Default value Source Boolean true Collection.js, line 12 debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged emitRecordEvents Whether record events should bubble up and be emitted by the collection. Details Type Default value Source Boolean true Collection.js, line 22 idAttribute Field to be used as the unique identifier for records in this collection. Defaults to \"id\" unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String \"id\" Collection.js, line 31 index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 159 indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 173 mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Since Default value Source Mapper 3.0.0 null Collection.js, line 115 Example Try it out const JSData = require('js-data'); const {Collection, Mapper} = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar'; } } const myMapper = new MyMapperClass({ name: 'myMapper' }); const collection = new Collection(null, { mapper: myMapper }); const JSData = require('js-data'); const {Collection, Mapper} = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar'; } } const myMapper = new MyMapperClass({ name: 'myMapper' }); const collection = new Collection(null, { mapper: myMapper }); onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace skip Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Skip: Ignore new record, keep existing record. Details Type Default value Source String \"merge\" Collection.js, line 42 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Collection: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Collection class. Details Since Source 3.0.0 Collection.js, line 939 Example Try it out const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomCollectionClass extends Collection { foo () { return 'bar'; } static beep () { return 'boop'; } } const customCollection = new CustomCollectionClass(); console.log(customCollection.foo()); console.log(CustomCollectionClass.beep()); // Extend the class using alternate method. const OtherCollectionClass = Collection.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherCollection = new OtherCollectionClass(); console.log(otherCollection.foo()); console.log(OtherCollectionClass.beep()); // Extend the class, providing a custom constructor. function AnotherCollectionClass () { Collection.call(this); this.created_at = new Date().getTime(); } Collection.extend({ constructor: AnotherCollectionClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherCollection = new AnotherCollectionClass(); console.log(anotherCollection.created_at); console.log(anotherCollection.foo()); console.log(AnotherCollectionClass.beep()); const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomCollectionClass extends Collection { foo () { return 'bar'; } static beep () { return 'boop'; } } const customCollection = new CustomCollectionClass(); console.log(customCollection.foo()); console.log(CustomCollectionClass.beep()); // Extend the class using alternate method. const OtherCollectionClass = Collection.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherCollection = new OtherCollectionClass(); console.log(otherCollection.foo()); console.log(OtherCollectionClass.beep()); // Extend the class, providing a custom constructor. function AnotherCollectionClass () { Collection.call(this); this.created_at = new Date().getTime(); } Collection.extend({ constructor: AnotherCollectionClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherCollection = new AnotherCollectionClass(); console.log(anotherCollection.created_at); console.log(anotherCollection.foo()); console.log(AnotherCollectionClass.beep()); add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge Boolean &lt;optional&gt; true See Collection#commitOnMerge. noValidate Boolean &lt;optional&gt; See Record#noValidate. onConflict String &lt;optional&gt; See Collection#onConflict. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 207 afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 341 afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 353 beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 366 beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 378 beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 388 between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The result. Details Since Source 3.0.0 Collection.js, line 398 Examples // Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }); // Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }); // Same as above const users = collection.between([18], [30], { index: 'age' }); // Same as above const users = collection.between([18], [30], { index: 'age' }); createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Details Since Source 3.0.0 Collection.js, line 432 Examples // Index users by age collection.createIndex('age'); // Index users by age collection.createIndex('age'); // Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']); // Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source See 3.0.0 Collection.js, line 460 query Example Try it out const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); const collection = new Collection([ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = collection.filter((post) =&gt; post.id % 2 === 0); const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); const collection = new Collection([ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = collection.filter((post) =&gt; post.id % 2 === 0); forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 506 Example collection.forEach(function (record) { // do something }); collection.forEach(function (record) { // do something }); get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 524 getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 542 Examples // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = collection.getAll('draft', 'inReview', { index: 'status' }); // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = collection.getAll('draft', 'inReview', { index: 'status' }); // Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }); // Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }); getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 571 limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 587 Example const posts = collection.limit(10); const posts = collection.limit(10); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 606 Example const names = collection.map((user) =&gt; user.name); const names = collection.map((user) =&gt; user.name); mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 626 method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 329 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; prune(opts) Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options, passed to Collection#removeAll. Return value: Type Description Array The removed records, if any. Details Since Source 3.0.0 Collection.js, line 644 query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 656 Example // Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); // Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 677 reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 695 Example const totalVotes = collection.reduce((prev, record) =&gt; { return prev + record.upVotes + record.downVotes; }, 0); const totalVotes = collection.reduce((prev, record) =&gt; { return prev + record.upVotes + record.downVotes; }, 0); remove(idOrRecord, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description idOrRecord String | Number | Object | Record The primary key of the record to be removed, or a reference to the record that is to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 714 removeAll(queryOrRecords, opts) Remove from this collection the given records or the records selected by the given \"query\". Method parameters: Name Type Argument Default Description queryOrRecords Object | Array.&lt;Object&gt; | Array.&lt;Record&gt; &lt;optional&gt; {} Records to be removed or selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 748 skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 782 Example const posts = collection.skip(10); const posts = collection.skip(10); toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 801 unsaved() Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. Return value: Type Description Array The unsaved records, if any. Details Since Source 3.0.0 Collection.js, line 816 updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 827 updateIndexes(record) Updates all indexes in this collection for the provided record. Has no effect if the record is not in the collection. Method parameters: Name Type Description record Object TODO Details Since Source 3.0.0 Collection.js, line 845 Type Definitions addListener(The) Callback signature for the Collection#event:add event. Method parameters: Name Type Description The Record | Array.&lt;Record&gt; Record or Records that were added. Details Type Since Source See Function 3.0.0 Collection.js, line 895 Collection#event:add Collection#add Example function onAdd (recordOrRecords) { // do something } collection.on('add', onAdd); function onAdd (recordOrRecords) { // do something } collection.on('add', onAdd); changeListener(The, The) Callback signature for the Collection#event:change event. Method parameters: Name Type Description The Record Record that changed. The Object changes. Details Type Since Source See Function 3.0.0 Collection.js, line 869 Collection#event:change Example function onChange (record, changes) { // do something } collection.on('change', onChange); function onChange (record, changes) { // do something } collection.on('change', onChange); removeListener(Record) Callback signature for the Collection#event:remove event. Method parameters: Name Type Description Record Record | Array.&lt;Record&gt; or Records that were removed. Details Type Since Source See Function 3.0.0 Collection.js, line 922 Collection#event:remove Collection#remove Collection#removeAll Example function onRemove (recordsOrRecords) { // do something } collection.on('remove', onRemove); function onRemove (recordsOrRecords) { // do something } collection.on('remove', onRemove); Events add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll × Search results Close api.js-data.io • js-data.io "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Component Component new Component(opts) The base class from which all JSData components inherit some basic functionality. Typically you won't instantiate this class directly, but you may find it useful as an abstract class for your own components. See Component.extend for an example of using Component as a base class. import {Component} from 'js-data' Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description debug Boolean &lt;optional&gt; false See Component#debug. Return value: Type Description Component A new Component instance. Details Since Source 3.0.0 Component.js, line 4 Members debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Component: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Component class. Details Since Source 3.0.0 Component.js, line 68 Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomComponentClass extends Component { foo () { return 'bar'; } static beep () { return 'boop'; } } const customComponent = new CustomComponentClass(); console.log(customComponent.foo()); console.log(CustomComponentClass.beep()); // Extend the class using alternate method. const OtherComponentClass = Component.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherComponent = new OtherComponentClass(); console.log(otherComponent.foo()); console.log(OtherComponentClass.beep()); // Extend the class, providing a custom constructor. function AnotherComponentClass () { Component.call(this); this.created_at = new Date().getTime(); } Component.extend({ constructor: AnotherComponentClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherComponent = new AnotherComponentClass(); console.log(anotherComponent.created_at); console.log(anotherComponent.foo()); console.log(AnotherComponentClass.beep()); const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomComponentClass extends Component { foo () { return 'bar'; } static beep () { return 'boop'; } } const customComponent = new CustomComponentClass(); console.log(customComponent.foo()); console.log(CustomComponentClass.beep()); // Extend the class using alternate method. const OtherComponentClass = Component.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherComponent = new OtherComponentClass(); console.log(otherComponent.foo()); console.log(OtherComponentClass.beep()); // Extend the class, providing a custom constructor. function AnotherComponentClass () { Component.call(this); this.created_at = new Date().getTime(); } Component.extend({ constructor: AnotherComponentClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherComponent = new AnotherComponentClass(); console.log(anotherComponent.created_at); console.log(anotherComponent.foo()); console.log(AnotherComponentClass.beep()); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; × Search results Close api.js-data.io • js-data.io "},"Container.html":{"id":"Container.html","title":"Class: Container","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Container Container new Container(opts) The Container class is a place to define and store Mapper instances. Container makes it easy to manage your Mappers. Without a container, you need to manage Mappers yourself, including resolving circular dependencies among relations. All Mappers in a container share the same adapters, so you don't have to register adapters for every single Mapper. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description debug Boolean &lt;optional&gt; false See Component#debug. mapperClass Constructor &lt;optional&gt; See Container#mapperClass. mapperDefaults Object &lt;optional&gt; See Container#mapperDefaults. Details Since Source 3.0.0 Container.js, line 911 Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const {Container} = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // import { Container } from 'js-data'; const JSData = require('js-data'); const {Container} = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); Extends This class extends the Component class. Members _adapters The adapters registered with this Container, which are also shared by all Mappers in this Container. Details Type Since Source See Object 3.0.0 Container.js, line 941 Container#registerAdapter _mappers The the mappers in this container Details Type Since Source See Object 3.0.0 Container.js, line 954 Mapper debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged mapperClass Constructor function to use in Container#defineMapper to create new Mapper instances. Container#mapperClass should extend Mapper. By default Mapper is used to instantiate Mappers. Details Type Since Source See Constructor 3.0.0 Container.js, line 966 Mapper Example Try it out // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 1000 Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Container: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Container class. Details Since Source 3.0.0 Container.js, line 1331 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomContainerClass extends Container { foo () { return 'bar' } static beep () { return 'boop' } } const customContainer = new CustomContainerClass(); console.log(customContainer.foo()); console.log(CustomContainerClass.beep()); // Extend the class using alternate method. const OtherContainerClass = Container.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherContainer = new OtherContainerClass(); console.log(otherContainer.foo()); console.log(OtherContainerClass.beep()); // Extend the class, providing a custom constructor. function AnotherContainerClass () { Container.call(this); this.created_at = new Date().getTime(); } Container.extend({ constructor: AnotherContainerClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherContainer = new AnotherContainerClass(); console.log(anotherContainer.created_at); console.log(anotherContainer.foo()); console.log(AnotherContainerClass.beep()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomContainerClass extends Container { foo () { return 'bar' } static beep () { return 'boop' } } const customContainer = new CustomContainerClass(); console.log(customContainer.foo()); console.log(CustomContainerClass.beep()); // Extend the class using alternate method. const OtherContainerClass = Container.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherContainer = new OtherContainerClass(); console.log(otherContainer.foo()); console.log(OtherContainerClass.beep()); // Extend the class, providing a custom constructor. function AnotherContainerClass () { Container.call(this); this.created_at = new Date().getTime(); } Container.extend({ constructor: AnotherContainerClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherContainer = new AnotherContainerClass(); console.log(anotherContainer.created_at); console.log(anotherContainer.foo()); console.log(AnotherContainerClass.beep()); as(name) Return a container scoped to a particular mapper. Method parameters: Name Type Description name String Name of the Mapper. Return value: Type Description Object A container scoped to a particular mapper. Details Since Source 3.0.0 Container.js, line 1072 Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 8 Mapper#count Example // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); create(name, props, opts) Wrapper for Mapper#create. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object See Mapper#create. opts Object &lt;optional&gt; See Mapper#create. Fires: Container#event:beforeCreate Container#event:afterCreate Return value: Type Description Promise See Mapper#create. Details Since Source See 3.0.0 Container.js, line 84 Mapper#create Example // Create and save a new blog post import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.create('post', { title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'draft', ... } }); // Create and save a new blog post import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.create('post', { title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'draft', ... } }); createMany(name, records, opts) Wrapper for Mapper#createMany. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Record&gt; See Mapper#createMany. opts Object &lt;optional&gt; See Mapper#createMany. Fires: Container#event:beforeCreateMany Container#event:afterCreateMany Return value: Type Description Promise See Mapper#createMany. Details Since Source See 3.0.0 Container.js, line 165 Mapper#createMany Example // Create and save several new blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.createMany('post', [{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]); // { id: 1234, status: 'draft', ... } console.log(posts[1]); // { id: 1235, status: 'draft', ... } }); // Create and save several new blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.createMany('post', [{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]); // { id: 1234, status: 'draft', ... } console.log(posts[1]); // { id: 1235, status: 'draft', ... } }); createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 199 Mapper#createRecord Example // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper The newly created instance of Mapper. Details Since Source See 3.0.0 Container.js, line 1117 Container#as Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); destroy(name, id, opts) Wrapper for Mapper#destroy. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#destroy. opts Object &lt;optional&gt; See Mapper#destroy. Fires: Container#event:beforeDestroy Container#event:afterDestroy Return value: Type Description Promise See Mapper#destroy. Details Since Source See 3.0.0 Container.js, line 273 Mapper#destroy Example // Destroy a specific blog post import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.destroy('post', 1234).then(() =&gt; { // Blog post #1234 has been destroyed }); // Destroy a specific blog post import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.destroy('post', 1234).then(() =&gt; { // Blog post #1234 has been destroyed }); destroyAll(name, query, opts) Wrapper for Mapper#destroyAll. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#destroyAll. opts Object &lt;optional&gt; See Mapper#destroyAll. Fires: Container#event:beforeDestroyAll Container#event:afterDestroyAll Return value: Type Description Promise See Mapper#destroyAll. Details Since Source See 3.0.0 Container.js, line 351 Mapper#destroyAll Example // Destroy all \"draft\" blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.destroyAll('post', { status: 'draft' }).then(() =&gt; { // All \"draft\" blog posts have been destroyed }); // Destroy all \"draft\" blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.destroyAll('post', { status: 'draft' }).then(() =&gt; { // All \"draft\" blog posts have been destroyed }); emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); find(name, id, opts) Wrapper for Mapper#find. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#find. opts Object &lt;optional&gt; See Mapper#find. Fires: Container#event:beforeFind Container#event:afterFind Return value: Type Description Promise See Mapper#find. Details Since Source See 3.0.0 Container.js, line 429 Mapper#find Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.find('post', 1).then((post) =&gt; { console.log(post) // { id: 1, ...} }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.find('post', 1).then((post) =&gt; { console.log(post) // { id: 1, ...} }); findAll(name, query, opts) Wrapper for Mapper#createRecord. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#findAll. opts Object &lt;optional&gt; See Mapper#findAll. Fires: Container#event:beforeFindAll Container#event:afterFindAll Return value: Type Description Promise See Mapper#findAll. Details Since Source See 3.0.0 Container.js, line 506 Mapper#findAll Example // Find all \"published\" blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.findAll('post', { status: 'published' }).then((posts) =&gt; { console.log(posts); // [{ id: 1, ...}, ...] }); // Find all \"published\" blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.findAll('post', { status: 'published' }).then((posts) =&gt; { console.log(posts); // [{ id: 1, ...}, ...] }); getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 1189 getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 1206 getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 1223 getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1234 Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" getMapperByName(name) Return the mapper registered under the specified name. Doesn't throw error if mapper doesn't exist. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1264 Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 533 Mapper#getSchema is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 544 Mapper#is Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Container. Proxy for Component#on. If an event was emitted by a Mapper in the Container, then the name of the Mapper will be prepended to the arugments passed to the listener. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source Overrides 3.0.0 Container.js, line 1032 Component#on Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.on('foo', function (...args) { console.log(args.join(':')) }); store.defineMapper('user'); store.emit('foo', 'arg1', 'arg2'); store.getMapper('user').emit('foo', 'arg1', 'arg2'); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.on('foo', function (...args) { console.log(args.join(':')) }); store.defineMapper('user'); store.emit('foo', 'arg1', 'arg2'); store.getMapper('user').emit('foo', 'arg1', 'arg2'); registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 1291 Connecting to a data source Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 566 Mapper#sum Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); toJSON(name, records, opts) Wrapper for Mapper#toJSON. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Record | Array.&lt;Record&gt; See Mapper#toJSON. opts Object &lt;optional&gt; See Mapper#toJSON. Return value: Type Description Object | Array.&lt;Object&gt; See Mapper#toJSON. Details Since Source See 3.0.0 Container.js, line 591 Mapper#toJSON Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('person', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }); // \"foo\" is stripped by toJSON() console.log(store.toJSON('person', person)); // {\"id\":1,\"name\":\"John\"} store.defineMapper('personRelaxed', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } }, additionalProperties: true } }); const person2 = store.createRecord('personRelaxed', { id: 1, name: 'John', foo: 'bar' }); // \"foo\" is not stripped by toJSON console.log(store.toJSON('personRelaxed', person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('person', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); const person = store.createRecord('person', { id: 1, name: 'John', foo: 'bar' }); // \"foo\" is stripped by toJSON() console.log(store.toJSON('person', person)); // {\"id\":1,\"name\":\"John\"} store.defineMapper('personRelaxed', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } }, additionalProperties: true } }); const person2 = store.createRecord('personRelaxed', { id: 1, name: 'John', foo: 'bar' }); // \"foo\" is not stripped by toJSON console.log(store.toJSON('personRelaxed', person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} update(name, id, record, opts) Wrapper for Mapper#update. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number See Mapper#update. record Object See Mapper#update. opts Object &lt;optional&gt; See Mapper#update. Fires: Container#event:beforeUpdate Container#event:afterUpdate Return value: Type Description Promise See Mapper#update. Details Since Source Tutorials See 3.0.0 Container.js, line 687 Saving data Mapper#update Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.update('post', 1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'published', ... } }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.update('post', 1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'published', ... } }); updateAll(name, update, query, opts) Wrapper for Mapper#updateAll. Method parameters: Name Type Argument Description name String Name of the Mapper to target. update Object See Mapper#updateAll. query Object &lt;optional&gt; See Mapper#updateAll. opts Object &lt;optional&gt; See Mapper#updateAll. Fires: Container#event:beforeUpdateAll Container#event:afterUpdateAll Return value: Type Description Promise See Mapper#updateAll. Details Since Source See 3.0.0 Container.js, line 771 Mapper#updateAll Example // Turn all of John's blog posts into drafts. import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); const update = { status: draft: published_at: null }; const query = { userId: 1234 }; store.updateAll('post', update, query).then((posts) =&gt; { console.log(posts); // [...] }); // Turn all of John's blog posts into drafts. import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); const update = { status: draft: published_at: null }; const query = { userId: 1234 }; store.updateAll('post', update, query).then((posts) =&gt; { console.log(posts); // [...] }); updateMany(name, records, opts) Wrapper for Mapper#updateMany. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#updateMany. opts Object &lt;optional&gt; See Mapper#updateMany. Fires: Container#event:beforeUpdateMany Container#event:afterUpdateMany Return value: Type Description Promise See Mapper#updateMany. Details Since Source See 3.0.0 Container.js, line 852 Mapper#updateMany Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.updateMany('post', [ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts); // [...] }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.updateMany('post', [ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts); // [...] }); validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 881 Mapper#validate Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] Type Definitions afterCreateListener(name, props, opts, result) Callback signature for the Container#event:afterCreate event. Method parameters: Name Type Description name String The name argument received by Mapper#afterCreate. props Object The props argument received by Mapper#afterCreate. opts Object The opts argument received by Mapper#afterCreate. result Object The result argument received by Mapper#afterCreate. Details Type Since Source See Function 3.0.0 Container.js, line 66 Container#event:afterCreate Container#create Example function onAfterCreate (mapperName, props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); function onAfterCreate (mapperName, props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); afterCreateManyListener(name, records, opts, result) Callback signature for the Container#event:afterCreateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#afterCreateMany. records Object The records argument received by Mapper#afterCreateMany. opts Object The opts argument received by Mapper#afterCreateMany. result Object The result argument received by Mapper#afterCreateMany. Details Type Since Source See Function 3.0.0 Container.js, line 147 Container#event:afterCreateMany Container#createMany Example function onAfterCreateMany (mapperName, records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); function onAfterCreateMany (mapperName, records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); afterDestroyAllListener(name, query, opts, result) Callback signature for the Container#event:afterDestroyAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterDestroyAll. query Object The query argument received by Mapper#afterDestroyAll. opts Object The opts argument received by Mapper#afterDestroyAll. result Object The result argument received by Mapper#afterDestroyAll. Details Type Since Source See Function 3.0.0 Container.js, line 333 Container#event:afterDestroyAll Container#destroyAll Example function onAfterDestroyAll (mapperName, query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); function onAfterDestroyAll (mapperName, query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); afterDestroyListener(name, id, opts, result) Callback signature for the Container#event:afterDestroy event. Method parameters: Name Type Description name String The name argument received by Mapper#afterDestroy. id String | Number The id argument received by Mapper#afterDestroy. opts Object The opts argument received by Mapper#afterDestroy. result Object The result argument received by Mapper#afterDestroy. Details Type Since Source See Function 3.0.0 Container.js, line 255 Container#event:afterDestroy Container#destroy Example function onAfterDestroy (mapperName, id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); function onAfterDestroy (mapperName, id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); afterFindAllListener(name, query, opts, result) Callback signature for the Container#event:afterFindAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterFindAll. query Object The query argument received by Mapper#afterFindAll. opts Object The opts argument received by Mapper#afterFindAll. result Object The result argument received by Mapper#afterFindAll. Details Type Since Source See Function 3.0.0 Container.js, line 488 Container#event:afterFindAll Container#findAll Example function onAfterFindAll (mapperName, query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); function onAfterFindAll (mapperName, query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); afterFindListener(name, id, opts, result) Callback signature for the Container#event:afterFind event. Method parameters: Name Type Description name String The name argument received by Mapper#afterFind. id String | Number The id argument received by Mapper#afterFind. opts Object The opts argument received by Mapper#afterFind. result Object The result argument received by Mapper#afterFind. Details Type Since Source See Function 3.0.0 Container.js, line 411 Container#event:afterFind Container#find Example function onAfterFind (mapperName, id, opts, result) { // do something } store.on('afterFind', onAfterFind); function onAfterFind (mapperName, id, opts, result) { // do something } store.on('afterFind', onAfterFind); afterUpdateAllListener(name, props, query, opts, result) Callback signature for the Container#event:afterUpdateAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdateAll. props Object The props argument received by Mapper#afterUpdateAll. query Object The query argument received by Mapper#afterUpdateAll. opts Object The opts argument received by Mapper#afterUpdateAll. result Object The result argument received by Mapper#afterUpdateAll. Details Type Since Source See Function 3.0.0 Container.js, line 752 Container#event:afterUpdateAll Container#updateAll Example function onAfterUpdateAll (mapperName, props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); function onAfterUpdateAll (mapperName, props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); afterUpdateListener(name, id, props, opts, result) Callback signature for the Container#event:afterUpdate event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdate. id String | Number The id argument received by Mapper#afterUpdate. props Object The props argument received by Mapper#afterUpdate. opts Object The opts argument received by Mapper#afterUpdate. result Object The result argument received by Mapper#afterUpdate. Details Type Since Source See Function 3.0.0 Container.js, line 668 Container#event:afterUpdate Container#update Example function onAfterUpdate (mapperName, id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); function onAfterUpdate (mapperName, id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); afterUpdateManyListener(name, records, opts, result) Callback signature for the Container#event:afterUpdateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdateMany. records Object The records argument received by Mapper#afterUpdateMany. opts Object The opts argument received by Mapper#afterUpdateMany. result Object The result argument received by Mapper#afterUpdateMany. Details Type Since Source See Function 3.0.0 Container.js, line 834 Container#event:afterUpdateMany Container#updateMany Example function onAfterUpdateMany (mapperName, records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); function onAfterUpdateMany (mapperName, records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); beforeCreateListener(name, props, opts) Callback signature for the Container#event:beforeCreate event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeCreate. props Object The props argument received by Mapper#beforeCreate. opts Object The opts argument received by Mapper#beforeCreate. Details Type Since Source See Function 3.0.0 Container.js, line 41 Container#event:beforeCreate Container#create Example function onBeforeCreate (mapperName, props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); function onBeforeCreate (mapperName, props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); beforeCreateManyListener(name, records, opts) Callback signature for the Container#event:beforeCreateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeCreateMany. records Object The records argument received by Mapper#beforeCreateMany. opts Object The opts argument received by Mapper#beforeCreateMany. Details Type Since Source See Function 3.0.0 Container.js, line 122 Container#event:beforeCreateMany Container#createMany Example function onBeforeCreateMany (mapperName, records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); function onBeforeCreateMany (mapperName, records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); beforeDestroyAllListener(name, query, opts) Callback signature for the Container#event:beforeDestroyAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeDestroyAll. query Object The query argument received by Mapper#beforeDestroyAll. opts Object The opts argument received by Mapper#beforeDestroyAll. Details Type Since Source See Function 3.0.0 Container.js, line 308 Container#event:beforeDestroyAll Container#destroyAll Example function onBeforeDestroyAll (mapperName, query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); function onBeforeDestroyAll (mapperName, query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); beforeDestroyListener(name, id, opts) Callback signature for the Container#event:beforeDestroy event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeDestroy. id String | Number The id argument received by Mapper#beforeDestroy. opts Object The opts argument received by Mapper#beforeDestroy. Details Type Since Source See Function 3.0.0 Container.js, line 230 Container#event:beforeDestroy Container#destroy Example function onBeforeDestroy (mapperName, id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); function onBeforeDestroy (mapperName, id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); beforeFindAllListener(name, query, opts) Callback signature for the Container#event:beforeFindAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeFindAll. query Object The query argument received by Mapper#beforeFindAll. opts Object The opts argument received by Mapper#beforeFindAll. Details Type Since Source See Function 3.0.0 Container.js, line 463 Container#event:beforeFindAll Container#findAll Example function onBeforeFindAll (mapperName, query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); function onBeforeFindAll (mapperName, query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); beforeFindListener(name, id, opts) Callback signature for the Container#event:beforeFind event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeFind. id String | Number The id argument received by Mapper#beforeFind. opts Object The opts argument received by Mapper#beforeFind. Details Type Since Source See Function 3.0.0 Container.js, line 386 Container#event:beforeFind Container#find Example function onBeforeFind (mapperName, id, opts) { // do something } store.on('beforeFind', onBeforeFind); function onBeforeFind (mapperName, id, opts) { // do something } store.on('beforeFind', onBeforeFind); beforeUpdateAllListener(name, props, query, opts) Callback signature for the Container#event:beforeUpdateAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdateAll. props Object The props argument received by Mapper#beforeUpdateAll. query Object The query argument received by Mapper#beforeUpdateAll. opts Object The opts argument received by Mapper#beforeUpdateAll. Details Type Since Source See Function 3.0.0 Container.js, line 726 Container#event:beforeUpdateAll Container#updateAll Example function onBeforeUpdateAll (mapperName, props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); function onBeforeUpdateAll (mapperName, props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); beforeUpdateListener(name, id, props, opts) Callback signature for the Container#event:beforeUpdate event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdate. id String | Number The id argument received by Mapper#beforeUpdate. props Object The props argument received by Mapper#beforeUpdate. opts Object The opts argument received by Mapper#beforeUpdate. Details Type Since Source See Function 3.0.0 Container.js, line 642 Container#event:beforeUpdate Container#update Example function onBeforeUpdate (mapperName, id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); function onBeforeUpdate (mapperName, id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); beforeUpdateManyListener(name, records, opts) Callback signature for the Container#event:beforeUpdateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdateMany. records Object The records argument received by Mapper#beforeUpdateMany. opts Object The opts argument received by Mapper#beforeUpdateMany. Details Type Since Source See Function 3.0.0 Container.js, line 809 Container#event:beforeUpdateMany Container#updateMany Example function onBeforeUpdateMany (mapperName, records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); function onBeforeUpdateMany (mapperName, records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); Events afterCreate Fired during Container#create. See Container~afterCreateListener for how to listen for this event. Details Source See Container.js, line 58 Container~afterCreateListener Container#create afterCreateMany Fired during Container#createMany. See Container~afterCreateManyListener for how to listen for this event. Details Source See Container.js, line 139 Container~afterCreateManyListener Container#createMany afterDestroy Fired during Container#destroy. See Container~afterDestroyListener for how to listen for this event. Details Source See Container.js, line 247 Container~afterDestroyListener Container#destroy afterDestroyAll Fired during Container#destroyAll. See Container~afterDestroyAllListener for how to listen for this event. Details Source See Container.js, line 325 Container~afterDestroyAllListener Container#destroyAll afterFind Fired during Container#find. See Container~afterFindListener for how to listen for this event. Details Source See Container.js, line 403 Container~afterFindListener Container#find afterFindAll Fired during Container#findAll. See Container~afterFindAllListener for how to listen for this event. Details Source See Container.js, line 480 Container~afterFindAllListener Container#findAll afterUpdate Fired during Container#update. See Container~afterUpdateListener for how to listen for this event. Details Source See Container.js, line 660 Container~afterUpdateListener Container#update afterUpdateAll Fired during Container#updateAll. See Container~afterUpdateAllListener for how to listen for this event. Details Source See Container.js, line 744 Container~afterUpdateAllListener Container#updateAll afterUpdateMany Fired during Container#updateMany. See Container~afterUpdateManyListener for how to listen for this event. Details Source See Container.js, line 826 Container~afterUpdateManyListener Container#updateMany beforeCreate Fired during Container#create. See Container~beforeCreateListener for how to listen for this event. Details Source See Container.js, line 33 Container~beforeCreateListener Container#create beforeCreateMany Fired during Container#createMany. See Container~beforeCreateManyListener for how to listen for this event. Details Source See Container.js, line 114 Container~beforeCreateManyListener Container#createMany beforeDestroy Fired during Container#destroy. See Container~beforeDestroyListener for how to listen for this event. Details Source See Container.js, line 222 Container~beforeDestroyListener Container#destroy beforeDestroyAll Fired during Container#destroyAll. See Container~beforeDestroyAllListener for how to listen for this event. Details Source See Container.js, line 300 Container~beforeDestroyAllListener Container#destroyAll beforeFind Fired during Container#find. See Container~beforeFindListener for how to listen for this event. Details Source See Container.js, line 378 Container~beforeFindListener Container#find beforeFindAll Fired during Container#findAll. See Container~beforeFindAllListener for how to listen for this event. Details Source See Container.js, line 455 Container~beforeFindAllListener Container#findAll beforeUpdate Fired during Container#update. See Container~beforeUpdateListener for how to listen for this event. Details Source See Container.js, line 634 Container~beforeUpdateListener Container#update beforeUpdateAll Fired during Container#updateAll. See Container~beforeUpdateAllListener for how to listen for this event. Details Source See Container.js, line 718 Container~beforeUpdateAllListener Container#updateAll beforeUpdateMany Fired during Container#updateMany. See Container~beforeUpdateManyListener for how to listen for this event. Details Source See Container.js, line 801 Container~beforeUpdateManyListener Container#updateMany × Search results Close api.js-data.io • js-data.io "},"DataStore.html":{"id":"DataStore.html","title":"Class: DataStore","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: DataStore DataStore new DataStore(opts) The DataStore class is an extension of SimpleStore. Not only does DataStore manage mappers and store data in collections, it uses the LinkedCollection class to link related records together in memory. import { DataStore } from 'js-data'; Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See SimpleStore. Properties Name Type Argument Default Description collectionClass Boolean &lt;optional&gt; LinkedCollection See DataStore#collectionClass. debug Boolean &lt;optional&gt; false See Component#debug. unlinkOnDestroy Boolean &lt;optional&gt; true See DataStore#unlinkOnDestroy. usePendingFind Boolean | Function &lt;optional&gt; true See DataStore#usePendingFind. usePendingFindAll Boolean | Function &lt;optional&gt; true See DataStore#usePendingFindAll. Return value: Type Description DataStore Unspecified Details Since Source Tutorials See 3.0.0 DataStore.js, line 24 Components of JSData: DataStore Working with the DataStore Notes on using JSData in the Browser SimpleStore Example import { DataStore } from 'js-data'; import HttpAdapter from 'js-data-http'; const store = new DataStore(); // DataStore#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); // DataStore#as returns the store scoped to a particular Mapper. const UserStore = store.as('user'); // Call \"find\" on \"UserMapper\" (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a \"user\" record via the http adapter, but that's it // Call \"find\" on \"store\" targeting \"user\" (Stateful DataStore) return store.find('user', 1); // same as \"UserStore.find(1)\" }).then((user) =&gt; { // not only was a \"user\" record retrieved, but it was added to the // store's \"user\" collection const cachedUser = store.getCollection('user').get(1); console.log(user === cachedUser); // true }); import { DataStore } from 'js-data'; import HttpAdapter from 'js-data-http'; const store = new DataStore(); // DataStore#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); // DataStore#as returns the store scoped to a particular Mapper. const UserStore = store.as('user'); // Call \"find\" on \"UserMapper\" (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a \"user\" record via the http adapter, but that's it // Call \"find\" on \"store\" targeting \"user\" (Stateful DataStore) return store.find('user', 1); // same as \"UserStore.find(1)\" }).then((user) =&gt; { // not only was a \"user\" record retrieved, but it was added to the // store's \"user\" collection const cachedUser = store.getCollection('user').get(1); console.log(user === cachedUser); // true }); Extends This class extends the SimpleStore class. Members _adapters The adapters registered with this Container, which are also shared by all Mappers in this Container. Details Type Since Source See Object 3.0.0 Container.js, line 941 Container#registerAdapter Inherited From: Container#_adapters _mappers The the mappers in this container Details Type Since Source See Object 3.0.0 Container.js, line 954 Mapper Inherited From: Container#_mappers debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged mapperClass Constructor function to use in Container#defineMapper to create new Mapper instances. Container#mapperClass should extend Mapper. By default Mapper is used to instantiate Mappers. Details Type Since Source See Constructor 3.0.0 Container.js, line 966 Mapper Inherited From: Container#mapperClass Example Try it out // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 1000 Inherited From: Container#mapperDefaults Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); unlinkOnDestroy Whether in-memory relations should be unlinked from records after they are destroyed. Details Type Since Default value Source Boolean 3.0.0 true DataStore.js, line 12 usePendingFind Whether to use the pending query if a find request for the specified record is currently underway. Can be set to true, false, or to a function that returns true or false. Details Type Since Default value Source Boolean | Function 3.0.0 true SimpleStore.js, line 271 Inherited From: SimpleStore#usePendingFind usePendingFindAll Whether to use the pending query if a findAll request for the given query is currently underway. Can be set to true, false, or to a function that returns true or false. Details Type Since Default value Source Boolean | Function 3.0.0 true SimpleStore.js, line 283 Inherited From: SimpleStore#usePendingFindAll Methods &lt;static&gt; extend(props, classProps) Create a subclass of this DataStore: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this DataStore class. Details Since Source 3.0.0 DataStore.js, line 471 Example Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomDataStoreClass extends DataStore { foo () { return 'bar'; } static beep () { return 'boop'; } } const customDataStore = new CustomDataStoreClass(); console.log(customDataStore.foo()); console.log(CustomDataStoreClass.beep()); // Extend the class using alternate method. const OtherDataStoreClass = DataStore.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherDataStore = new OtherDataStoreClass(); console.log(otherDataStore.foo()); console.log(OtherDataStoreClass.beep()); // Extend the class, providing a custom constructor. function AnotherDataStoreClass () { DataStore.call(this); this.created_at = new Date().getTime(); } DataStore.extend({ constructor: AnotherDataStoreClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherDataStore = new AnotherDataStoreClass(); console.log(anotherDataStore.created_at); console.log(anotherDataStore.foo()); console.log(AnotherDataStoreClass.beep()); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomDataStoreClass extends DataStore { foo () { return 'bar'; } static beep () { return 'boop'; } } const customDataStore = new CustomDataStoreClass(); console.log(customDataStore.foo()); console.log(CustomDataStoreClass.beep()); // Extend the class using alternate method. const OtherDataStoreClass = DataStore.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherDataStore = new OtherDataStoreClass(); console.log(otherDataStore.foo()); console.log(OtherDataStoreClass.beep()); // Extend the class, providing a custom constructor. function AnotherDataStoreClass () { DataStore.call(this); this.created_at = new Date().getTime(); } DataStore.extend({ constructor: AnotherDataStoreClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherDataStore = new AnotherDataStoreClass(); console.log(anotherDataStore.created_at); console.log(anotherDataStore.foo()); console.log(AnotherDataStoreClass.beep()); add(name, data, opts) Wrapper for Collection#add. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; See Collection#add. opts Object &lt;optional&gt; Configuration options. See Collection#add. Fires: SimpleStore#event:add Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; See Collection#add. Details Since Source See 3.0.0 SimpleStore.js, line 13 Collection#add Collection#add Inherited From: SimpleStore#add Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); // Add one book to the in-memory store: store.add('book', { id: 1, title: 'Respect your Data' }); // Add multiple books to the in-memory store: store.add('book', [ { id: 2, title: 'Easy data recipes' }, { id: 3, title: 'Active Record 101' } ]); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); // Add one book to the in-memory store: store.add('book', { id: 1, title: 'Respect your Data' }); // Add multiple books to the in-memory store: store.add('book', [ { id: 2, title: 'Easy data recipes' }, { id: 3, title: 'Active Record 101' } ]); addToCache(name, data, opts) This method takes the data received from SimpleStore#find, SimpleStore#findAll, SimpleStore#update, etc., and adds the data to the store. You don't need to call this method directly. If you're using the http adapter and your response data is in an unexpected format, you may need to override this method so the right data gets added to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. data * Data from which data should be selected for add. opts Object &lt;optional&gt; Configuration options. Details Source SimpleStore.js, line 441 Inherited From: SimpleStore#addToCache Examples const store = new SimpleStore({ addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return SimpleStore.prototype.addToCache.call(this, mapperName, data, opts); } }); const store = new SimpleStore({ addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return SimpleStore.prototype.addToCache.call(this, mapperName, data, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return super.addToCache(mapperName, data, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return super.addToCache(mapperName, data, opts); } } const store = new MyStore(); as(name) Return the store scoped to a particular mapper/collection pair. Method parameters: Name Type Description name String Name of the Mapper. Return value: Type Description Object The store, scoped to a particular Mapper/Collection pair. Details Since Source 3.0.0 SimpleStore.js, line 487 Inherited From: SimpleStore#as Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); between(name, leftKeys, rightKeys, opts) Wrapper for Collection#between. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. leftKeys Array See Collection#between. rightKeys Array See Collection#between. opts Object &lt;optional&gt; Configuration options. See Collection#between. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; See Collection#between. Details Since Source See 3.0.0 SimpleStore.js, line 44 Collection#between Collection#between Inherited From: SimpleStore#between Examples // Get all users ages 18 to 30 const users = store.between('user', 18, 30, { index: 'age' }); // Get all users ages 18 to 30 const users = store.between('user', 18, 30, { index: 'age' }); // Same as above const users = store.between('user', [18], [30], { index: 'age' }); // Same as above const users = store.between('user', [18], [30], { index: 'age' }); cachedFind(name, id, opts) Retrieve a cached find result, if any. This method is called during SimpleStore#find to determine if Mapper#find needs to be called. If this method returns undefined then Mapper#find will be called. Otherwise SimpleStore#find will immediately resolve with the return value of this method. When using SimpleStore in the browser, you can override this method to implement your own cache-busting strategy. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find. id String | Number The id argument passed to SimpleStore#find. opts Object The opts argument passed to SimpleStore#find. Details Since Source 3.0.0 SimpleStore.js, line 541 Inherited From: SimpleStore#cachedFind Examples const store = new SimpleStore({ cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFind.call(this, mapperName, id, opts); } }); const store = new SimpleStore({ cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFind.call(this, mapperName, id, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return super.cachedFind(mapperName, id, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return super.cachedFind(mapperName, id, opts); } } const store = new MyStore(); cachedFindAll(name, hash, opts) Retrieve a cached findAll result, if any. This method is called during SimpleStore#findAll to determine if Mapper#findAll needs to be called. If this method returns undefined then Mapper#findAll will be called. Otherwise SimpleStore#findAll will immediately resolve with the return value of this method. When using SimpleStore in the browser, you can override this method to implement your own cache-busting strategy. Method parameters: Name Type Description name String The name argument passed to SimpleStore#findAll. hash String The result of calling SimpleStore#hashQuery on the query argument passed to SimpleStore#findAll. opts Object The opts argument passed to SimpleStore#findAll. Details Since Source 3.0.0 SimpleStore.js, line 587 Inherited From: SimpleStore#cachedFindAll Examples const store = new SimpleStore({ cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFindAll.call(this, mapperName, hash, opts); } }); const store = new SimpleStore({ cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFindAll.call(this, mapperName, hash, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return super.cachedFindAll(mapperName, hash, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return super.cachedFindAll(mapperName, hash, opts); } } const store = new MyStore(); cacheFind(name, data, id, opts) Mark a Mapper#find result as cached by adding an entry to SimpleStore#_completedQueries. By default, once a find entry is added it means subsequent calls to the same Resource with the same id argument will immediately resolve with the result of calling SimpleStore#get instead of delegating to Mapper#find. As part of implementing your own caching strategy, you may choose to override this method. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find. data * The result to cache. id String | Number The id argument passed to SimpleStore#find. opts Object The opts argument passed to SimpleStore#find. Details Since Source 3.0.0 SimpleStore.js, line 634 Inherited From: SimpleStore#cacheFind Examples const store = new SimpleStore({ cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return SimpleStore.prototype.cacheFind.call(this, mapperName, data, id, opts); } }); const store = new SimpleStore({ cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return SimpleStore.prototype.cacheFind.call(this, mapperName, data, id, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return super.cacheFind(mapperName, data, id, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return super.cacheFind(mapperName, data, id, opts); } } const store = new MyStore(); cacheFindAll(name, data, hash, opts) Mark a Mapper#findAll result as cached by adding an entry to SimpleStore#_completedQueries. By default, once a findAll entry is added it means subsequent calls to the same Resource with the same query argument will immediately resolve with the result of calling SimpleStore#filter instead of delegating to Mapper#findAll. As part of implementing your own caching strategy, you may choose to override this method. Method parameters: Name Type Description name String The name argument passed to SimpleStore#findAll. data * The result to cache. hash String The result of calling SimpleStore#hashQuery on the query argument passed to SimpleStore#findAll. opts Object The opts argument passed to SimpleStore#findAll. Details Since Source 3.0.0 SimpleStore.js, line 683 Inherited From: SimpleStore#cacheFindAll Examples const store = new SimpleStore({ cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return SimpleStore.prototype.cachedFindAll.call(this, mapperName, data, hash, opts); } }); const store = new SimpleStore({ cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return SimpleStore.prototype.cachedFindAll.call(this, mapperName, data, hash, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return super.cachedFindAll(mapperName, data, hash, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return super.cachedFindAll(mapperName, data, hash, opts); } } const store = new MyStore(); clear() Remove all records from the in-memory store and reset SimpleStore#_completedQueries. Return value: Type Description Object Object containing all records that were in the store. Details Since Source See 3.0.0 SimpleStore.js, line 733 SimpleStore#remove SimpleStore#removeAll Inherited From: SimpleStore#clear count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 8 Mapper#count Inherited From: Container#count Example // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); create(name, record, opts) Wrapper for Mapper#create. Adds the created record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. record Object Passed to Mapper#create. opts Object &lt;optional&gt; Passed to Mapper#create. See Mapper#create for more configuration options. Fires: SimpleStore#event:beforeCreate SimpleStore#event:afterCreate SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the create. Details Since Source 3.0.0 SimpleStore.js, line 803 Inherited From: SimpleStore#create Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book {\"author_id\":1234,...} store.create('book', { author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }).then((book) =&gt; { console.log(book.id); // 120392 console.log(book.title); // \"Respect your Data\" }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book {\"author_id\":1234,...} store.create('book', { author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }).then((book) =&gt; { console.log(book.id); // 120392 console.log(book.title); // \"Respect your Data\" }); createIndex(name, name, fieldList) Wrapper for Collection#createIndex. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. name String See Collection#createIndex. fieldList Array.&lt;String&gt; &lt;optional&gt; See Collection#createIndex. Details Since Source See 3.0.0 SimpleStore.js, line 67 Collection#createIndex Collection#createIndex Inherited From: SimpleStore#createIndex Examples // Index users by age store.createIndex('user', 'age'); // Index users by age store.createIndex('user', 'age'); // Index users by status and role store.createIndex('user', 'statusAndRole', ['status', 'role']); // Index users by status and role store.createIndex('user', 'statusAndRole', ['status', 'role']); createMany(name, records, opts) Wrapper for Mapper#createMany. Adds the created records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array Passed to Mapper#createMany. opts Object &lt;optional&gt; Passed to Mapper#createMany. See Mapper#createMany for more configuration options. Fires: SimpleStore#event:beforeCreateMany SimpleStore#event:afterCreateMany SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the create. Details Since Source 3.0.0 SimpleStore.js, line 895 Inherited From: SimpleStore#createMany Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book [{\"author_id\":1234,...},{...}] store.createMany('book', [{ author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }, { author_id: 1234, edition: 'Second Edition', title: 'Respect your Data' }]).then((books) =&gt; { console.log(books[0].id); // 142394 console.log(books[0].title); // \"Respect your Data\" }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book [{\"author_id\":1234,...},{...}] store.createMany('book', [{ author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }, { author_id: 1234, edition: 'Second Edition', title: 'Respect your Data' }]).then((books) =&gt; { console.log(books[0].id); // 142394 console.log(books[0].title); // \"Respect your Data\" }); createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 199 Mapper#createRecord Inherited From: Container#createRecord Example // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper The newly created instance of Mapper. Details Since Source See 3.0.0 Container.js, line 1117 Container#as Inherited From: Container#defineMapper Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); destroy(name, id, opts) Wrapper for Mapper#destroy. Removes any destroyed record from the in-memory store. Clears out any SimpleStore#_completedQueries entries associated with the provided id. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#destroy. opts Object &lt;optional&gt; Passed to Mapper#destroy. See Mapper#destroy for more configuration options. Fires: SimpleStore#event:beforeDestroy SimpleStore#event:afterDestroy SimpleStore#event:remove Return value: Type Description Promise Resolves when the destroy operation completes. Details Since Source 3.0.0 SimpleStore.js, line 1039 Inherited From: SimpleStore#destroy Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is no longer in the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is no longer in the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); destroyAll(name, query, opts) Wrapper for Mapper#destroyAll. Removes any destroyed records from the in-memory store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper#destroyAll. opts Object &lt;optional&gt; Passed to Mapper#destroyAll. See Mapper#destroyAll for more configuration options. Fires: SimpleStore#event:beforeDestroyAll SimpleStore#event:afterDestroyAll SimpleStore#event:remove Return value: Type Description Promise Resolves when the delete completes. Details Since Source 3.0.0 SimpleStore.js, line 1146 Inherited From: SimpleStore#destroyAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is gone from the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is gone from the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); filter(name, queryOrFn, thisArg) Wrapper for Collection#filter. Method parameters: Name Type Argument Default Description name String | Number Name of the Mapper to target. queryOrFn Object | Function &lt;optional&gt; {} See Collection#filter. thisArg Object &lt;optional&gt; See Collection#filter. Return value: Type Description Array See Collection#filter. Details Since Source See 3.0.0 SimpleStore.js, line 88 Collection#filter Collection#filter Inherited From: SimpleStore#filter Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = store.filter('post', { where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = store.filter('post', function (post) { return post.id % 2 === 0 }); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = store.filter('post', { where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = store.filter('post', function (post) { return post.id % 2 === 0 }); find(name, id, opts) Wrapper for Mapper#find. Adds any found record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#find. opts Object &lt;optional&gt; Passed to Mapper#find. Properties Name Type Argument Description force Boolean &lt;optional&gt; Bypass cacheFind usePendingFind Boolean | Function &lt;optional&gt; See SimpleStore#usePendingFind Fires: SimpleStore#event:beforeFind SimpleStore#event:afterFind SimpleStore#event:add Return value: Type Description Promise Resolves with the result, if any. Details Since Source 3.0.0 SimpleStore.js, line 1262 Inherited From: SimpleStore#find Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // GET /book/1234 store.find('book', 1234).then((book) =&gt; { // The book record is now in the in-memory store console.log(store.get('book', 1234) === book); // true }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // GET /book/1234 store.find('book', 1234).then((book) =&gt; { // The book record is now in the in-memory store console.log(store.get('book', 1234) === book); // true }); findAll(name, query, opts) Wrapper for Mapper#findAll. Adds any found records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper.findAll. opts Object &lt;optional&gt; Passed to Mapper.findAll. Properties Name Type Argument Description force Boolean &lt;optional&gt; Bypass cacheFindAll usePendingFindAll Boolean | Function &lt;optional&gt; See SimpleStore#usePendingFindAll Fires: SimpleStore#event:beforeFindAll SimpleStore#event:afterFindAll SimpleStore#event:add Return value: Type Description Promise Resolves with the result, if any. Details Since Source 3.0.0 SimpleStore.js, line 1374 Inherited From: SimpleStore#findAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('movie'); // Since this example uses the http adapter, we'll get something like: // // GET /movie?rating=PG store.find('movie', { rating: 'PG' }).then((movies) =&gt; { // The movie records are now in the in-memory store console.log(store.filter('movie')); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('movie'); // Since this example uses the http adapter, we'll get something like: // // GET /movie?rating=PG store.find('movie', { rating: 'PG' }).then((movies) =&gt; { // The movie records are now in the in-memory store console.log(store.filter('movie')); }); get(name, id) Wrapper for Collection#get. Method parameters: Name Type Description name String | Number Name of the Mapper to target. id String | Number See Collection#get. Return value: Type Description Object | Record See Collection#get. Details Since Source See 3.0.0 SimpleStore.js, line 129 Collection#get Collection#get Inherited From: SimpleStore#get Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); console.log(store.get('post', 1)); // {...} console.log(store.get('post', 2)); // undefined const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); console.log(store.get('post', 1)); // {...} console.log(store.get('post', 2)); // undefined getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 1189 Inherited From: Container#getAdapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 1206 Inherited From: Container#getAdapterName getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 1223 Inherited From: Container#getAdapters getAll(name, keyList, opts) Wrapper for Collection#getAll. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. keyList Array &lt;optional&gt; &lt;repeatable&gt; See Collection#getAll. opts Object &lt;optional&gt; See Collection#getAll. Return value: Type Description Array See Collection#getAll. Details Since Source See 3.0.0 SimpleStore.js, line 156 Collection#getAll Collection#getAll Inherited From: SimpleStore#getAll Examples // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = store.getAll('post', 'draft', 'inReview', { index: 'status' }); // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = store.getAll('post', 'draft', 'inReview', { index: 'status' }); // Same as above const posts = store.getAll('post', ['draft'], ['inReview'], { index: 'status' }); // Same as above const posts = store.getAll('post', ['draft'], ['inReview'], { index: 'status' }); getCollection(name) Return the Collection with the given name, if for some reason you need a direct reference to the collection. Method parameters: Name Type Description name String Name of the Collection to retrieve. Throws: Thrown if the specified Collection does not exist. Type Error Return value: Type Description Collection Unspecified Details Since Source 3.0.0 SimpleStore.js, line 1437 Inherited From: SimpleStore#getCollection getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1234 Inherited From: Container#getMapper Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" getMapperByName(name) Return the mapper registered under the specified name. Doesn't throw error if mapper doesn't exist. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1264 Inherited From: Container#getMapperByName Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 533 Mapper#getSchema Inherited From: Container#getSchema hashQuery(name, query) Hashing function used to cache SimpleStore#find and SimpleStore#findAll requests. This method simply JSONifies the query argument passed to SimpleStore#find or SimpleStore#findAll. Override this method for custom hashing behavior. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find or SimpleStore#findAll. query Object The query argument passed to SimpleStore#find or SimpleStore#findAll. Return value: Type Description String The JSONified query. Details Since Source 3.0.0 SimpleStore.js, line 1456 Inherited From: SimpleStore#hashQuery is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 544 Mapper#is Inherited From: Container#is Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this SimpleStore. Proxy for Container#on. If an event was emitted by a Mapper or Collection in the SimpleStore, then the name of the Mapper or Collection will be prepended to the arugments passed to the provided event handler. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Source SimpleStore.js, line 391 Inherited From: SimpleStore#on Examples // Listen for all \"afterCreate\" events in a SimpleStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a SimpleStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection store.on('add', (mapperName, records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection store.on('add', (mapperName, records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record store.on('change', (mapperName, record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record store.on('change', (mapperName, record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; prune(opts) Wrapper for Collection#prune. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; See Collection#prune. Return value: Type Description Array See Collection#prune. Details Since Source See 3.0.0 SimpleStore.js, line 178 Collection#prune Collection#prune Inherited From: SimpleStore#prune query(name) Wrapper for Collection#query. Method parameters: Name Type Description name String | Number Name of the Mapper to target. Return value: Type Description Query See Collection#query. Details Since Source See 3.0.0 SimpleStore.js, line 190 Collection#query Collection#query Inherited From: SimpleStore#query Example // Grab page 2 of users between ages 18 and 30 store.query('user') .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); // Grab page 2 of users between ages 18 and 30 store.query('user') .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 1291 Connecting to a data source Inherited From: Container#registerAdapter Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); remove(name, id, opts) Wrapper for Collection#remove. Removes the specified Record from the store. Method parameters: Name Type Argument Description name String The name of the Collection to target. id String | Number The primary key of the Record to remove. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Fires: SimpleStore#event:remove Return value: Type Description Record The removed Record, if any. Details Since Source See 3.0.0 SimpleStore.js, line 1480 Collection#add Collection#add Inherited From: SimpleStore#remove Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); console.log(store.getAll('book').length); store.add('book', { id: 1234 }); console.log(store.getAll('book').length); store.remove('book', 1234); console.log(store.getAll('book').length); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); console.log(store.getAll('book').length); store.add('book', { id: 1234 }); console.log(store.getAll('book').length); store.remove('book', 1234); console.log(store.getAll('book').length); removeAll(name, query, opts) Wrapper for Collection#removeAll. Removes the selected Records from the store. Method parameters: Name Type Argument Default Description name String The name of the Collection to target. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Fires: SimpleStore#event:remove Return value: Type Description Record The removed Records, if any. Details Since Source See 3.0.0 SimpleStore.js, line 1517 Collection#add Collection#add Inherited From: SimpleStore#removeAll Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('movie'); console.log(store.getAll('movie').length); store.add('movie', [{ id: 3, rating: 'R' }, { id: 4, rating: 'PG-13' }); console.log(store.getAll('movie').length); store.removeAll('movie', { rating: 'R' }); console.log(store.getAll('movie').length); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('movie'); console.log(store.getAll('movie').length); store.add('movie', [{ id: 3, rating: 'R' }, { id: 4, rating: 'PG-13' }); console.log(store.getAll('movie').length); store.removeAll('movie', { rating: 'R' }); console.log(store.getAll('movie').length); removeRelated(name, records, opts) Remove from the store Records that are related to the provided Record(s). Method parameters: Name Type Argument Description name String The name of the Collection to target. records Record | Array.&lt;Record&gt; Records whose relations are to be removed. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record(s) to remove from the store. Fires: SimpleStore#event:remove Details Since Source 3.0.0 SimpleStore.js, line 1563 Inherited From: SimpleStore#removeRelated sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 566 Mapper#sum Inherited From: Container#sum Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); toJSON(name, opts) Wrapper for Collection#toJSON. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. opts Object &lt;optional&gt; See Collection#toJSON. Return value: Type Description Array See Collection#toJSON. Details Since Source See 3.0.0 SimpleStore.js, line 210 Collection#toJSON Collection#toJSON Inherited From: SimpleStore#toJSON Example store.defineMapper('post', { schema: { properties: { id: { type: 'number' }, title: { type: 'string' } } } }); store.add('post', [ { id: 1, status: 'published', title: 'Respect your Data' }, { id: 2, status: 'draft', title: 'Connecting to a data source' } ]); console.log(store.toJSON('post')); const draftsJSON = store.query('post') .filter({ status: 'draft' }) .mapCall('toJSON') .run(); store.defineMapper('post', { schema: { properties: { id: { type: 'number' }, title: { type: 'string' } } } }); store.add('post', [ { id: 1, status: 'published', title: 'Respect your Data' }, { id: 2, status: 'draft', title: 'Connecting to a data source' } ]); console.log(store.toJSON('post')); const draftsJSON = store.query('post') .filter({ status: 'draft' }) .mapCall('toJSON') .run(); unsaved() Wrapper for Collection#unsaved. Return value: Type Description Array See Collection#unsaved. Details Since Source See 3.0.0 SimpleStore.js, line 242 Collection#unsaved Collection#unsaved Inherited From: SimpleStore#unsaved update(name, id, record, opts) Wrapper for Mapper#update. Adds the updated Record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#update. record Object Passed to Mapper#update. opts Object &lt;optional&gt; Passed to Mapper#update. See Mapper#update for more configuration options. Fires: SimpleStore#event:beforeUpdate SimpleStore#event:afterUpdate SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source 3.0.0 SimpleStore.js, line 1675 Inherited From: SimpleStore#update Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post/1234 {\"status\":\"published\"} store.update('post', 1, { status: 'published' }).then((post) =&gt; { // The post record has also been updated in the in-memory store console.log(store.get('post', 1234)); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post/1234 {\"status\":\"published\"} store.update('post', 1, { status: 'published' }).then((post) =&gt; { // The post record has also been updated in the in-memory store console.log(store.get('post', 1234)); }); updateAll(name, props, query, opts) Wrapper for Mapper#updateAll. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object Passed to Mapper#updateAll. query Object &lt;optional&gt; Passed to Mapper#updateAll. opts Object &lt;optional&gt; Passed to Mapper#updateAll. See Mapper#updateAll for more configuration options. Fires: SimpleStore#event:beforeUpdateAll SimpleStore#event:afterUpdateAll SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source 3.0.0 SimpleStore.js, line 1767 Inherited From: SimpleStore#updateAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post?author_id=1234 {\"status\":\"published\"} store.updateAll('post', { author_id: 1234 }, { status: 'published' }).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.filter('posts', { author_id: 1234 })); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post?author_id=1234 {\"status\":\"published\"} store.updateAll('post', { author_id: 1234 }, { status: 'published' }).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.filter('posts', { author_id: 1234 })); }); updateMany(name, records, opts) Wrapper for Mapper#updateMany. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; Passed to Mapper#updateMany. opts Object &lt;optional&gt; Passed to Mapper#updateMany. See Mapper#updateMany for more configuration options. Fires: SimpleStore#event:beforeUpdateMany SimpleStore#event:afterUpdateMany SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source 3.0.0 SimpleStore.js, line 1857 Inherited From: SimpleStore#updateMany Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post [{\"id\":3,status\":\"published\"},{\"id\":4,status\":\"published\"}] store.updateMany('post', [ { id: 3, status: 'published' }, { id: 4, status: 'published' } ]).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.getAll('post', 3, 4)); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post [{\"id\":3,status\":\"published\"},{\"id\":4,status\":\"published\"}] store.updateMany('post', [ { id: 3, status: 'published' }, { id: 4, status: 'published' } ]).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.getAll('post', 3, 4)); }); validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 881 Mapper#validate Inherited From: Container#validate Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] Events add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany Inherited From: SimpleStore#event:add afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 777 SimpleStore~afterCreateListener SimpleStore#create Inherited From: SimpleStore#event:afterCreate afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 869 SimpleStore~afterCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:afterCreateMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 1013 SimpleStore~afterDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:afterDestroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1120 SimpleStore~afterDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:afterDestroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1236 SimpleStore~afterFindListener SimpleStore#find Inherited From: SimpleStore#event:afterFind afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1348 SimpleStore~afterFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:afterFindAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1648 SimpleStore~afterUpdateListener SimpleStore#update Inherited From: SimpleStore#event:afterUpdate afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1740 SimpleStore~afterUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:afterUpdateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1831 SimpleStore~afterUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:afterUpdateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source See SimpleStore.js, line 752 SimpleStore~beforeCreateListener SimpleStore#create Inherited From: SimpleStore#event:beforeCreate beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 844 SimpleStore~beforeCreateManyListener SimpleStore#createMany Inherited From: SimpleStore#event:beforeCreateMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source See SimpleStore.js, line 988 SimpleStore~beforeDestroyListener SimpleStore#destroy Inherited From: SimpleStore#event:beforeDestroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1095 SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll Inherited From: SimpleStore#event:beforeDestroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source See SimpleStore.js, line 1211 SimpleStore~beforeFindListener SimpleStore#find Inherited From: SimpleStore#event:beforeFind beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1323 SimpleStore~beforeFindAllListener SimpleStore#findAll Inherited From: SimpleStore#event:beforeFindAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source See SimpleStore.js, line 1622 SimpleStore~beforeUpdateListener SimpleStore#update Inherited From: SimpleStore#event:beforeUpdate beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source See SimpleStore.js, line 1714 SimpleStore~beforeUpdateAllListener SimpleStore#updateAll Inherited From: SimpleStore#event:beforeUpdateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source See SimpleStore.js, line 1806 SimpleStore~beforeUpdateManyListener SimpleStore#updateMany Inherited From: SimpleStore#event:beforeUpdateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener Inherited From: SimpleStore#event:change remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll Inherited From: SimpleStore#event:remove × Search results Close api.js-data.io • js-data.io "},"LinkedCollection.html":{"id":"LinkedCollection.html","title":"Class: LinkedCollection","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: LinkedCollection LinkedCollection new LinkedCollection(records, opts) Extends Collection. Used by a DataStore to implement an Identity Map. import {LinkedCollection} from 'js-data' Method parameters: Name Type Argument Description records Array &lt;optional&gt; Initial set of records to insert into the collection. See Collection. opts Object &lt;optional&gt; Configuration options. See Collection. Return value: Type Description Mapper Unspecified Details Source LinkedCollection.js, line 7 Extends This class extends the Collection class. Members commitOnMerge Whether to call Record#commit on records that are added to the collection and already exist in the collection. Details Type Default value Source Boolean true Collection.js, line 12 Inherited From: Collection#commitOnMerge debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged emitRecordEvents Whether record events should bubble up and be emitted by the collection. Details Type Default value Source Boolean true Collection.js, line 22 Inherited From: Collection#emitRecordEvents idAttribute Field to be used as the unique identifier for records in this collection. Defaults to \"id\" unless Collection#mapper is set, in which case this will default to Mapper#idAttribute. Details Type Default value Source String \"id\" Collection.js, line 31 Inherited From: Collection#idAttribute index The main index, which uses @{link Collection#recordId} as the key. Details Type Source Index Collection.js, line 159 Inherited From: Collection#index indexes Object that holds the secondary indexes of this collection. Details Type Source Object.&lt;string, Index&gt; Collection.js, line 173 Inherited From: Collection#indexes mapper Default Mapper for this collection. Optional. If a Mapper is provided, then the collection will use the Mapper#idAttribute setting, and will wrap records in Mapper#recordClass. Details Type Since Default value Source Mapper 3.0.0 null Collection.js, line 115 Inherited From: Collection#mapper Example Try it out const JSData = require('js-data'); const {Collection, Mapper} = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar'; } } const myMapper = new MyMapperClass({ name: 'myMapper' }); const collection = new Collection(null, { mapper: myMapper }); const JSData = require('js-data'); const {Collection, Mapper} = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar'; } } const myMapper = new MyMapperClass({ name: 'myMapper' }); const collection = new Collection(null, { mapper: myMapper }); onConflict What to do when inserting a record into this Collection that shares a primary key with a record already in this Collection. Possible values: merge replace skip Merge: Recursively shallow copy properties from the new record onto the existing record. Replace: Shallow copy top-level properties from the new record onto the existing record. Any top-level own properties of the existing record that are not on the new record will be removed. Skip: Ignore new record, keep existing record. Details Type Default value Source String \"merge\" Collection.js, line 42 Inherited From: Collection#onConflict Methods &lt;static&gt; extend(props, classProps) Create a subclass of this LinkedCollection: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this LinkedCollection class. Details Since Source 3.0.0 LinkedCollection.js, line 126 Example Try it out const JSData = require('js-data'); const { LinkedCollection } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomLinkedCollectionClass extends LinkedCollection { foo () { return 'bar'; } static beep () { return 'boop'; } } const customLinkedCollection = new CustomLinkedCollectionClass(); console.log(customLinkedCollection.foo()); console.log(CustomLinkedCollectionClass.beep()); // Extend the class using alternate method. const OtherLinkedCollectionClass = LinkedCollection.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherLinkedCollection = new OtherLinkedCollectionClass(); console.log(otherLinkedCollection.foo()); console.log(OtherLinkedCollectionClass.beep()); // Extend the class, providing a custom constructor. function AnotherLinkedCollectionClass () { LinkedCollection.call(this); this.created_at = new Date().getTime(); } LinkedCollection.extend({ constructor: AnotherLinkedCollectionClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherLinkedCollection = new AnotherLinkedCollectionClass(); console.log(anotherLinkedCollection.created_at); console.log(anotherLinkedCollection.foo()); console.log(AnotherLinkedCollectionClass.beep()); const JSData = require('js-data'); const { LinkedCollection } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomLinkedCollectionClass extends LinkedCollection { foo () { return 'bar'; } static beep () { return 'boop'; } } const customLinkedCollection = new CustomLinkedCollectionClass(); console.log(customLinkedCollection.foo()); console.log(CustomLinkedCollectionClass.beep()); // Extend the class using alternate method. const OtherLinkedCollectionClass = LinkedCollection.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherLinkedCollection = new OtherLinkedCollectionClass(); console.log(otherLinkedCollection.foo()); console.log(OtherLinkedCollectionClass.beep()); // Extend the class, providing a custom constructor. function AnotherLinkedCollectionClass () { LinkedCollection.call(this); this.created_at = new Date().getTime(); } LinkedCollection.extend({ constructor: AnotherLinkedCollectionClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherLinkedCollection = new AnotherLinkedCollectionClass(); console.log(anotherLinkedCollection.created_at); console.log(anotherLinkedCollection.foo()); console.log(AnotherLinkedCollectionClass.beep()); add(data, opts) Insert the provided record or records. If a record is already in the collection then the provided record will either merge with or replace the existing record based on the value of the onConflict option. The collection's secondary indexes will be updated as each record is visited. Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records to insert. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description commitOnMerge Boolean &lt;optional&gt; true See Collection#commitOnMerge. noValidate Boolean &lt;optional&gt; See Record#noValidate. onConflict String &lt;optional&gt; See Collection#onConflict. Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The added record or records. Details Since Source 3.0.0 Collection.js, line 207 Inherited From: Collection#add afterRemove(id, opts, record) Lifecycle hook called by Collection#remove. If this method returns a value then Collection#remove will return that same value. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. record Object The result that will be returned by Collection#remove. Details Since Source 3.0.0 Collection.js, line 341 Inherited From: Collection#afterRemove afterRemoveAll(query, opts, records) Lifecycle hook called by Collection#removeAll. If this method returns a value then Collection#removeAll will return that same value. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. records Object The result that will be returned by Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 353 Inherited From: Collection#afterRemoveAll beforeAdd(records, opts) Lifecycle hook called by Collection#add. If this method returns a value then the records argument in Collection#add will be re-assigned to the returned value. Method parameters: Name Type Description records Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The records argument passed to Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 366 Inherited From: Collection#beforeAdd beforeRemove(id, opts) Lifecycle hook called by Collection#remove. Method parameters: Name Type Description id String | Number The id argument passed to Collection#remove. opts Object The opts argument passed to Collection#remove. Details Since Source 3.0.0 Collection.js, line 378 Inherited From: Collection#beforeRemove beforeRemoveAll(query, opts) Lifecycle hook called by Collection#removeAll. Method parameters: Name Type Description query Object The query argument passed to Collection#removeAll. opts Object The opts argument passed to Collection#removeAll. Details Since Source 3.0.0 Collection.js, line 388 Inherited From: Collection#beforeRemoveAll between(leftKeys, rightKeys, opts) Find all records between two boundaries. Shortcut for collection.query().between(18, 30, { index: 'age' }).run() Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include records on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include records on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting records to skip. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The result. Details Since Source 3.0.0 Collection.js, line 398 Inherited From: Collection#between Examples // Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }); // Get all users ages 18 to 30 const users = collection.between(18, 30, { index: 'age' }); // Same as above const users = collection.between([18], [30], { index: 'age' }); // Same as above const users = collection.between([18], [30], { index: 'age' }); createIndex(name, fieldList) Create a new secondary index on the contents of the collection. Method parameters: Name Type Argument Description name String The name of the new secondary index. fieldList Array.&lt;String&gt; &lt;optional&gt; Array of field names to use as the key or compound key of the new secondary index. If no fieldList is provided, then the name will also be the field that is used to index the collection. Details Since Source 3.0.0 Collection.js, line 432 Inherited From: Collection#createIndex Examples // Index users by age collection.createIndex('age'); // Index users by age collection.createIndex('age'); // Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']); // Index users by status and role collection.createIndex('statusAndRole', ['status', 'role']); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); filter(queryOrFn, thisArg) Find the record or records that match the provided query or pass the provided filter function. Shortcut for collection.query().filter(queryOrFn[, thisArg]).run() Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Object &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Array The result. Details Since Source See 3.0.0 Collection.js, line 460 query Inherited From: Collection#filter Example Try it out const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); const collection = new Collection([ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = collection.filter((post) =&gt; post.id % 2 === 0); const JSData = require('js-data'); const { Collection } = JSData; console.log('Using JSData v' + JSData.version.full); const collection = new Collection([ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = collection.filter({ where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = collection.filter((post) =&gt; post.id % 2 === 0); forEach(forEachFn, thisArg) Iterate over all records. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 506 Inherited From: Collection#forEach Example collection.forEach(function (record) { // do something }); collection.forEach(function (record) { // do something }); get(id) Get the record with the given id. Method parameters: Name Type Description id String | Number The primary key of the record to get. Return value: Type Description Object | Record The record with the given id. Details Since Source 3.0.0 Collection.js, line 524 Inherited From: Collection#get getAll(keyList, opts) Find the record or records that match the provided keyLists. Shortcut for collection.query().getAll(keyList1, keyList2, ...).run() Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all records matching each keyList will be retrieved. If no keyLists are provided, all records will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 542 Inherited From: Collection#getAll Examples // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = collection.getAll('draft', 'inReview', { index: 'status' }); // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = collection.getAll('draft', 'inReview', { index: 'status' }); // Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }); // Same as above const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' }); getIndex(name) Return the index with the given name. If no name is provided, return the main index. Throws an error if the specified index does not exist. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the index to retrieve. Details Since Source 3.0.0 Collection.js, line 571 Inherited From: Collection#getIndex limit(num) Limit the result. Shortcut for collection.query().limit(maximumNumber).run() Method parameters: Name Type Description num Number The maximum number of records to keep in the result. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 587 Inherited From: Collection#limit Example const posts = collection.limit(10); const posts = collection.limit(10); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to all records. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Array The result of the mapping. Details Since Source 3.0.0 Collection.js, line 606 Inherited From: Collection#map Example const names = collection.map((user) =&gt; user.name); const names = collection.map((user) =&gt; user.name); mapCall(funcName) Return the result of calling the specified function on each record in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 626 Inherited From: Collection#mapCall method(result, opts) Lifecycle hook called by Collection#add. If this method returns a value then Collection#add will return that same value. Method parameters: Name Type Description result Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; The record or records that were added to this Collection by Collection#add. opts Object The opts argument passed to Collection#add. Details Since Source 3.0.0 Collection.js, line 329 Inherited From: Collection#method off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; prune(opts) Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options, passed to Collection#removeAll. Return value: Type Description Array The removed records, if any. Details Since Source 3.0.0 Collection.js, line 644 Inherited From: Collection#prune query() Create a new query to be executed against the contents of the collection. The result will be all or a subset of the contents of the collection. Return value: Type Description Query New query object. Details Since Source 3.0.0 Collection.js, line 656 Inherited From: Collection#query Example // Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); // Grab page 2 of users between ages 18 and 30 collection.query() .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); recordId(record) Return the primary key of the given, or if no record is provided, return the name of the field that holds the primary key of records in this Collection. Method parameters: Name Type Argument Description record Object | Record &lt;optional&gt; The record whose primary key is to be returned. Return value: Type Description String | Number Primary key or name of field that holds primary key. Details Since Source 3.0.0 Collection.js, line 677 Inherited From: Collection#recordId reduce(cb, initialValue) Reduce the data in the collection to a single value and return the result. Method parameters: Name Type Description cb Function Reduction callback. initialValue * Initial value of the reduction. Return value: Type Description * The result. Details Since Source 3.0.0 Collection.js, line 695 Inherited From: Collection#reduce Example const totalVotes = collection.reduce((prev, record) =&gt; { return prev + record.upVotes + record.downVotes; }, 0); const totalVotes = collection.reduce((prev, record) =&gt; { return prev + record.upVotes + record.downVotes; }, 0); remove(idOrRecord, opts) Remove the record with the given id from this Collection. Method parameters: Name Type Argument Description idOrRecord String | Number | Object | Record The primary key of the record to be removed, or a reference to the record that is to be removed. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Object | Record The removed record, if any. Details Since Source 3.0.0 Collection.js, line 714 Inherited From: Collection#remove removeAll(queryOrRecords, opts) Remove from this collection the given records or the records selected by the given \"query\". Method parameters: Name Type Argument Default Description queryOrRecords Object | Array.&lt;Object&gt; | Array.&lt;Record&gt; &lt;optional&gt; {} Records to be removed or selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; The removed records, if any. Details Since Source 3.0.0 Collection.js, line 748 Inherited From: Collection#removeAll skip(num) Skip a number of results. Shortcut for collection.query().skip(numberToSkip).run() Method parameters: Name Type Description num Number The number of records to skip. Return value: Type Description Array The result. Details Since Source 3.0.0 Collection.js, line 782 Inherited From: Collection#skip Example const posts = collection.skip(10); const posts = collection.skip(10); toJSON(opts) Return the plain JSON representation of all items in this collection. Assumes records in this collection have a toJSON method. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Return value: Type Description Array The records. Details Since Source 3.0.0 Collection.js, line 801 Inherited From: Collection#toJSON unsaved() Return all \"unsaved\" (not uniquely identifiable) records in this colleciton. Return value: Type Description Array The unsaved records, if any. Details Since Source 3.0.0 Collection.js, line 816 Inherited From: Collection#unsaved updateIndex(record, opts) Update a record's position in a single index of this collection. See Collection#updateIndexes to update a record's position in all indexes at once. Method parameters: Name Type Argument Description record Object The record to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; The index in which to update the record's position. If you don't specify an index then the record will be updated in the main index. Details Since Source 3.0.0 Collection.js, line 827 Inherited From: Collection#updateIndex updateIndexes(record) Updates all indexes in this collection for the provided record. Has no effect if the record is not in the collection. Method parameters: Name Type Description record Object TODO Details Since Source 3.0.0 Collection.js, line 845 Inherited From: Collection#updateIndexes Events add Fired when one or more records are added to the Collection. See Collection~addListener on how to listen for this event. Details Source See Collection.js, line 885 Collection~addListener Collection#event:add Collection#add Inherited From: Collection#event:add change Fired when a record changes. Only works for records that have tracked changes. See Collection~changeListener on how to listen for this event. Details Source See Collection.js, line 861 Collection~changeListener Inherited From: Collection#event:change remove Fired when one or more records are removed from the Collection. See Collection~removeListener for how to listen for this event. Details Source See Collection.js, line 911 Collection~removeListener Collection#event:remove Collection#remove Collection#removeAll Inherited From: Collection#event:remove × Search results Close api.js-data.io • js-data.io "},"Mapper.html":{"id":"Mapper.html","title":"Class: Mapper","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Mapper Mapper new Mapper(opts) The core of JSData's ORM/ODM implementation. Given a minimum amout of meta information about a resource, a Mapper can perform generic CRUD operations against that resource. Apart from its configuration, a Mapper is stateless. The particulars of various persistence layers have been abstracted into adapters, which a Mapper uses to perform its operations. The term \"Mapper\" comes from the [Data Mapper Pattern][pattern] described in Martin Fowler's [Patterns of Enterprise Application Architecture][book]. A Data Mapper moves data between [in-memory object instances][record] and a relational or document-based database. JSData's Mapper can work with any persistence layer you can write an adapter for. (\"Model\" is a heavily overloaded term and is avoided in this documentation to prevent confusion.) Method parameters: Name Type Description opts Object Configuration options. Properties Name Type Argument Default Description applySchema Boolean &lt;optional&gt; true See Mapper#applySchema. debug Boolean &lt;optional&gt; false See Component#debug. defaultAdapter String &lt;optional&gt; http See Mapper#defaultAdapter. idAttribute String &lt;optional&gt; id See Mapper#idAttribute. methods Object &lt;optional&gt; See Mapper#methods. name String See Mapper#name. notify Boolean &lt;optional&gt; See Mapper#notify. raw Boolean &lt;optional&gt; false See Mapper#raw. recordClass Function | Boolean &lt;optional&gt; See Mapper#recordClass. schema Object | Schema &lt;optional&gt; See Mapper#schema. Return value: Type Description Mapper A new Mapper instance. Details Since Source Tutorials See 3.0.0 Mapper.js, line 256 Components of JSData: Mapper Modeling your data http://www.js-data.io/v3.0/docs/components-of-jsdata#mapper Examples [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern [book]: http://martinfowler.com/books/eaa.html [record]: Record.html // Import and instantiate import { Mapper } from 'js-data'; const UserMapper = new Mapper({ name: 'user' }); [pattern]: https://en.wikipedia.org/wiki/Data_mapper_pattern [book]: http://martinfowler.com/books/eaa.html [record]: Record.html // Import and instantiate import { Mapper } from 'js-data'; const UserMapper = new Mapper({ name: 'user' }); // Define a Mapper using the Container component import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); // Define a Mapper using the Container component import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); Extends This class extends the Component class. Members _adapters Hash of registered adapters. Don't modify directly. Use Mapper#registerAdapter instead. Details Since Default value Source Tutorials 3.0.0 {} Mapper.js, line 139 Connecting to a data source applyDefaults Whether Mapper#beforeCreate and Mapper#beforeCreateMany should automatically receive default values according to the Mapper's schema. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 150 applySchema Whether to augment Mapper#recordClass with ES5 getters and setters according to the properties defined in Mapper#schema. This makes possible validation and change tracking on individual properties when using the dot (e.g. user.name = \"Bob\") operator to modify a property, and is true by default. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 161 debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged defaultAdapter The name of the registered adapter that this Mapper should used by default. Details Type Since Default value Source Tutorials String 3.0.0 \"http\" Mapper.js, line 175 Connecting to a data source idAttribute The field used as the unique identifier on records handled by this Mapper. Details Type Since Default value Source String 3.0.0 id Mapper.js, line 186 keepChangeHistory Whether records created from this mapper keep changeHistory on property changes. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 196 lifecycleMethods The Container that holds this Mapper. Do not modify. Details Type Since Source Object 3.0.0 Mapper.js, line 319 lifecycleMethods The meta information describing this Mapper's available lifecycle methods. Do not modify. Details Type Since Source Object 3.0.0 Mapper.js, line 331 methods Functions that should be added to the prototype of Mapper#recordClass. Details Type Since Source Object 3.0.0 Mapper.js, line 487 name The name for this Mapper. This is the minimum amount of meta information required for a Mapper to be able to execute CRUD operations for a Resource. Details Type Since Source String 3.0.0 Mapper.js, line 449 notify Whether this Mapper should emit operational events. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 206 noValidate Whether to skip validation when the Record instances are created. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 216 raw Whether Mapper#create, Mapper#createMany, Mapper#update, Mapper#updateAll, Mapper#updateMany, Mapper#find, Mapper#findAll, Mapper#destroy, Mapper#destroyAll, Mapper#count, and Mapper#sum should return a raw result object that contains both the instance data returned by the adapter and metadata about the operation. The default is to NOT return the result object, and instead return just the instance data. Details Type Since Default value Source Boolean 3.0.0 false Mapper.js, line 226 recordClass Set to false to force the Mapper to work with POJO objects only. Details Since Default value Source See 3.0.0 Record Mapper.js, line 343 Record Examples // Use POJOs only. import { Mapper, Record } from 'js-data'; const UserMapper = new Mapper({ recordClass: false }); UserMapper.recordClass // false; const user = UserMapper.createRecord(); user instanceof Record; // false // Use POJOs only. import { Mapper, Record } from 'js-data'; const UserMapper = new Mapper({ recordClass: false }); UserMapper.recordClass // false; const user = UserMapper.createRecord(); user instanceof Record; // false // Set to a custom class to have records wrapped in your custom class. import { Mapper, Record } from 'js-data'; // Custom class class User { constructor (props = {}) { for (var key in props) { if (props.hasOwnProperty(key)) { this[key] = props[key]; } } } } const UserMapper = new Mapper({ recordClass: User }); UserMapper.recordClass; // function User() {} const user = UserMapper.createRecord(); user instanceof Record; // false user instanceof User; // true // Set to a custom class to have records wrapped in your custom class. import { Mapper, Record } from 'js-data'; // Custom class class User { constructor (props = {}) { for (var key in props) { if (props.hasOwnProperty(key)) { this[key] = props[key]; } } } } const UserMapper = new Mapper({ recordClass: User }); UserMapper.recordClass; // function User() {} const user = UserMapper.createRecord(); user instanceof Record; // false user instanceof User; // true // Extend the Record class. import { Mapper, Record } from 'js-data'; // Custom class class User extends Record { constructor () { super(props); } } const UserMapper = new Mapper({ recordClass: User }); UserMapper.recordClass; // function User() {} const user = UserMapper.createRecord(); user instanceof Record; // true user instanceof User; // true // Extend the Record class. import { Mapper, Record } from 'js-data'; // Custom class class User extends Record { constructor () { super(props); } } const UserMapper = new Mapper({ recordClass: User }); UserMapper.recordClass; // function User() {} const user = UserMapper.createRecord(); user instanceof Record; // true user instanceof User; // true schema This Mapper's Schema. Details Type Since Source See Schema 3.0.0 Mapper.js, line 399 Schema Example Try it out const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); const UserMapper = new Mapper({ name: 'user', schema: { properties: { id: { type: 'number' }, first: { type: 'string', track: true }, last: { type: 'string', track: true }, role: { type: 'string', track: true, required: true }, age: { type: 'integer', track: true }, is_active: { type: 'number' } } } }); const user = UserMapper.createRecord({ id: 1, name: 'John', role: 'admin' }); user.on('change', function (user, changes) { console.log(changes); }); user.on('change:role', function (user, value) { console.log('change:role - ' + value); }); user.role = 'owner'; const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); const UserMapper = new Mapper({ name: 'user', schema: { properties: { id: { type: 'number' }, first: { type: 'string', track: true }, last: { type: 'string', track: true }, role: { type: 'string', track: true, required: true }, age: { type: 'integer', track: true }, is_active: { type: 'number' } } } }); const user = UserMapper.createRecord({ id: 1, name: 'John', role: 'admin' }); user.on('change', function (user, changes) { console.log(changes); }); user.on('change:role', function (user, value) { console.log('change:role - ' + value); }); user.role = 'owner'; validateOnSet Whether records created from this mapper automatically validate their properties when their properties are modified. Details Type Since Default value Source Boolean 3.0.0 true Mapper.js, line 244 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Mapper: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Mapper class. Details Since Source 3.0.0 Mapper.js, line 2487 Example Try it out const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomMapperClass extends Mapper { foo () { return 'bar'; } static beep () { return 'boop'; } }; const customMapper = new CustomMapperClass(); console.log(customMapper.foo()); console.log(CustomMapperClass.beep()); // Extend the class using alternate method. const OtherMapperClass = Mapper.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherMapper = new OtherMapperClass(); console.log(otherMapper.foo()); console.log(OtherMapperClass.beep()); // Extend the class, providing a custom constructor. function AnotherMapperClass () { Mapper.call(this); this.created_at = new Date().getTime(); } Mapper.extend({ constructor: AnotherMapperClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherMapper = new AnotherMapperClass(); console.log(anotherMapper.created_at); console.log(anotherMapper.foo()); console.log(AnotherMapperClass.beep()); const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomMapperClass extends Mapper { foo () { return 'bar'; } static beep () { return 'boop'; } }; const customMapper = new CustomMapperClass(); console.log(customMapper.foo()); console.log(CustomMapperClass.beep()); // Extend the class using alternate method. const OtherMapperClass = Mapper.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherMapper = new OtherMapperClass(); console.log(otherMapper.foo()); console.log(OtherMapperClass.beep()); // Extend the class, providing a custom constructor. function AnotherMapperClass () { Mapper.call(this); this.created_at = new Date().getTime(); } Mapper.extend({ constructor: AnotherMapperClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherMapper = new AnotherMapperClass(); console.log(anotherMapper.created_at); console.log(anotherMapper.foo()); console.log(AnotherMapperClass.beep()); afterCount(query, opts, result) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 509 afterCreate(props, opts, result) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 522 afterCreateMany(records, opts, result) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 535 afterDestroy(id, opts, result) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 548 afterDestroyAll(data, query, opts, result) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description data * The data returned by the adapter. query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 561 afterFind(id, opts, result) Mapper lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 575 afterFindAll(query, opts, result) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 588 afterSum(query, opts, result) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 601 afterUpdate(id, props, opts, result) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 614 afterUpdateAll(props, query, opts, result) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 628 afterUpdateMany(records, opts, result) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. result * The result, if any. Details Since Source 3.0.0 Mapper.js, line 642 beforeCount(query, opts) Mapper lifecycle hook called by Mapper#count. If this method returns a promise then Mapper#count will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#count. opts Object The opts argument passed to Mapper#count. Details Since Source 3.0.0 Mapper.js, line 679 beforeCreate(props, opts) Mapper lifecycle hook called by Mapper#create. If this method returns a promise then Mapper#create will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#create. opts Object The opts argument passed to Mapper#create. Details Since Source 3.0.0 Mapper.js, line 655 beforeCreateMany(records, opts) Mapper lifecycle hook called by Mapper#createMany. If this method returns a promise then Mapper#createMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#createMany. opts Object The opts argument passed to Mapper#createMany. Details Since Source 3.0.0 Mapper.js, line 667 beforeDestroy(id, opts) Mapper lifecycle hook called by Mapper#destroy. If this method returns a promise then Mapper#destroy will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#destroy. opts Object The opts argument passed to Mapper#destroy. Details Since Source 3.0.0 Mapper.js, line 691 beforeDestroyAll(query, opts) Mapper lifecycle hook called by Mapper#destroyAll. If this method returns a promise then Mapper#destroyAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query query The query argument passed to Mapper#destroyAll. opts Object The opts argument passed to Mapper#destroyAll. Details Since Source 3.0.0 Mapper.js, line 703 beforeFind(id, opts) Mappers lifecycle hook called by Mapper#find. If this method returns a promise then Mapper#find will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#find. opts Object The opts argument passed to Mapper#find. Details Since Source 3.0.0 Mapper.js, line 715 beforeFindAll(query, opts) Mapper lifecycle hook called by Mapper#findAll. If this method returns a promise then Mapper#findAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description query Object The query argument passed to Mapper#findAll. opts Object The opts argument passed to Mapper#findAll. Details Since Source 3.0.0 Mapper.js, line 727 beforeSum(field, query, opts) Mapper lifecycle hook called by Mapper#sum. If this method returns a promise then Mapper#sum will wait for the promise to resolve before continuing. Method parameters: Name Type Description field String The field argument passed to Mapper#sum. query Object The query argument passed to Mapper#sum. opts Object The opts argument passed to Mapper#sum. Details Since Source 3.0.0 Mapper.js, line 739 beforeUpdate(id, props, opts) Mapper lifecycle hook called by Mapper#update. If this method returns a promise then Mapper#update will wait for the promise to resolve before continuing. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#update. props props The props argument passed to Mapper#update. opts Object The opts argument passed to Mapper#update. Details Since Source 3.0.0 Mapper.js, line 752 beforeUpdateAll(props, query, opts) Mapper lifecycle hook called by Mapper#updateAll. If this method returns a promise then Mapper#updateAll will wait for the promise to resolve before continuing. Method parameters: Name Type Description props Object The props argument passed to Mapper#updateAll. query Object The query argument passed to Mapper#updateAll. opts Object The opts argument passed to Mapper#updateAll. Details Since Source 3.0.0 Mapper.js, line 765 beforeUpdateMany(records, opts) Mapper lifecycle hook called by Mapper#updateMany. If this method returns a promise then Mapper#updateMany will wait for the promise to resolve before continuing. Method parameters: Name Type Description records Array The records argument passed to Mapper#updateMany. opts Object The opts argument passed to Mapper#updateMany. Details Since Source 3.0.0 Mapper.js, line 778 belongsTo() Define a belongsTo relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 822 http://www.js-data.io/v3.0/docs/relations Example PostMapper.belongsTo(UserMapper, { // post.user_id points to user.id foreignKey: 'user_id' // user records will be attached to post records at \"post.user\" localField: 'user' }); CommentMapper.belongsTo(UserMapper, { // comment.user_id points to user.id foreignKey: 'user_id' // user records will be attached to comment records at \"comment.user\" localField: 'user' }); CommentMapper.belongsTo(PostMapper, { // comment.post_id points to post.id foreignKey: 'post_id' // post records will be attached to comment records at \"comment.post\" localField: 'post' }); PostMapper.belongsTo(UserMapper, { // post.user_id points to user.id foreignKey: 'user_id' // user records will be attached to post records at \"post.user\" localField: 'user' }); CommentMapper.belongsTo(UserMapper, { // comment.user_id points to user.id foreignKey: 'user_id' // user records will be attached to comment records at \"comment.user\" localField: 'user' }); CommentMapper.belongsTo(PostMapper, { // comment.post_id points to post.id foreignKey: 'post_id' // post records will be attached to comment records at \"comment.post\" localField: 'post' }); count(query, opts) Select records according to the query argument and return the count. Mapper#beforeCount will be called before calling the adapter. Mapper#afterCount will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the count method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the count of the selected records. Details Since Source 3.0.0 Mapper.js, line 855 Example // Get the number of published blog posts PostMapper.count({ status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); // Get the number of published blog posts PostMapper.count({ status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); create(props, opts) Create and save a new the record using the provided props. Mapper#beforeCreate will be called before calling the adapter. Mapper#afterCreate will be called after calling the adapter. Method parameters: Name Type Argument Description props Object The properties for the new record. opts Object &lt;optional&gt; Configuration options. Refer to the create method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if props contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#create or Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Fires: Mapper#event:beforeCreate Mapper#event:afterCreate Return value: Type Description Promise Resolves with the created record. Details Since Source 3.0.0 Mapper.js, line 935 Example // Create and save a new blog post PostMapper.create({ title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'draft', ... } }); // Create and save a new blog post PostMapper.create({ title: 'Modeling your data', status: 'draft' }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'draft', ... } }); createInstance(props, opts) Use Mapper#createRecord instead. Method parameters: Name Type Argument Description props Object | Array See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Object | Array See Mapper#createRecord. Details Since Source See 3.0.0 Mapper.js, line 1029 Mapper#createRecord Deprecated: Yes createMany(records, opts) Given an array of records, batch create them via an adapter. Mapper#beforeCreateMany will be called before calling the adapter. Mapper#afterCreateMany will be called after calling the adapter. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array of records to be created in one batch. opts Object &lt;optional&gt; Configuration options. Refer to the createMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to create in a cascading create if records contains nested relations. NOT performed in a transaction. Each nested create will result in another Mapper#createMany call. pass Array.&lt;String&gt; &lt;optional&gt; [] Relations to send to the adapter as part of the payload. Normally relations are not sent. Fires: Mapper#event:beforeCreate Mapper#event:afterCreate Return value: Type Description Promise Resolves with the created records. Details Since Source Tutorials 3.0.0 Mapper.js, line 1163 Saving data Example // Create and save several new blog posts PostMapper.createMany([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]); // { id: 1234, status: 'draft', ... } console.log(posts[1]); // { id: 1235, status: 'draft', ... } }); // Create and save several new blog posts PostMapper.createMany([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]).then((posts) =&gt; { console.log(posts[0]); // { id: 1234, status: 'draft', ... } console.log(posts[1]); // { id: 1235, status: 'draft', ... } }); createRecord(props, opts) Create an unsaved, uncached instance of this Mapper's Mapper#recordClass. Returns props if props is already an instance of Mapper#recordClass. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description props Object | Array.&lt;Object&gt; The properties for the Record instance or an array of property objects for the Record instances. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. Return value: Type Description Record | Array.&lt;Record&gt; The Record instance or Record instances. Details Since Source 3.0.0 Mapper.js, line 1296 Examples // Create empty unsaved record instance const post = PostMapper.createRecord(); // Create empty unsaved record instance const post = PostMapper.createRecord(); // Create an unsaved record instance with inital properties const post = PostMapper.createRecord({ title: 'Modeling your data', status: 'draft' }); // Create an unsaved record instance with inital properties const post = PostMapper.createRecord({ title: 'Modeling your data', status: 'draft' }); // Create a record instance that corresponds to a saved record const post = PostMapper.createRecord({ // JSData thinks this record has been saved if it has a primary key id: 1234, title: 'Modeling your data', status: 'draft' }); // Create a record instance that corresponds to a saved record const post = PostMapper.createRecord({ // JSData thinks this record has been saved if it has a primary key id: 1234, title: 'Modeling your data', status: 'draft' }); // Create record instances from an array const posts = PostMapper.createRecord([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]); // Create record instances from an array const posts = PostMapper.createRecord([{ title: 'Modeling your data', status: 'draft' }, { title: 'Reading data', status: 'draft' }]); // Records are validated by default import { Mapper } from 'js-data'; const PostMapper = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }); try { const post = PostMapper.createRecord({ title: 1234, }); } catch (err) { console.log(err.errors); // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] } // Records are validated by default import { Mapper } from 'js-data'; const PostMapper = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }); try { const post = PostMapper.createRecord({ title: 1234, }); } catch (err) { console.log(err.errors); // [{ expected: 'one of (string)', actual: 'number', path: 'title' }] } // Skip validation import { Mapper } from 'js-data'; const PostMapper = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }); const post = PostMapper.createRecord({ title: 1234, }, { noValidate: true }); console.log(post.isValid()); // false // Skip validation import { Mapper } from 'js-data'; const PostMapper = new Mapper({ name: 'post', schema: { properties: { title: { type: 'string' } } } }); const post = PostMapper.createRecord({ title: 1234, }, { noValidate: true }); console.log(post.isValid()); // false crud(method, args) Lifecycle invocation method. You probably won't call this method directly. Method parameters: Name Type Argument Description method String Name of the lifecycle method to invoke. args * &lt;repeatable&gt; Arguments to pass to the lifecycle method. Return value: Type Description Promise Unspecified Details Since Source 3.0.0 Mapper.js, line 1390 dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg destroy(id, opts) Using an adapter, destroy the record with the given primary key. Mapper#beforeDestroy will be called before destroying the record. Mapper#afterDestroy will be called after destroying the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Refer to the destroy method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Fires: Mapper#event:beforeDestroy Mapper#event:afterDestroy Return value: Type Description Promise Resolves when the record has been destroyed. Resolves even if no record was found to be destroyed. Details Since Source Tutorials 3.0.0 Mapper.js, line 1501 Saving data Examples // Destroy a specific blog post PostMapper.destroy(1234).then(() =&gt; { // Blog post #1234 has been destroyed }); // Destroy a specific blog post PostMapper.destroy(1234).then(() =&gt; { // Blog post #1234 has been destroyed }); // Get full response PostMapper.destroy(1234, { raw: true }).then((result) =&gt; { console.log(result.deleted); e.g. 1 console.log(...); // etc., more metadata can be found on the result }); // Get full response PostMapper.destroy(1234, { raw: true }).then((result) =&gt; { console.log(result.deleted); e.g. 1 console.log(...); // etc., more metadata can be found on the result }); destroyAll(query, opts) Destroy the records selected by query via an adapter. If no query is provided then all records will be destroyed. Mapper#beforeDestroyAll will be called before destroying the records. Mapper#afterDestroyAll will be called after destroying the records. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the destroyAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Fires: Mapper#event:beforeDestroyAll Mapper#event:afterDestroyAll Return value: Type Description Promise Resolves when the records have been destroyed. Resolves even if no records were found to be destroyed. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1588 Saving data query Examples // Destroy all blog posts PostMapper.destroyAll().then(() =&gt; { // All blog posts have been destroyed }); // Destroy all blog posts PostMapper.destroyAll().then(() =&gt; { // All blog posts have been destroyed }); // Destroy all \"draft\" blog posts PostMapper.destroyAll({ status: 'draft' }).then(() =&gt; { // All \"draft\" blog posts have been destroyed }); // Destroy all \"draft\" blog posts PostMapper.destroyAll({ status: 'draft' }).then(() =&gt; { // All \"draft\" blog posts have been destroyed }); // Get full response const query = null; const options = { raw: true }; PostMapper.destroyAll(query, options).then((result) =&gt; { console.log(result.deleted); e.g. 14 console.log(...); // etc., more metadata can be found on the result }); // Get full response const query = null; const options = { raw: true }; PostMapper.destroyAll(query, options).then((result) =&gt; { console.log(result.deleted); e.g. 14 console.log(...); // etc., more metadata can be found on the result }); emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); find(id, opts) Retrieve via an adapter the record with the given primary key. Mapper#beforeFind will be called before calling the adapter. Mapper#afterFind will be called after calling the adapter. Method parameters: Name Type Argument Description id String | Number The primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Refer to the find method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Fires: Mapper#event:beforeFind Mapper#event:afterFind Return value: Type Description Promise Resolves with the found record. Resolves with undefined if no record was found. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1689 Reading data http://www.js-data.io/v3.0/docs/reading-data Examples PostMapper.find(1).then((post) =&gt; { console.log(post); // { id: 1, ...} }); PostMapper.find(1).then((post) =&gt; { console.log(post); // { id: 1, ...} }); // Get full response PostMapper.find(1, { raw: true }).then((result) =&gt; { console.log(result.data); // { id: 1, ...} console.log(result.found); // 1 console.log(...); // etc., more metadata can be found on the result }); // Get full response PostMapper.find(1, { raw: true }).then((result) =&gt; { console.log(result.data); // { id: 1, ...} console.log(result.found); // 1 console.log(...); // etc., more metadata can be found on the result }); findAll(query, opts) Using the query argument, select records to retrieve via an adapter. Mapper#beforeFindAll will be called before calling the adapter. Mapper#afterFindAll will be called after calling the adapter. Method parameters: Name Type Argument Default Description query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the findAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load in the request. Fires: Mapper#event:beforeFindAll Mapper#event:afterFindAll Return value: Type Description Promise Resolves with the found records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 1778 Reading data query Examples // Find all \"published\" blog posts PostMapper.findAll({ status: 'published' }).then((posts) =&gt; { console.log(posts); // [{ id: 1, status: 'published', ...}, ...] }); // Find all \"published\" blog posts PostMapper.findAll({ status: 'published' }).then((posts) =&gt; { console.log(posts); // [{ id: 1, status: 'published', ...}, ...] }); // Get full response PostMapper.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { console.log(result.data); // [{ id: 1, status: 'published', ...}, ...] console.log(result.found); // e.g. 13 console.log(...); // etc., more metadata can be found on the result }); // Get full response PostMapper.findAll({ status: 'published' }, { raw: true }).then((result) =&gt; { console.log(result.data); // [{ id: 1, status: 'published', ...}, ...] console.log(result.found); // e.g. 13 console.log(...); // etc., more metadata can be found on the result }); getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1822 Connecting to a data source getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source Tutorials 3.0.0 Mapper.js, line 1841 Connecting to a data source getAdapters() Get the object of registered adapters for this Mapper. Return value: Type Description Object Mapper#_adapters Details Since Source Tutorials 3.0.0 Mapper.js, line 1859 Connecting to a data source getSchema() Returns this Mapper's Schema. Return value: Type Description Schema This Mapper's Schema. Details Since Source See 3.0.0 Mapper.js, line 1871 Mapper#schema hasMany() Defines a hasMany relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1883 http://www.js-data.io/v3.0/docs/relations Example UserMapper.hasMany(PostMapper, { // post.user_id points to user.id foreignKey: 'user_id' // post records will be attached to user records at \"user.posts\" localField: 'posts' }); UserMapper.hasMany(PostMapper, { // post.user_id points to user.id foreignKey: 'user_id' // post records will be attached to user records at \"user.posts\" localField: 'posts' }); hasOne() Defines a hasOne relationship. Only useful if you're managing your Mappers manually and not using a Container or DataStore component. Details Since Source See 3.0.0 Mapper.js, line 1903 http://www.js-data.io/v3.0/docs/relations Example UserMapper.hasOne(ProfileMapper, { // profile.user_id points to user.id foreignKey: 'user_id' // profile records will be attached to user records at \"user.profile\" localField: 'profile' }); UserMapper.hasOne(ProfileMapper, { // profile.user_id points to user.id foreignKey: 'user_id' // profile records will be attached to user records at \"user.profile\" localField: 'profile' }); is(record) Return whether record is an instance of this Mapper's recordClass. Method parameters: Name Type Description record Object | Record The record to check. Return value: Type Description Boolean Whether record is an instance of this Mapper's Mapper#recordClass. Details Since Source 3.0.0 Mapper.js, line 1923 Example const post = PostMapper.createRecord(); console.log(PostMapper.is(post)); // true // Equivalent to what's above console.log(post instanceof PostMapper.recordClass); // true const post = PostMapper.createRecord(); console.log(PostMapper.is(post)); // true // Equivalent to what's above console.log(post instanceof PostMapper.recordClass); // true log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; registerAdapter(name, adapter, opts) Register an adapter on this Mapper under the given name. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for this Mapper. Details Since Source Tutorials 3.0.0 Mapper.js, line 1944 Connecting to a data source sum(field, query, opts) Select records according to the query argument, and aggregate the sum value of the property specified by field. Mapper#beforeSum will be called before calling the adapter. Mapper#afterSum will be called after calling the adapter. Method parameters: Name Type Argument Default Description field String The field to sum. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the sum method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Return value: Type Description Promise Resolves with the aggregated sum. Details Since Source 3.0.0 Mapper.js, line 1987 Example PurchaseOrderMapper.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); PurchaseOrderMapper.sum('amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); toJSON(records, opts) Return a plain object representation of the given record. Relations can be optionally be included. Non-schema properties can be excluded. Method parameters: Name Type Argument Description records Record | Array.&lt;Record&gt; Record or records from which to create a POJO representation. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the POJO representation. withAll Boolean &lt;optional&gt; Whether to simply include all relations in the representation. Overrides opts.with. Return value: Type Description Object | Array.&lt;Object&gt; POJO representation of the record or records. Details Since Source 3.0.0 Mapper.js, line 2019 Example import { Mapper, Schema } from 'js-data'; const PersonMapper = new Mapper({ name: 'person', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); const person = PersonMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); // \"foo\" is stripped by toJSON() console.log(PersonMapper.toJSON(person)); // {\"id\":1,\"name\":\"John\"} const PersonRelaxedMapper = new Mapper({ name: 'personRelaxed', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } }, additionalProperties: true } }); const person2 = PersonRelaxedMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); // \"foo\" is not stripped by toJSON console.log(PersonRelaxedMapper.toJSON(person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} import { Mapper, Schema } from 'js-data'; const PersonMapper = new Mapper({ name: 'person', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); const person = PersonMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); // \"foo\" is stripped by toJSON() console.log(PersonMapper.toJSON(person)); // {\"id\":1,\"name\":\"John\"} const PersonRelaxedMapper = new Mapper({ name: 'personRelaxed', schema: { properties: { name: { type: 'string' }, id: { type: 'string' } }, additionalProperties: true } }); const person2 = PersonRelaxedMapper.createRecord({ id: 1, name: 'John', foo: 'bar' }); // \"foo\" is not stripped by toJSON console.log(PersonRelaxedMapper.toJSON(person2)); // {\"id\":1,\"name\":\"John\",\"foo\":\"bar\"} update(id, props, opts) Using an adapter, update the record with the primary key specified by the id argument. Mapper#beforeUpdate will be called before updating the record. Mapper#afterUpdate will be called after updating the record. Method parameters: Name Type Argument Description id String | Number The primary key of the record to update. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Refer to the update method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. transaction. Fires: Mapper#event:beforeUpdate Mapper#event:afterUpdate Return value: Type Description Promise Resolves with the updated record. Rejects if the record could not be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 2161 Saving data Example // Update a specific post PostMapper.update(1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'published', ... } }); // Update a specific post PostMapper.update(1234, { status: 'published', published_at: new Date() }).then((post) =&gt; { console.log(post); // { id: 1234, status: 'published', ... } }); updateAll(props, query, opts) Using the query argument, perform the a single updated to the selected records. Mapper#beforeUpdateAll will be called before making the update. Mapper#afterUpdateAll will be called after making the update. Method parameters: Name Type Argument Default Description props Object Update to apply to selected records. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Refer to the updateAll method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Fires: Mapper#event:beforeUpdateAll Mapper#event:afterUpdateAll Return value: Type Description Promise Resolves with the update records, if any. Details Since Source Tutorials See 3.0.0 Mapper.js, line 2250 Saving data query Example // Turn all of John's blog posts into drafts. const update = { status: draft: published_at: null }; const query = { userId: 1234 }; PostMapper.updateAll(update, query).then((posts) =&gt; { console.log(posts); // [...] }); // Turn all of John's blog posts into drafts. const update = { status: draft: published_at: null }; const query = { userId: 1234 }; PostMapper.updateAll(update, query).then((posts) =&gt; { console.log(posts); // [...] }); updateMany(records, opts) Given an array of updates, perform each of the updates via an adapter. Each \"update\" is a hash of properties with which to update an record. Each update must contain the primary key of the record to be updated. Mapper#beforeUpdateMany will be called before making the update. Mapper#afterUpdateMany will be called after making the update. Method parameters: Name Type Argument Description records Array.&lt;Record&gt; Array up record updates. opts Object &lt;optional&gt; Configuration options. Refer to the updateMany method of whatever adapter you're using for more configuration options. Properties Name Type Argument Default Description adapter Boolean &lt;optional&gt; Mapper#defaultAdapter Name of the adapter to use. notify Boolean &lt;optional&gt; Mapper#notify See Mapper#notify. noValidate Boolean &lt;optional&gt; Mapper#noValidate See Mapper#noValidate. raw Boolean &lt;optional&gt; Mapper#raw See Mapper#raw. Fires: Mapper#event:beforeUpdateMany Mapper#event:afterUpdateMany Return value: Type Description Promise Resolves with the updated records. Rejects if any of the records could be found. Details Since Source Tutorials 3.0.0 Mapper.js, line 2339 Saving data Example PostMapper.updateMany([ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts); // [...] }); PostMapper.updateMany([ { id: 1234, status: 'draft' }, { id: 2468, status: 'published', published_at: new Date() } ]).then((posts) =&gt; { console.log(posts); // [...] }); validate(record, opts) Validate the given record or records according to this Mapper's Schema. If there are no validation errors then the return value will be undefined. Method parameters: Name Type Argument Description record Object | Array.&lt;Object&gt; The record or records to validate. opts Object &lt;optional&gt; Configuration options. Passed to Schema#validate. Return value: Type Description Array.&lt;Object&gt; Array of errors or undefined if no errors. Details Since Source 3.0.0 Mapper.js, line 2375 Example import {Mapper, Schema} from 'js-data' const PersonSchema = new Schema({ properties: { name: { type: 'string' }, id: { type: 'string' } } }); const PersonMapper = new Mapper({ name: 'person', schema: PersonSchema }); let errors = PersonMapper.validate({ name: 'John' }); console.log(errors); // undefined errors = PersonMapper.validate({ name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] import {Mapper, Schema} from 'js-data' const PersonSchema = new Schema({ properties: { name: { type: 'string' }, id: { type: 'string' } } }); const PersonMapper = new Mapper({ name: 'person', schema: PersonSchema }); let errors = PersonMapper.validate({ name: 'John' }); console.log(errors); // undefined errors = PersonMapper.validate({ name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] wrap(data, opts) Method used to wrap data returned by an adapter with this Mapper's Mapper#recordClass. This method is used by all of a Mapper's CRUD methods. The provided implementation of this method assumes that the data passed to it is a record or records that need to be wrapped with Mapper#createRecord. Override with care. Provided implementation of Mapper#wrap: function (data, opts) { return this.createRecord(data, opts); } Method parameters: Name Type Argument Description data Object | Array.&lt;Object&gt; The record or records to be wrapped. opts Object &lt;optional&gt; Configuration options. Passed to Mapper#createRecord. Return value: Type Description Record | Array.&lt;Record&gt; The wrapped record or records. Details Since Source 3.0.0 Mapper.js, line 2419 Example const PostMapper = new Mapper({ name: 'post', // Override to customize behavior wrap (data, opts) { const originalWrap = this.constructor.prototype.wrap; // Let's say \"GET /post\" doesn't return JSON quite like JSData expects, // but the actual post records are nested under a \"posts\" field. So, // we override Mapper#wrap to handle this special case. if (opts.op === 'findAll') { return originalWrap.call(this, data.posts, opts); } // Otherwise perform original behavior return originalWrap.call(this, data, opts); } }); const PostMapper = new Mapper({ name: 'post', // Override to customize behavior wrap (data, opts) { const originalWrap = this.constructor.prototype.wrap; // Let's say \"GET /post\" doesn't return JSON quite like JSData expects, // but the actual post records are nested under a \"posts\" field. So, // we override Mapper#wrap to handle this special case. if (opts.op === 'findAll') { return originalWrap.call(this, data.posts, opts); } // Otherwise perform original behavior return originalWrap.call(this, data, opts); } }); Type Definitions afterCreateListener(props, opts, result) Callback signature for the Mapper#event:afterCreate event. Method parameters: Name Type Description props Object The props argument passed to Mapper#afterCreate. opts Object The opts argument passed to Mapper#afterCreate. result Object The result argument passed to Mapper#afterCreate. Details Type Since Source See Function 3.0.0 Mapper.js, line 918 Mapper#event:afterCreate Mapper#create Example function onAfterCreate (props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); function onAfterCreate (props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); afterCreateManyListener(records, opts, result) Callback signature for the Mapper#event:afterCreateMany event. Method parameters: Name Type Description records Object The records argument received by Mapper#afterCreateMany. opts Object The opts argument received by Mapper#afterCreateMany. result Object The result argument received by Mapper#afterCreateMany. Details Type Since Source See Function 3.0.0 Mapper.js, line 1146 Mapper#event:afterCreateMany Mapper#createMany Example function onAfterCreateMany (records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); function onAfterCreateMany (records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); afterDestroyAllListener(query, opts, result) Callback signature for the Mapper#event:afterDestroyAll event. Method parameters: Name Type Description query Object The query argument passed to Mapper#afterDestroyAll. opts Object The opts argument passed to Mapper#afterDestroyAll. result Object The result argument passed to Mapper#afterDestroyAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 1571 Mapper#event:afterDestroyAll Mapper#destroyAll Example function onAfterDestroyAll (query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); function onAfterDestroyAll (query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); afterDestroyListener(id, opts, result) Callback signature for the Mapper#event:afterDestroy event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#afterDestroy. opts Object The opts argument passed to Mapper#afterDestroy. result Object The result argument passed to Mapper#afterDestroy. Details Type Since Source See Function 3.0.0 Mapper.js, line 1484 Mapper#event:afterDestroy Mapper#destroy Example function onAfterDestroy (id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); function onAfterDestroy (id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); afterFindAllListener(query, opts, result) Callback signature for the Mapper#event:afterFindAll event. Method parameters: Name Type Description query Object The query argument passed to Mapper#afterFindAll. opts Object The opts argument passed to Mapper#afterFindAll. result Object The result argument passed to Mapper#afterFindAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 1761 Mapper#event:afterFindAll Mapper#findAll Example function onAfterFindAll (query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); function onAfterFindAll (query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); afterFindListener(id, opts, result) Callback signature for the Mapper#event:afterFind event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#afterFind. opts Object The opts argument passed to Mapper#afterFind. result Object The result argument passed to Mapper#afterFind. Details Type Since Source See Function 3.0.0 Mapper.js, line 1672 Mapper#event:afterFind Mapper#find Example function onAfterFind (id, opts, result) { // do something } store.on('afterFind', onAfterFind); function onAfterFind (id, opts, result) { // do something } store.on('afterFind', onAfterFind); afterUpdateAllListener(props, query, opts, result) Callback signature for the Mapper#event:afterUpdateAll event. Method parameters: Name Type Description props Object The props argument received by Mapper#afterUpdateAll. query Object The query argument received by Mapper#afterUpdateAll. opts Object The opts argument received by Mapper#afterUpdateAll. result Object The result argument received by Mapper#afterUpdateAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 2232 Mapper#event:afterUpdateAll Mapper#updateAll Example function onAfterUpdateAll (props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); function onAfterUpdateAll (props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); afterUpdateListener(id, props, opts, result) Callback signature for the Mapper#event:afterUpdate event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#afterUpdate. props Object The props argument passed to Mapper#afterUpdate. opts Object The opts argument passed to Mapper#afterUpdate. result Object The result argument passed to Mapper#afterUpdate. Details Type Since Source See Function 3.0.0 Mapper.js, line 2143 Mapper#event:afterUpdate Mapper#update Example function onAfterUpdate (id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); function onAfterUpdate (id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); afterUpdateManyListener(records, opts, result) Callback signature for the Mapper#event:afterUpdateMany event. Method parameters: Name Type Description records Object The records argument received by Mapper#afterUpdateMany. opts Object The opts argument received by Mapper#afterUpdateMany. result Object The result argument received by Mapper#afterUpdateMany. Details Type Since Source See Function 3.0.0 Mapper.js, line 2322 Mapper#event:afterUpdateMany Mapper#updateMany Example function onAfterUpdateMany (records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); function onAfterUpdateMany (records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); beforeCreateListener(props, opts) Callback signature for the Mapper#event:beforeCreate event. Method parameters: Name Type Description props Object The props argument passed to Mapper#beforeCreate. opts Object The opts argument passed to Mapper#beforeCreate. Details Type Since Source See Function 3.0.0 Mapper.js, line 894 Mapper#event:beforeCreate Mapper#create Example function onBeforeCreate (props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); function onBeforeCreate (props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); beforeCreateManyListener(records, opts) Callback signature for the Mapper#event:beforeCreateMany event. Method parameters: Name Type Description records Object The records argument received by Mapper#beforeCreateMany. opts Object The opts argument received by Mapper#beforeCreateMany. Details Type Since Source See Function 3.0.0 Mapper.js, line 1122 Mapper#event:beforeCreateMany Mapper#createMany Example function onBeforeCreateMany (records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); function onBeforeCreateMany (records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); beforeDestroyAllListener(query, opts) Callback signature for the Mapper#event:beforeDestroyAll event. Method parameters: Name Type Description query Object The query argument passed to Mapper#beforeDestroyAll. opts Object The opts argument passed to Mapper#beforeDestroyAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 1547 Mapper#event:beforeDestroyAll Mapper#destroyAll Example function onBeforeDestroyAll (query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); function onBeforeDestroyAll (query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); beforeDestroyListener(id, opts) Callback signature for the Mapper#event:beforeDestroy event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#beforeDestroy. opts Object The opts argument passed to Mapper#beforeDestroy. Details Type Since Source See Function 3.0.0 Mapper.js, line 1460 Mapper#event:beforeDestroy Mapper#destroy Example function onBeforeDestroy (id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); function onBeforeDestroy (id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); beforeFindAllListener(query, opts) Callback signature for the Mapper#event:beforeFindAll event. Method parameters: Name Type Description query Object The query argument passed to Mapper#beforeFindAll. opts Object The opts argument passed to Mapper#beforeFindAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 1737 Mapper#event:beforeFindAll Mapper#findAll Example function onBeforeFindAll (query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); function onBeforeFindAll (query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); beforeFindListener(id, opts) Callback signature for the Mapper#event:beforeFind event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#beforeFind. opts Object The opts argument passed to Mapper#beforeFind. Details Type Since Source See Function 3.0.0 Mapper.js, line 1648 Mapper#event:beforeFind Mapper#find Example function onBeforeFind (id, opts) { // do something } store.on('beforeFind', onBeforeFind); function onBeforeFind (id, opts) { // do something } store.on('beforeFind', onBeforeFind); beforeUpdateAllListener(props, query, opts) Callback signature for the Mapper#event:beforeUpdateAll event. Method parameters: Name Type Description props Object The props argument received by Mapper#beforeUpdateAll. query Object The query argument received by Mapper#beforeUpdateAll. opts Object The opts argument received by Mapper#beforeUpdateAll. Details Type Since Source See Function 3.0.0 Mapper.js, line 2207 Mapper#event:beforeUpdateAll Mapper#updateAll Example function onBeforeUpdateAll (props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); function onBeforeUpdateAll (props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); beforeUpdateListener(id, props, opts) Callback signature for the Mapper#event:beforeUpdate event. Method parameters: Name Type Description id String | Number The id argument passed to Mapper#beforeUpdate. props Object The props argument passed to Mapper#beforeUpdate. opts Object The opts argument passed to Mapper#beforeUpdate. Details Type Since Source See Function 3.0.0 Mapper.js, line 2118 Mapper#event:beforeUpdate Mapper#update Example function onBeforeUpdate (id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); function onBeforeUpdate (id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); beforeUpdateManyListener(records, opts) Callback signature for the Mapper#event:beforeUpdateMany event. Method parameters: Name Type Description records Object The records argument received by Mapper#beforeUpdateMany. opts Object The opts argument received by Mapper#beforeUpdateMany. Details Type Since Source See Function 3.0.0 Mapper.js, line 2298 Mapper#event:beforeUpdateMany Mapper#updateMany Example function onBeforeUpdateMany (records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); function onBeforeUpdateMany (records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); Events afterCreate Fired during Mapper#create. See Mapper~afterCreateListener for how to listen for this event. Details Source See Mapper.js, line 910 Mapper~afterCreateListener Mapper#create afterCreateMany Fired during Mapper#createMany. See Mapper~afterCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1138 Mapper~afterCreateManyListener Mapper#createMany afterDestroy Fired during Mapper#destroy. See Mapper~afterDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1476 Mapper~afterDestroyListener Mapper#destroy afterDestroyAll Fired during Mapper#destroyAll. See Mapper~afterDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1563 Mapper~afterDestroyAllListener Mapper#destroyAll afterFind Fired during Mapper#find. See Mapper~afterFindListener for how to listen for this event. Details Source See Mapper.js, line 1664 Mapper~afterFindListener Mapper#find afterFindAll Fired during Mapper#findAll. See Mapper~afterFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1753 Mapper~afterFindAllListener Mapper#findAll afterUpdate Fired during Mapper#update. See Mapper~afterUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2135 Mapper~afterUpdateListener Mapper#update afterUpdateAll Fired during Mapper#updateAll. See Mapper~afterUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2224 Mapper~afterUpdateAllListener Mapper#updateAll afterUpdateMany Fired during Mapper#updateMany. See Mapper~afterUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2314 Mapper~afterUpdateManyListener Mapper#updateMany beforeCreate Fired during Mapper#create. See Mapper~beforeCreateListener for how to listen for this event. Details Source See Mapper.js, line 886 Mapper~beforeCreateListener Mapper#create beforeCreateMany Fired during Mapper#createMany. See Mapper~beforeCreateManyListener for how to listen for this event. Details Source See Mapper.js, line 1114 Mapper~beforeCreateManyListener Mapper#createMany beforeDestroy Fired during Mapper#destroy. See Mapper~beforeDestroyListener for how to listen for this event. Details Source See Mapper.js, line 1452 Mapper~beforeDestroyListener Mapper#destroy beforeDestroyAll Fired during Mapper#destroyAll. See Mapper~beforeDestroyAllListener for how to listen for this event. Details Source See Mapper.js, line 1539 Mapper~beforeDestroyAllListener Mapper#destroyAll beforeFind Fired during Mapper#find. See Mapper~beforeFindListener for how to listen for this event. Details Source See Mapper.js, line 1640 Mapper~beforeFindListener Mapper#find beforeFindAll Fired during Mapper#findAll. See Mapper~beforeFindAllListener for how to listen for this event. Details Source See Mapper.js, line 1729 Mapper~beforeFindAllListener Mapper#findAll beforeUpdate Fired during Mapper#update. See Mapper~beforeUpdateListener for how to listen for this event. Details Source See Mapper.js, line 2110 Mapper~beforeUpdateListener Mapper#update beforeUpdateAll Fired during Mapper#updateAll. See Mapper~beforeUpdateAllListener for how to listen for this event. Details Source See Mapper.js, line 2199 Mapper~beforeUpdateAllListener Mapper#updateAll beforeUpdateMany Fired during Mapper#updateMany. See Mapper~beforeUpdateManyListener for how to listen for this event. Details Source See Mapper.js, line 2290 Mapper~beforeUpdateManyListener Mapper#updateMany × Search results Close api.js-data.io • js-data.io "},"module-js-data.html":{"id":"module-js-data.html","title":"Module: js-data","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Module: js-data Registered as js-data in NPM and Bower. Also available from CDN.JS and JSDelivr. Details Source index.js, line 1 Examples Try it out npm i --save js-data@beta npm i --save js-data@beta Try it out bower i --save js-data@3.0.0-beta.1 bower i --save js-data@3.0.0-beta.1 Try it out &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; Try it out &lt;script src=\"https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/js-data/3.0.0-beta.1/js-data.min.js\"&gt;&lt;/script&gt; Try it out &lt;script src=\"/path/to/js-data.min.js\"&gt;&lt;/script&gt; &lt;script&gt; console.log(JSData.version.full); // \"3.0.0-beta.1\" &lt;/script&gt; &lt;script src=\"/path/to/js-data.min.js\"&gt;&lt;/script&gt; &lt;script&gt; console.log(JSData.version.full); // \"3.0.0-beta.1\" &lt;/script&gt; Try it out var JSData = require('js-data'); var JSData = require('js-data'); Try it out import * as JSData from 'js-data'; import * as JSData from 'js-data'; Try it out define('myApp', ['js-data'], function (JSData) { ... }); define('myApp', ['js-data'], function (JSData) { ... }); Members &lt;static&gt; Collection JSData's Collection class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 44 Components of JSData: Collection Collection Example import { Collection } from 'js-data'; const collection = new Collection(); import { Collection } from 'js-data'; const collection = new Collection(); &lt;static&gt; Component JSData's Component class. Most components in JSData extend this class. Details Type Since Source See Constructor 3.0.0 index.js, line 59 Component Example import { Component } from 'js-data'; // Make a custom component. const MyComponent = Component.extend({ myMethod (someArg) { ... } }); import { Component } from 'js-data'; // Make a custom component. const MyComponent = Component.extend({ myMethod (someArg) { ... } }); &lt;static&gt; Container JSData's Container class. Defines and manages Mappers. Used in Node.js and in the browser, though in the browser you may want to use DataStore instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 77 Components of JSData: Container Container Example import { Container } from 'js-data'; const store = new Container(); import { Container } from 'js-data'; const store = new Container(); &lt;static&gt; DataStore JSData's DataStore class. Primarily for use in the browser. In Node.js you probably want to use Container instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 94 Components of JSData: DataStore DataStore Example import { DataStore } from 'js-data'; const store = new DataStore(); import { DataStore } from 'js-data'; const store = new DataStore(); &lt;static&gt; Index JSData's Index class, based on mindex. Details Type Since Source See Constructor 3.0.0 index.js, line 110 Index &lt;static&gt; LinkedCollection JSData's LinkedCollection class. Used by the DataStore component. If you need to create a collection manually, you should probably use the Collection class. Details Type Since Source See Constructor 3.0.0 index.js, line 120 DataStore LinkedCollection &lt;static&gt; Mapper JSData's Mapper class. The core of the ORM. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 133 Modeling your data Components of JSData: Mapper Container Mapper Examples Try it out import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); Try it out import { Mapper } from 'js-data'; const UserMapper = new Mapper({ name: 'user' }); import { Mapper } from 'js-data'; const UserMapper = new Mapper({ name: 'user' }); &lt;static&gt; Query JSData's Query class. Used by the Collection component. Details Type Since Source See Constructor 3.0.0 index.js, line 155 Query &lt;static&gt; Record JSData's Record class. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 165 Components of JSData: Record Record Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); import { Container } from 'js-data'; const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); &lt;static&gt; Schema JSData's Schema class. Implements http://json-schema.org/draft-04. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 182 Components of JSData: schema JSData's Schema Syntax Schema http://json-schema.org/ Example import { Container, Schema } from 'js-data'; const userSchema = new Schema({ properties: { id: { type: 'string' }, name: { type: 'string' } } }); const store = new Container(); store.defineMapper('user', { schema: userSchema }); import { Container, Schema } from 'js-data'; const userSchema = new Schema({ properties: { id: { type: 'string' }, name: { type: 'string' } } }); const store = new Container(); store.defineMapper('user', { schema: userSchema }); &lt;static&gt; Settable JSData's Settable class. Details Type Since Source See Constructor 3.0.0 index.js, line 208 Settable Example import { Settable } from 'js-data'; const obj = new Settable(); obj.set('secret', 'value'); console.log(JSON.stringify(obj)); // {} import { Settable } from 'js-data'; const obj = new Settable(); obj.set('secret', 'value'); console.log(JSON.stringify(obj)); // {} &lt;static&gt; SimpleStore JSData's SimpleStore class. Primarily for use in the browser. In Node.js you probably want to use Container instead. Details Type Since Source Tutorials See Constructor 3.0.0 index.js, line 224 Components of JSData: SimpleStore SimpleStore Example import { SimpleStore } from 'js-data'; const store = new SimpleStore(); import { SimpleStore } from 'js-data'; const store = new SimpleStore(); &lt;static&gt; utils JSData's utility methods. Details Type Since Source See Object 3.0.0 index.js, line 29 utils Properties: Name Type Description Promise Function See utils.Promise. Example import { utils } from 'js-data'; console.log(utils.isString('foo')); // true import { utils } from 'js-data'; console.log(utils.isString('foo')); // true &lt;static&gt; version Describes the version of this JSData object. Details Type Since Source Object 2.0.0 index.js, line 240 Properties: Name Type Description full String The full semver value. major Number The major version number. minor Number The minor version number. patch Number The patch version number. alpha String | Boolean The alpha version value, otherwise false if the current version is not alpha. beta String | Boolean The beta version value, otherwise false if the current version is not beta. Example console.log(JSData.version.full); // \"3.0.0-beta.1\" console.log(JSData.version.full); // \"3.0.0-beta.1\" Methods &lt;static&gt; belongsTo(related, opts) BelongsTo relation decorator. You probably won't use this directly. Method parameters: Name Type Description related Mapper The relation the target belongs to. opts Object Configuration options. Properties Name Type Description foreignKey String The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 4 &lt;static&gt; hasMany(related, opts) HasMany relation decorator. You probably won't use this directly. Method parameters: Name Type Description related Mapper The relation of which the target has many. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 24 &lt;static&gt; hasOne(related, opts) HasOne relation decorator. You probably won't use this directly. Method parameters: Name Type Description related Mapper The relation of which the target has one. opts Object Configuration options. Properties Name Type Argument Description foreignKey String &lt;optional&gt; The field that holds the primary key of the related record. localField String The field that holds a reference to the related record object. Return value: Type Description Function Invocation function, which accepts the target as the only parameter. Details Source decorators.js, line 44 × Search results Close api.js-data.io • js-data.io "},"Query.html":{"id":"Query.html","title":"Class: Query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Query Query new Query(collection) A class used by the Collection class to build queries to be executed against the collection's data. An instance of Query is returned by Collection#query. Query instances are typically short-lived, and you shouldn't have to create them yourself. Just use Collection#query. import { Query } from 'js-data'; Method parameters: Name Type Description collection Collection The collection on which this query operates. Details Since Source 3.0.0 Query.js, line 25 Example Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ] store.add('post', posts); const drafts = store.query('post').filter({ status: 'draft' }).limit(2).run(); console.log(drafts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ] store.add('post', posts); const drafts = store.query('post').filter({ status: 'draft' }).limit(2).run(); console.log(drafts); Extends This class extends the Component class. Members &lt;static&gt; ops The filtering operators supported by Query#filter, and which are implemented by adapters (for the most part). Details Type Since Source Object 3.0.0 Query.js, line 940 Properties: Name Type Description == Function Equality operator. != Function Inequality operator. &gt; Function Greater than operator. &gt;= Function Greater than (inclusive) operator. &lt; Function Less than operator. Function Less than (inclusive) operator. isectEmpty Function Operator that asserts that the intersection between two arrays is empty. isectNotEmpty Function Operator that asserts that the intersection between two arrays is not empty. in Function Operator that asserts whether a value is in an array. notIn Function Operator that asserts whether a value is not in an array. contains Function Operator that asserts whether an array contains a value. notContains Function Operator that asserts whether an array does not contain a value. Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store.filter('post', { status: 'published', limit: 2 }); console.log(publishedPosts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store.filter('post', { status: 'published', limit: 2 }); console.log(publishedPosts); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store.filter('post', { where: { status: { '==': 'published' } }, limit: 2 }); console.log(publishedPosts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store.filter('post', { where: { status: { '==': 'published' } }, limit: 2 }); console.log(publishedPosts); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store .query('post') .filter({ status: 'published' }) .limit(2) .run(); console.log(publishedPosts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store .query('post') .filter({ status: 'published' }) .limit(2) .run(); console.log(publishedPosts); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store .query('post') .filter({ where: { status: { '==': 'published' } } }) .limit(2) .run(); console.log(publishedPosts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const publishedPosts = store .query('post') .filter({ where: { status: { '==': 'published' } } }) .limit(2) .run(); console.log(publishedPosts); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const myPublishedPosts = store.filter('post', { where: { status: { '==': 'published' }, user_id: { '==': currentUser.id } } }); console.log(myPublishedPosts); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'published', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } ]; store.add('post', posts); const myPublishedPosts = store.filter('post', { where: { status: { '==': 'published' }, user_id: { '==': currentUser.id } } }); console.log(myPublishedPosts); collection The Collection on which this query operates. Details Type Since Source Collection 3.0.0 Query.js, line 61 data The current data result of this query. Details Type Since Source Array 3.0.0 Query.js, line 70 debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Query: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Query class. Details Since Source 3.0.0 Query.js, line 1141 Example Try it out const JSData = require('js-data'); const { Query } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomQueryClass extends Query { foo () { return 'bar'; } static beep () { return 'boop'; } } const customQuery = new CustomQueryClass(); console.log(customQuery.foo()); console.log(CustomQueryClass.beep()); // Extend the class using alternate method. const OtherQueryClass = Query.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherQuery = new OtherQueryClass(); console.log(otherQuery.foo()); console.log(OtherQueryClass.beep()); // Extend the class, providing a custom constructor. function AnotherQueryClass (collection) { Query.call(this, collection); this.created_at = new Date().getTime(); } Query.extend({ constructor: AnotherQueryClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherQuery = new AnotherQueryClass(); console.log(anotherQuery.created_at); console.log(anotherQuery.foo()); console.log(AnotherQueryClass.beep()); const JSData = require('js-data'); const { Query } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomQueryClass extends Query { foo () { return 'bar'; } static beep () { return 'boop'; } } const customQuery = new CustomQueryClass(); console.log(customQuery.foo()); console.log(CustomQueryClass.beep()); // Extend the class using alternate method. const OtherQueryClass = Query.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherQuery = new OtherQueryClass(); console.log(otherQuery.foo()); console.log(OtherQueryClass.beep()); // Extend the class, providing a custom constructor. function AnotherQueryClass (collection) { Query.call(this, collection); this.created_at = new Date().getTime(); } Query.extend({ constructor: AnotherQueryClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherQuery = new AnotherQueryClass(); console.log(anotherQuery.created_at); console.log(anotherQuery.foo()); console.log(AnotherQueryClass.beep()); between(leftKeys, rightKeys, opts) Find all entities between two boundaries. Method parameters: Name Type Argument Description leftKeys Array Keys defining the left boundary. rightKeys Array Keys defining the right boundary. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. leftInclusive Boolean &lt;optional&gt; true Whether to include entities on the left boundary. rightInclusive Boolean &lt;optional&gt; false Whether to include entities on the left boundary. limit Boolean &lt;optional&gt; Limit the result to a certain number. offset Boolean &lt;optional&gt; The number of resulting entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 164 Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users) const filteredUsers = store .query('user') .between(18, 30, { index: 'age' }) .run(); console.log(filteredUsers); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users) const filteredUsers = store .query('user') .between(18, 30, { index: 'age' }) .run(); console.log(filteredUsers); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users) const filteredUsers = store .query('user') .between([18], [30], { index: 'age' }) .run(); console.log(filteredUsers); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users) const filteredUsers = store .query('user') .between([18], [30], { index: 'age' }) .run(); console.log(filteredUsers); compare(orderBy, index, a, b) The comparison function used by the Query class. Method parameters: Name Type Description orderBy Array An orderBy clause used for sorting and sub-sorting. index Number The index of the current orderBy clause being used. a * The first item in the comparison. b * The second item in the comparison. Return value: Type Description Number -1 if b should preceed a. 0 if a and b are equal. 1 if a should preceed b. Details Since Source 3.0.0 Query.js, line 233 dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); evaluate(value, op, predicate) Predicate evaluation function used by the Query class. Method parameters: Name Type Description value * The value to evaluate. op String The operator to use in this evaluation. predicate * The predicate to use in this evaluation. Return value: Type Description Boolean Whether the value passed the evaluation or not. Details Since Source 3.0.0 Query.js, line 279 filter(queryOrFn, thisArg) Find the record or records that match the provided query or are accepted by the provided filter function. Method parameters: Name Type Argument Default Description queryOrFn Object | Function &lt;optional&gt; {} Selection query or filter function. thisArg Function &lt;optional&gt; Context to which to bind queryOrFn if queryOrFn is a function. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 301 Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } { author: 'Peter', age: 25, status: 'deleted', id: 6 }, { author: 'Sally', age: 21, status: 'draft', id: 7 }, { author: 'Jim', age: 27, status: 'draft', id: 8 }, { author: 'Jim', age: 27, status: 'published', id: 9 }, { author: 'Jason', age: 55, status: 'published', id: 10 } ]; store.add('post', posts); const results = store .query('post') .filter({ where: { status: { '==': 'draft' }, age: { '&lt;': 30 } } }) .run(); console.log(results); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } { author: 'Peter', age: 25, status: 'deleted', id: 6 }, { author: 'Sally', age: 21, status: 'draft', id: 7 }, { author: 'Jim', age: 27, status: 'draft', id: 8 }, { author: 'Jim', age: 27, status: 'published', id: 9 }, { author: 'Jason', age: 55, status: 'published', id: 10 } ]; store.add('post', posts); const results = store .query('post') .filter({ where: { status: { '==': 'draft' }, age: { '&lt;': 30 } } }) .run(); console.log(results); Try it out const posts = query .filter(function (post) { return post.isReady(); }) .run(); const posts = query .filter(function (post) { return post.isReady(); }) .run(); forEach(forEachFn, thisArg) Iterate over all entities. Method parameters: Name Type Argument Description forEachFn Function Iteration function. thisArg * &lt;optional&gt; Context to which to bind forEachFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 672 get(keyList, opts) Find the entity or entities that match the provided key. Method parameters: Name Type Argument Description keyList Array Key(s) defining the entity to retrieve. If keyList is not an array (i.e. for a single-value key), it will be wrapped in an array. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description string String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 686 Examples Try it out const entities = query.get(25).run(); const entities = query.get(25).run(); Try it out const entities = query.get([25]).run(); const entities = query.get([25]).run(); Try it out const activeAdmins = query.get(['active', 'admin'], { index: 'activityAndRoles' }).run(); const activeAdmins = query.get(['active', 'admin'], { index: 'activityAndRoles' }).run(); Try it out const niceDays = query.get(['sunny', 'humid', 'calm'], { index: 'weatherConditions' }).run(); const niceDays = query.get(['sunny', 'humid', 'calm'], { index: 'weatherConditions' }).run(); getAll(keyList, opts) Find the entity or entities that match the provided keyLists. Method parameters: Name Type Argument Description keyList Array &lt;optional&gt; &lt;repeatable&gt; Provide one or more keyLists, and all entities matching each keyList will be retrieved. If no keyLists are provided, all entities will be returned. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description index String &lt;optional&gt; Name of the secondary index to use in the query. If no index is specified, the main index is used. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 732 Examples Try it out const posts = query.getAll('draft', 'inReview', { index: 'status' }).run(); const posts = query.getAll('draft', 'inReview', { index: 'status' }).run(); Try it out const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run(); const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run(); getData() Return the current data result of this query. Return value: Type Description Array The data in this query. Details Since Source 3.0.0 Query.js, line 772 like(pattern, flags) Implementation used by the like operator. Takes a pattern and flags and returns a RegExp instance that can test strings. Method parameters: Name Type Description pattern String Testing pattern. flags String Flags for the regular expression. Return value: Type Description RegExp Regular expression for testing strings. Details Since Source 3.0.0 Query.js, line 786 limit(num) Limit the result. Method parameters: Name Type Description num Number The maximum number of entities to keep in the result. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 800 Example Try it out const store = new JSData.DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ]; store.add('post', posts); const results = store.query('post').limit(2).run(); console.log(results); const store = new JSData.DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ]; store.add('post', posts); const results = store.query('post').limit(2).run(); console.log(results); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log map(mapFn, thisArg) Apply a mapping function to the result data. Method parameters: Name Type Argument Description mapFn Function Mapping function. thisArg * &lt;optional&gt; Context to which to bind mapFn. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 831 Example const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users); const ages = store .query('user') .map(function (user) { return user.age; }) .run(); console.log(ages); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('user'); const users = [ { name: 'Peter', age: 25, id: 1 }, { name: 'Jim', age: 19, id: 2 }, { name: 'Mike', age: 17, id: 3 }, { name: 'Alan', age: 29, id: 4 }, { name: 'Katie', age: 33, id: 5 } ]; store.add('user', users); const ages = store .query('user') .map(function (user) { return user.age; }) .run(); console.log(ages); mapCall(funcName) Return the result of calling the specified function on each item in this collection's main index. Method parameters: Name Type Description funcName String Name of function to call Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 868 Example const stringAges = UserCollection.query().mapCall('toString').run(); const stringAges = UserCollection.query().mapCall('toString').run(); off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; run() Complete the execution of the query and return the resulting data. Return value: Type Description Array The result of executing this query. Details Since Source 3.0.0 Query.js, line 888 skip(num) Skip a number of results. Method parameters: Name Type Description num Number The number of entities to skip. Return value: Type Description Query A reference to itself for chaining. Details Since Source 3.0.0 Query.js, line 901 Example Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ]; store.add('post', posts); const results = store.query('post').skip(2).run(); console.log(results); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'draft', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'draft', id: 5 } ]; store.add('post', posts); const results = store.query('post').skip(2).run(); console.log(results); × Search results Close api.js-data.io • js-data.io "},"query_.html":{"id":"query_.html","title":"Namespace: query","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Namespace: query query Selection query as defined by JSData's Query Syntax. Details Since Source Tutorials 3.0.0 Query.js, line 356 JSData's Query Syntax Properties: Name Type Argument Description limit Number &lt;optional&gt; See query.limit. offset Number &lt;optional&gt; See query.offset. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. skip Number &lt;optional&gt; Alias for query.offset. sort String | Array.&lt;Array&gt; &lt;optional&gt; Alias for query.orderBy. where Object &lt;optional&gt; See query.where. Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') store.findAll('post').then((posts) =&gt; { console.log(posts); // [...] }); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') store.findAll('post').then((posts) =&gt; { console.log(posts); // [...] }); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = store.filter('post'); console.log(posts); // [...] const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const posts = store.filter('post'); console.log(posts); // [...] Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 2; let currentPage = 3; store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } { author: 'Peter', age: 25, status: 'deleted', id: 6 }, { author: 'Sally', age: 21, status: 'draft', id: 7 }, { author: 'Jim', age: 27, status: 'draft', id: 8 }, { author: 'Jim', age: 27, status: 'published', id: 9 }, { author: 'Jason', age: 55, status: 'published', id: 10 } ]; store.add('post', posts); // Retrieve a filtered page of blog posts // Would typically replace filter with findAll const results = store.filter('post', { where: { status: { // WHERE status = 'published' '==': 'published' }, author: { // AND author IN ('bob', 'alice') 'in': ['bob', 'alice'], // OR author IN ('karen') '|in': ['karen'] } }, orderBy: [ // ORDER BY date_published DESC, ['date_published', 'DESC'], // ORDER BY title ASC ['title', 'ASC'] ], // LIMIT 2 limit: PAGE_SIZE, // SKIP 4 offset: PAGE_SIZE * (currentPage - 1) }); console.log(results); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 2; let currentPage = 3; store.defineMapper('post'); const posts = [ { author: 'John', age: 30, status: 'published', id: 1 }, { author: 'Sally', age: 31, status: 'published', id: 2 }, { author: 'Mike', age: 32, status: 'draft', id: 3 }, { author: 'Adam', age: 33, status: 'deleted', id: 4 }, { author: 'Adam', age: 33, status: 'published', id: 5 } { author: 'Peter', age: 25, status: 'deleted', id: 6 }, { author: 'Sally', age: 21, status: 'draft', id: 7 }, { author: 'Jim', age: 27, status: 'draft', id: 8 }, { author: 'Jim', age: 27, status: 'published', id: 9 }, { author: 'Jason', age: 55, status: 'published', id: 10 } ]; store.add('post', posts); // Retrieve a filtered page of blog posts // Would typically replace filter with findAll const results = store.filter('post', { where: { status: { // WHERE status = 'published' '==': 'published' }, author: { // AND author IN ('bob', 'alice') 'in': ['bob', 'alice'], // OR author IN ('karen') '|in': ['karen'] } }, orderBy: [ // ORDER BY date_published DESC, ['date_published', 'DESC'], // ORDER BY title ASC ['title', 'ASC'] ], // LIMIT 2 limit: PAGE_SIZE, // SKIP 4 offset: PAGE_SIZE * (currentPage - 1) }); console.log(results); Members &lt;static&gt; limit Maximum number of records to retrieve. Details Type Since Source See Number 3.0.0 Query.js, line 611 http://www.js-data.io/v3.0/docs/query-syntax Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const PAGE_SIZE = 10 let currentPage = 1 store.findAll('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const PAGE_SIZE = 10 let currentPage = 1 store.findAll('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 5 let currentPage = 2 store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 1 }, { author: 'Sally', age: 31, id: 2 }, { author: 'Mike', age: 32, id: 3 }, { author: 'Adam', age: 33, id: 4 }, { author: 'Adam', age: 33, id: 5 }, { author: 'Peter', age: 25, id: 6 }, { author: 'Sally', age: 21, id: 7 }, { author: 'Jim', age: 27, id: 8 }, { author: 'Jim', age: 27, id: 9 }, { author: 'Jason', age: 55, id: 10 } ]; store.add('post', posts); const results = store.filter('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); console.log(results) const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 5 let currentPage = 2 store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 1 }, { author: 'Sally', age: 31, id: 2 }, { author: 'Mike', age: 32, id: 3 }, { author: 'Adam', age: 33, id: 4 }, { author: 'Adam', age: 33, id: 5 }, { author: 'Peter', age: 25, id: 6 }, { author: 'Sally', age: 21, id: 7 }, { author: 'Jim', age: 27, id: 8 }, { author: 'Jim', age: 27, id: 9 }, { author: 'Jason', age: 55, id: 10 } ]; store.add('post', posts); const results = store.filter('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); console.log(results) &lt;static&gt; offset Number of records to skip. Details Type Since Source See Number 3.0.0 Query.js, line 554 http://www.js-data.io/v3.0/docs/query-syntax Examples Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const PAGE_SIZE = 10; let currentPage = 1; store.findAll('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post'); const PAGE_SIZE = 10; let currentPage = 1; store.findAll('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 5; let currentPage = 2; store.defineMapper('post'); const posts = [ { author: 'John', age: 30, id: 1 }, { author: 'Sally', age: 31, id: 2 }, { author: 'Mike', age: 32, id: 3 }, { author: 'Adam', age: 33, id: 4 }, { author: 'Adam', age: 33, id: 5 }, { author: 'Peter', age: 25, id: 6 }, { author: 'Sally', age: 21, id: 7 }, { author: 'Jim', age: 27, id: 8 }, { author: 'Jim', age: 27, id: 9 }, { author: 'Jason', age: 55, id: 10 } ]; store.add('post', posts); const results = store.filter('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); console.log(results) const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); const PAGE_SIZE = 5; let currentPage = 2; store.defineMapper('post'); const posts = [ { author: 'John', age: 30, id: 1 }, { author: 'Sally', age: 31, id: 2 }, { author: 'Mike', age: 32, id: 3 }, { author: 'Adam', age: 33, id: 4 }, { author: 'Adam', age: 33, id: 5 }, { author: 'Peter', age: 25, id: 6 }, { author: 'Sally', age: 21, id: 7 }, { author: 'Jim', age: 27, id: 8 }, { author: 'Jim', age: 27, id: 9 }, { author: 'Jason', age: 55, id: 10 } ]; store.add('post', posts); const results = store.filter('post', { offset: PAGE_SIZE * (currentPage 1) limit: PAGE_SIZE }); console.log(results) &lt;static&gt; orderBy Determines how records should be ordered in the result. Details Type Since Source See String | Array.&lt;Array&gt; 3.0.0 Query.js, line 516 http://www.js-data.io/v3.0/docs/query-syntax Example Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 5 }, { author: 'Sally', age: 31, id: 6 }, { author: 'Mike', age: 32, id: 7 }, { author: 'Adam', age: 33, id: 8 }, { author: 'Adam', age: 33, id: 9 } ]; store.add('post', posts); const results = store.filter('post', { orderBy:[['author','ASC'],['id','DESC']] }); console.log(results); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 5 }, { author: 'Sally', age: 31, id: 6 }, { author: 'Mike', age: 32, id: 7 }, { author: 'Adam', age: 33, id: 8 }, { author: 'Adam', age: 33, id: 9 } ]; store.add('post', posts); const results = store.filter('post', { orderBy:[['author','ASC'],['id','DESC']] }); console.log(results); &lt;static&gt; where Filtering criteria. Records that do not meet this criteria will be exluded from the result. Details Type Since Source See Object 3.0.0 Query.js, line 448 http://www.js-data.io/v3.0/docs/query-syntax Example Try it out const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 5 }, { author: 'Sally', age: 31, id: 6 }, { author: 'Mike', age: 32, id: 7 }, { author: 'Adam', age: 33, id: 8 }, { author: 'Adam', age: 33, id: 9 } ]; store.add('post', posts); const results = store.filter('post', { where: { age: { '&gt;=': 30 } } }); console.log(results); const JSData = require('js-data'); const { DataStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new DataStore(); store.defineMapper('post') const posts = [ { author: 'John', age: 30, id: 5 }, { author: 'Sally', age: 31, id: 6 }, { author: 'Mike', age: 32, id: 7 }, { author: 'Adam', age: 33, id: 8 }, { author: 'Adam', age: 33, id: 9 } ]; store.add('post', posts); const results = store.filter('post', { where: { age: { '&gt;=': 30 } } }); console.log(results); × Search results Close api.js-data.io • js-data.io "},"Record.html":{"id":"Record.html","title":"Class: Record","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Record Record new Record(props, opts) js-data's Record class. An instance of Record corresponds to an in-memory representation of a single row or document in a database, Firebase, localstorage, etc. Basically, a Record instance represents whatever kind of entity in your persistence layer that has a primary key. import {Record} from 'js-data' Method parameters: Name Type Argument Description props Object &lt;optional&gt; The initial properties of the new Record instance. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description noValidate Boolean &lt;optional&gt; false Whether to skip validation on the initial properties. validateOnSet Boolean &lt;optional&gt; true Whether to enable setter validation on properties after the Record has been initialized. Details Since Source 3.0.0 Record.js, line 27 Examples Try it out const JSData = require('js-data'); const { Record } = JSData; console.log('Using JSData v' + JSData.version.full); // Instantiate a plain record let record = new Record(); console.log('record: ' + JSON.stringify(record)); // You can supply properties on instantiation record = new Record({ name: 'John' }); console.log('record: ' + JSON.stringify(record)); const JSData = require('js-data'); const { Record } = JSData; console.log('Using JSData v' + JSData.version.full); // Instantiate a plain record let record = new Record(); console.log('record: ' + JSON.stringify(record)); // You can supply properties on instantiation record = new Record({ name: 'John' }); console.log('record: ' + JSON.stringify(record)); Try it out const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); // Instantiate a record that's associated with a Mapper: const UserMapper = new Mapper({ name: 'user' }); const User = UserMapper.recordClass; const user = UserMapper.createRecord({ name: 'John' }); const user2 = new User({ name: 'Sally' }); console.log('user: ' + JSON.stringify(user)); console.log('user2: ' + JSON.stringify(user2)); const JSData = require('js-data'); const { Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); // Instantiate a record that's associated with a Mapper: const UserMapper = new Mapper({ name: 'user' }); const User = UserMapper.recordClass; const user = UserMapper.createRecord({ name: 'John' }); const user2 = new User({ name: 'Sally' }); console.log('user: ' + JSON.stringify(user)); console.log('user2: ' + JSON.stringify(user2)); Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); // Instantiate a record that's associated with a store's Mapper const user = store.createRecord('user', { name: 'John' }); console.log('user: ' + JSON.stringify(user)); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); // Instantiate a record that's associated with a store's Mapper const user = store.createRecord('user', { name: 'John' }); console.log('user: ' + JSON.stringify(user)); Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); // Validate on instantiation const user = store.createRecord('user', { name: 1234 }); console.log('user: ' + JSON.stringify(user)); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); // Validate on instantiation const user = store.createRecord('user', { name: 1234 }); console.log('user: ' + JSON.stringify(user)); Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); // Skip validation on instantiation const user = store.createRecord('user', { name: 1234 }, { noValidate: true }); console.log('user: ' + JSON.stringify(user)); console.log('user.isValid(): ' + user.isValid()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); // Skip validation on instantiation const user = store.createRecord('user', { name: 1234 }, { noValidate: true }); console.log('user: ' + JSON.stringify(user)); console.log('user.isValid(): ' + user.isValid()); Extends This class extends the Component class. Members debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Record: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Record class. Details Since Source 3.0.0 Record.js, line 883 Example Try it out const JSData = require('js-data'); const { Record } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomRecordClass extends Record { foo () { return 'bar'; } static beep () { return 'boop'; } } const customRecord = new CustomRecordClass(); console.log(customRecord.foo()); console.log(CustomRecordClass.beep()); // Extend the class using alternate method. const OtherRecordClass = Record.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherRecord = new OtherRecordClass(); console.log(otherRecord.foo()); console.log(OtherRecordClass.beep()); // Extend the class, providing a custom constructor. function AnotherRecordClass () { Record.call(this); this.created_at = new Date().getTime(); } Record.extend({ constructor: AnotherRecordClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherRecord = new AnotherRecordClass(); console.log(anotherRecord.created_at); console.log(anotherRecord.foo()); console.log(AnotherRecordClass.beep()); const JSData = require('js-data'); const { Record } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomRecordClass extends Record { foo () { return 'bar'; } static beep () { return 'boop'; } } const customRecord = new CustomRecordClass(); console.log(customRecord.foo()); console.log(CustomRecordClass.beep()); // Extend the class using alternate method. const OtherRecordClass = Record.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherRecord = new OtherRecordClass(); console.log(otherRecord.foo()); console.log(OtherRecordClass.beep()); // Extend the class, providing a custom constructor. function AnotherRecordClass () { Record.call(this); this.created_at = new Date().getTime(); } Record.extend({ constructor: AnotherRecordClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherRecord = new AnotherRecordClass(); console.log(anotherRecord.created_at); console.log(anotherRecord.foo()); console.log(AnotherRecordClass.beep()); _mapper() Returns the Mapper paired with this record's class, if any. Return value: Type Description Mapper The Mapper paired with this record's class, if any. Details Since Source 3.0.0 Record.js, line 155 afterLoadRelations(relations, opts) Lifecycle hook. Method parameters: Name Type Description relations Array.&lt;String&gt; The relations argument passed to Record#loadRelations. opts Object The opts argument passed to Record#loadRelations. Details Since Source 3.0.0 Record.js, line 170 beforeLoadRelations(relations, opts) Lifecycle hook. Method parameters: Name Type Description relations Array.&lt;String&gt; The relations argument passed to Record#loadRelations. opts Object The opts argument passed to Record#loadRelations. Details Since Source 3.0.0 Record.js, line 180 changeHistory() Return the change history of this record since it was instantiated or Record#commit was called. Details Since Source 3.0.0 Record.js, line 190 changes(opts) Return changes to this record since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Object Object describing the changes to this record since it was instantiated or its Record#commit method was last called. Details Since Source 3.0.0 Record.js, line 201 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user changes: ' + JSON.stringify(user.changes())); user.name = 'John'; console.log('user changes: ' + JSON.stringify(user.changes())); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user changes: ' + JSON.stringify(user.changes())); user.name = 'John'; console.log('user changes: ' + JSON.stringify(user.changes())); commit(opts) Make the record's current in-memory state it's only state, with any previous property values being set to current values. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Passed to Record#toJSON. Details Since Source 3.0.0 Record.js, line 230 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user hasChanges: ' + user.hasChanges()); user.name = 'John'; console.log('user hasChanges: ' + user.hasChanges()); user.commit(); console.log('user hasChanges: ' + user.hasChanges()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user hasChanges: ' + user.hasChanges()); user.name = 'John'; console.log('user hasChanges: ' + user.hasChanges()); user.commit(); console.log('user hasChanges: ' + user.hasChanges()); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg destroy(opts) Call Mapper#destroy using this record's primary key. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options passed to Mapper#destroy. Return value: Type Description Promise The result of calling Mapper#destroy with the primary key of this record. Details Since Source 3.0.0 Record.js, line 259 Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('user'); store.find('user', 1234).then((user) =&gt; { console.log(user.id); // 1234 // Destroy this user from the database return user.destroy(); }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('user'); store.find('user', 1234).then((user) =&gt; { console.log(user.id); // 1234 // Destroy this user from the database return user.destroy(); }); emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); get(key) Return the value at the given path for this instance. Method parameters: Name Type Description key String Path of value to retrieve. Return value: Type Description * Value at path. Details Since Source 3.0.0 Record.js, line 288 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'Bob' }); console.log('user.get(\"name\"): ' + user.get('name')); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'Bob' }); console.log('user.get(\"name\"): ' + user.get('name')); hasChanges(opts) Return whether this record has changed since it was instantiated or Record#commit was called. Method parameters: Name Type Argument Description opts &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Boolean Return whether the record has changed since it was instantiated or since its Record#commit method was called. Details Since Source 3.0.0 Record.js, line 310 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user hasChanges: ' + user.hasChanges()); user.name = 'John'; console.log('user hasChanges: ' + user.hasChanges()); user.commit(); console.log('user hasChanges: ' + user.hasChanges()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user hasChanges: ' + user.hasChanges()); user.name = 'John'; console.log('user hasChanges: ' + user.hasChanges()); user.commit(); console.log('user hasChanges: ' + user.hasChanges()); isNew() Return whether the record is unsaved. Records that have primary keys are considered \"saved\". Records without primary keys are considered \"unsaved\". Return value: Type Description Boolean Whether the record is unsaved. Details Since Source 3.0.0 Record.js, line 340 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { id: 1234 }); const user2 = store.createRecord('user'); console.log('user isNew: ' + user.isNew()); // false console.log('user2 isNew: ' + user2.isNew()); // true const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { id: 1234 }); const user2 = store.createRecord('user'); console.log('user isNew: ' + user.isNew()); // false console.log('user2 isNew: ' + user2.isNew()); // true isValid(opts) Return whether the record in its current state passes validation. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Passed to Mapper#validate. Return value: Type Description Boolean Whether the record in its current state passes validation. Details Since Source 3.0.0 Record.js, line 365 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 1234 }, { noValidate: true // this allows us to put the record into an invalid state }); console.log('user isValid: ' + user.isValid()); user.name = 'John'; console.log('user isValid: ' + user.isValid()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 1234 }, { noValidate: true // this allows us to put the record into an invalid state }); console.log('user isValid: ' + user.isValid()); user.name = 'John'; console.log('user isValid: ' + user.isValid()); loadRelations(relations, opts) Lazy load relations of this record, to be attached to the record once their loaded. Method parameters: Name Type Argument Description relations Array.&lt;String&gt; &lt;optional&gt; List of relations to load. Can use localField names or Mapper names to pick relations. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Resolves with the record, with the loaded relations now attached. Details Since Source 3.0.0 Record.js, line 429 Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('user', { relations: { hasMany: { post: { localField: 'posts', foreignKey: 'user_id' } } } }); store.defineMapper('post', { relations: { belongsTo: { user: { localField: 'user', foreignKey: 'user_id' } } } }); store.find('user', 1234).then((user) =&gt; { console.log(user.id); // 1234 // Load the user's post relations return user.loadRelations(['post']); }).then((user) =&gt; { console.log(user.posts); // [{...}, {...}, ...] }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('user', { relations: { hasMany: { post: { localField: 'posts', foreignKey: 'user_id' } } } }); store.defineMapper('post', { relations: { belongsTo: { user: { localField: 'user', foreignKey: 'user_id' } } } }); store.find('user', 1234).then((user) =&gt; { console.log(user.id); // 1234 // Load the user's post relations return user.loadRelations(['post']); }).then((user) =&gt; { console.log(user.posts); // [{...}, {...}, ...] }); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; previous(key) Return the properties with which this record was instantiated. Method parameters: Name Type Argument Description key String &lt;optional&gt; If specified, return just the initial value of the given key. Return value: Type Description Object The initial properties of this record. Details Since Source 3.0.0 Record.js, line 553 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'William' }); console.log('user previous: ' + JSON.stringify(user.previous())); user.name = 'Bob'; console.log('user previous: ' + JSON.stringify(user.previous())); user.commit(); console.log('user previous: ' + JSON.stringify(user.previous())); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'William' }); console.log('user previous: ' + JSON.stringify(user.previous())); user.name = 'Bob'; console.log('user previous: ' + JSON.stringify(user.previous())); user.commit(); console.log('user previous: ' + JSON.stringify(user.previous())); revert(opts) Revert changes to this record back to the properties it had when it was instantiated. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description preserve Array.&lt;String&gt; &lt;optional&gt; Array of strings or Regular Expressions denoting properties that should not be reverted. Details Since Source 3.0.0 Record.js, line 584 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'William' }); console.log('user: ' + JSON.stringify(user)); user.name = 'Bob'; console.log('user: ' + JSON.stringify(user)); user.revert(); console.log('user: ' + JSON.stringify(user)); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'William' }); console.log('user: ' + JSON.stringify(user)); user.name = 'Bob'; console.log('user: ' + JSON.stringify(user)); user.revert(); console.log('user: ' + JSON.stringify(user)); save(opts) Delegates to Mapper#create or Mapper#update. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Mapper#create and Mapper#update. Properties Name Type Argument Description changesOnly Boolean &lt;optional&gt; Equality function. Default uses ===. equalsFn Function &lt;optional&gt; Passed to Record#changes when opts.changesOnly is true. ignore Array &lt;optional&gt; Passed to Record#changes when opts.changesOnly is true. Return value: Type Description Promise The result of calling Mapper#create or Mapper#update. Details Since Source 3.0.0 Record.js, line 626 Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('session'); const session = store.createRecord('session', { topic: 'Node.js' }); // Create a new record in the database session.save().then(() =&gt; { console.log(session.id); // 1234 session.skill_level = 'beginner'; // Update the record in the database return session.save(); }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true }); store.defineMapper('session'); const session = store.createRecord('session', { topic: 'Node.js' }); // Create a new record in the database session.save().then(() =&gt; { console.log(session.id); // 1234 session.skill_level = 'beginner'; // Update the record in the database return session.save(); }); set(key, value, opts) Set the value for a given key, or the values for the given keys if \"key\" is an object. Triggers change events on those properties that have track: true in Mapper#schema. Method parameters: Name Type Argument Description key String | Object Key to set or hash of key-value pairs to set. value * &lt;optional&gt; Value to set for the given key. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Fires: Record#event:change Details Since Source 3.0.0 Record.js, line 687 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user: ' + JSON.stringify(user)); user.set('name', 'Bob'); console.log('user: ' + JSON.stringify(user)); user.set({ age: 30, role: 'admin' }); console.log('user: ' + JSON.stringify(user)); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user'); console.log('user: ' + JSON.stringify(user)); user.set('name', 'Bob'); console.log('user: ' + JSON.stringify(user)); user.set({ age: 30, role: 'admin' }); console.log('user: ' + JSON.stringify(user)); toJSON(opts) Return a plain object representation of this record. If the class from which this record was created has a Mapper, then Mapper#toJSON will be called with this record instead. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Array of relation names or relation fields to include in the representation. Only available as an option if the class from which this record was created has a Mapper and this record resides in an instance of DataStore. Return value: Type Description Object Plain object representation of this record. Details Since Source 3.0.0 Record.js, line 730 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 'John', $$hashKey: '1234' }); console.log('user: ' + JSON.stringify(user.toJSON())); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 'John', $$hashKey: '1234' }); console.log('user: ' + JSON.stringify(user.toJSON())); unset(key, opts) Unset the value for a given key. Triggers change events on those properties that have track: true in Mapper#schema. Method parameters: Name Type Argument Description key String Key to unset. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description silent Boolean &lt;optional&gt; false Whether to trigger change events. Details Since Source 3.0.0 Record.js, line 776 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'John' }); console.log('user: ' + JSON.stringify(user)); user.unset('name'); console.log('user: ' + JSON.stringify(user)); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user'); const user = store.createRecord('user', { name: 'John' }); console.log('user: ' + JSON.stringify(user)); user.unset('name'); console.log('user: ' + JSON.stringify(user)); validate(opts) Validate this record based on its current properties. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Passed to Mapper#validate. Return value: Type Description * Array of errors or undefined if no errors. Details Since Source 3.0.0 Record.js, line 805 Example Try it out const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 1234 }, { noValidate: true // this allows us to put the record into an invalid state }); console.log('user validation: ' + JSON.stringify(user.validate())); user.name = 'John'; console.log('user validation: ' + user.validate()); const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); store.defineMapper('user', { schema: { properties: { name: { type: 'string' } } } }); const user = store.createRecord('user', { name: 1234 }, { noValidate: true // this allows us to put the record into an invalid state }); console.log('user validation: ' + JSON.stringify(user.validate())); user.name = 'John'; console.log('user validation: ' + user.validate()); Type Definitions changeListener(The, The) Callback signature for the Record#event:change event. Method parameters: Name Type Description The Record Record that changed. The Object changes. Details Type Since Source See Function 3.0.0 Record.js, line 867 Record#event:change Example function onChange (record, changes) { // do something } record.on('change', onChange); function onChange (record, changes) { // do something } record.on('change', onChange); Events change Fired when a record changes. Only works for records that have tracked fields. See Record~changeListener on how to listen for this event. Details Source See Record.js, line 859 Record~changeListener × Search results Close api.js-data.io • js-data.io "},"Schema.html":{"id":"Schema.html","title":"Class: Schema","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Schema Schema new Schema(definition) js-data's Schema class. Method parameters: Name Type Description definition Object Schema definition according to json-schema.org Details Source Schema.js, line 927 Example Try it out const JSData = require('js-data'); const { Schema } = JSData; console.log('Using JSData v' + JSData.version.full); const PostSchema = new Schema({ type: 'object', properties: { title: { type: 'string' } } }); PostSchema.validate({ title: 1234 }); const JSData = require('js-data'); const { Schema } = JSData; console.log('Using JSData v' + JSData.version.full); const PostSchema = new Schema({ type: 'object', properties: { title: { type: 'string' } } }); PostSchema.validate({ title: 1234 }); Extends This class extends the Component class. Members &lt;static&gt; ANY_OPS Validation keywords validated for any type: enum type allOf anyOf oneOf not Details Type Source Array.&lt;String&gt; Schema.js, line 652 &lt;static&gt; ARRAY_OPS Validation keywords validated for array types: items maxItems minItems uniqueItems Details Type Source Array.&lt;String&gt; Schema.js, line 667 &lt;static&gt; NUMERIC_OPS Validation keywords validated for numeric (number and integer) types: multipleOf maximum minimum Details Type Source Array.&lt;String&gt; Schema.js, line 680 &lt;static&gt; OBJECT_OPS Validation keywords validated for object types: maxProperties minProperties required properties dependencies Details Type Source Array.&lt;String&gt; Schema.js, line 692 &lt;static&gt; STRING_OPS Validation keywords validated for string types: maxLength minLength pattern Details Type Source Array.&lt;String&gt; Schema.js, line 706 &lt;static&gt; typeGroupValidators A map of validation functions grouped by type. Details Type Source Object Schema.js, line 807 &lt;static&gt; types A function map for each of the seven primitive JSON types defined by the core specification. Each function will check a given value and return true or false if the value is an instance of that type. types.integer(1) // returns true types.string({}) // returns false http://json-schema.org/latest/json-schema-core.html#anchor8 Details Type Source Object Schema.js, line 6 &lt;static&gt; validationKeywords A map of all object member validation functions for each keyword defined in the JSON Schema. Details Type Source Object Schema.js, line 96 debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Schema: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Schema class. Details Since Source 3.0.0 Schema.js, line 1252 Example Try it out const JSData = require('js-data'); const { Schema } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSchemaClass extends Schema { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSchema = new CustomSchemaClass(); console.log(customSchema.foo()); console.log(CustomSchemaClass.beep()); // Extend the class using alternate method. const OtherSchemaClass = Schema.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherSchema = new OtherSchemaClass(); console.log(otherSchema.foo()); console.log(OtherSchemaClass.beep()); // Extend the class, providing a custom constructor. function AnotherSchemaClass () { Schema.call(this); this.created_at = new Date().getTime(); } Schema.extend({ constructor: AnotherSchemaClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherSchema = new AnotherSchemaClass(); console.log(anotherSchema.created_at); console.log(anotherSchema.foo()); console.log(AnotherSchemaClass.beep()); const JSData = require('js-data'); const { Schema } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSchemaClass extends Schema { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSchema = new CustomSchemaClass(); console.log(customSchema.foo()); console.log(CustomSchemaClass.beep()); // Extend the class using alternate method. const OtherSchemaClass = Schema.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherSchema = new OtherSchemaClass(); console.log(otherSchema.foo()); console.log(OtherSchemaClass.beep()); // Extend the class, providing a custom constructor. function AnotherSchemaClass () { Schema.call(this); this.created_at = new Date().getTime(); } Schema.extend({ constructor: AnotherSchemaClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const anotherSchema = new AnotherSchemaClass(); console.log(anotherSchema.created_at); console.log(anotherSchema.foo()); console.log(AnotherSchemaClass.beep()); &lt;static&gt; validate(value, schema, opts) Validates the provided value against a given Schema according to the http://json-schema.org/ v4 specification. Method parameters: Name Type Argument Description value * Value to be validated. schema Object Valid Schema according to the http://json-schema.org/ v4 specification. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array | undefined Array of errors or undefined if valid. Details Source Schema.js, line 726 apply(target) This adds ES5 getters/setters to the target based on the \"properties\" in this Schema, which makes possible change tracking and validation on property assignment. Method parameters: Name Type Description target Object The prototype to which to apply this schema. Details Source Schema.js, line 979 applyDefaults(target) Apply default values to the target object for missing values. Method parameters: Name Type Description target Object The target to which to apply values for missing values. Details Source Schema.js, line 1004 dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log makeDescriptor(prop, schema, opts) Assemble a property descriptor for tracking and validating changes to a property according to the given schema. This method is called when Mapper#applySchema is set to true. Method parameters: Name Type Argument Description prop String The property name. schema Schema | Object The schema for the property. opts Object &lt;optional&gt; Optional configuration. Properties Name Type Argument Description getter Function &lt;optional&gt; Custom getter function. setter Function &lt;optional&gt; Custom setter function. track Function &lt;optional&gt; Whether to track changes. Return value: Type Description Object A property descriptor for the given schema. Details Source Schema.js, line 1039 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 Component.js, line 145 Inherited From: Component#on Examples // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection collection.on('add', (records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record post.on('change', (record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; pick(value) Create a copy of the given value that contains only the properties defined in this schema. Method parameters: Name Type Description value * The value to copy. Return value: Type Description * The copy. Details Source Schema.js, line 1183 validate(value, opts) Validate the provided value against this schema. Method parameters: Name Type Argument Description value * Value to validate. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Array | undefined Array of errors or undefined if valid. Details Source Schema.js, line 1228 × Search results Close api.js-data.io • js-data.io "},"Settable.html":{"id":"Settable.html","title":"Class: Settable","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: Settable Settable new Settable() A base class which gives instances private properties. Typically you won't instantiate this class directly, but you may find it useful as an abstract class for your own components. See Settable.extend for an example of using Settable as a base class. import {Settable} from 'js-data' Return value: Type Description Settable A new Settable instance. Details Since Source 3.0.0 Settable.js, line 3 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Settable: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Settable class. Details Since Source 3.0.0 Settable.js, line 61 Example Try it out const JSData = require('js-data'); const { Settable } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSettableClass extends Settable { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSettable = new CustomSettableClass(); console.log(customSettable.foo()); console.log(CustomSettableClass.beep()); // Extend the class using alternate method. const OtherSettableClass = Settable.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherSettable = new OtherSettableClass(); console.log(otherSettable.foo()); console.log(OtherSettableClass.beep()); // Extend the class, providing a custom constructor. function AnotherSettableClass () { Settable.call(this); this.created_at = new Date().getTime(); } Settable.extend({ constructor: AnotherSettableClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherSettable = new AnotherSettableClass(); console.log(anotherSettable.created_at); console.log(anotherSettable.foo()); console.log(AnotherSettableClass.beep()); const JSData = require('js-data'); const { Settable } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSettableClass extends Settable { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSettable = new CustomSettableClass(); console.log(customSettable.foo()); console.log(CustomSettableClass.beep()); // Extend the class using alternate method. const OtherSettableClass = Settable.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }); const otherSettable = new OtherSettableClass(); console.log(otherSettable.foo()); console.log(OtherSettableClass.beep()); // Extend the class, providing a custom constructor. function AnotherSettableClass () { Settable.call(this); this.created_at = new Date().getTime(); } Settable.extend({ constructor: AnotherSettableClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherSettable = new AnotherSettableClass(); console.log(anotherSettable.created_at); console.log(anotherSettable.foo()); console.log(AnotherSettableClass.beep()); _get(key) Get a private property of this instance. Don't use the method unless you know what you're doing. Method parameters: Name Type Description key String The property to retrieve. Return value: Type Description * The value of the property. Details Since Source 3.0.0 Settable.js, line 23 × Search results Close api.js-data.io • js-data.io "},"SimpleStore.html":{"id":"SimpleStore.html","title":"Class: SimpleStore","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Class: SimpleStore SimpleStore new SimpleStore(opts) The SimpleStore class is an extension of Container. Not only does SimpleStore manage mappers, but also collections. SimpleStore implements the asynchronous Mapper methods, such as Mapper#find and Mapper#create. If you use the asynchronous SimpleStore methods instead of calling them directly on the mappers, then the results of the method calls will be inserted into the store's collections. You can think of a SimpleStore as an Identity Map for the ORM (the Mappers). import { SimpleStore } from 'js-data'; Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. See Container. Properties Name Type Argument Default Description collectionClass Boolean &lt;optional&gt; Collection See SimpleStore#collectionClass. debug Boolean &lt;optional&gt; false See Component#debug. usePendingFind Boolean | Function &lt;optional&gt; true See SimpleStore#usePendingFind. usePendingFindAll Boolean | Function &lt;optional&gt; true See SimpleStore#usePendingFindAll. Return value: Type Description SimpleStore Unspecified Details Since Source Tutorials See 3.0.0 SimpleStore.js, line 296 Components of JSData: SimpleStore Working with the SimpleStore Notes on using JSData in the Browser Container Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); // SimpleStore#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); // SimpleStore#as returns the store scoped to a particular Mapper. const UserStore = store.as('user'); // Call \"find\" on \"UserMapper\" (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a \"user\" record via the http adapter, but that's it // Call \"find\" on \"store\" targeting \"user\" (Stateful SimpleStore) return store.find('user', 1); // same as \"UserStore.find(1)\" }).then((user) =&gt; { // not only was a \"user\" record retrieved, but it was added to the // store's \"user\" collection const cachedUser = store.getCollection('user').get(1); console.log(user === cachedUser); // true }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); // SimpleStore#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); // SimpleStore#as returns the store scoped to a particular Mapper. const UserStore = store.as('user'); // Call \"find\" on \"UserMapper\" (Stateless ORM) UserMapper.find(1).then((user) =&gt; { // retrieved a \"user\" record via the http adapter, but that's it // Call \"find\" on \"store\" targeting \"user\" (Stateful SimpleStore) return store.find('user', 1); // same as \"UserStore.find(1)\" }).then((user) =&gt; { // not only was a \"user\" record retrieved, but it was added to the // store's \"user\" collection const cachedUser = store.getCollection('user').get(1); console.log(user === cachedUser); // true }); Extends This class extends the Container class. Members _adapters The adapters registered with this Container, which are also shared by all Mappers in this Container. Details Type Since Source See Object 3.0.0 Container.js, line 941 Container#registerAdapter Inherited From: Container#_adapters _mappers The the mappers in this container Details Type Since Source See Object 3.0.0 Container.js, line 954 Mapper Inherited From: Container#_mappers debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false Component.js, line 28 Inherited From: Component#debug Example Try it out const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged const JSData = require('js-data'); const { Component } = JSData; console.log('Using JSData v' + JSData.version.full); const component = new Component(); component.log('debug', 'some message'); // nothing gets logged // Display debug logs: component.debug = true; component.log('debug', 'other message'); // this DOES get logged mapperClass Constructor function to use in Container#defineMapper to create new Mapper instances. Container#mapperClass should extend Mapper. By default Mapper is used to instantiate Mappers. Details Type Since Source See Constructor 3.0.0 Container.js, line 966 Mapper Inherited From: Container#mapperClass Example Try it out // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); // import { Container, Mapper } from 'js-data'; const JSData = require('js-data'); const { Container, Mapper } = JSData; console.log('Using JSData v' + JSData.version.full); class MyMapperClass extends Mapper { foo () { return 'bar' } } const store = new Container({ mapperClass: MyMapperClass }); store.defineMapper('user'); console.log(store.getMapper('user').foo()); mapperDefaults Defaults options to pass to Container#mapperClass when creating a new Mapper. Details Type Since Default value Source Object 3.0.0 {} Container.js, line 1000 Inherited From: Container#mapperDefaults Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { idAttribute: '_id' } }); store.defineMapper('user'); console.log(store.getMapper('user').idAttribute); usePendingFind Whether to use the pending query if a find request for the specified record is currently underway. Can be set to true, false, or to a function that returns true or false. Details Type Since Default value Source Boolean | Function 3.0.0 true SimpleStore.js, line 271 usePendingFindAll Whether to use the pending query if a findAll request for the given query is currently underway. Can be set to true, false, or to a function that returns true or false. Details Type Since Default value Source Boolean | Function 3.0.0 true SimpleStore.js, line 283 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this SimpleStore: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this SimpleStore class. Details Since Source 3.0.0 SimpleStore.js, line 2008 Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSimpleStoreClass extends SimpleStore { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSimpleStore = new CustomSimpleStoreClass(); console.log(customSimpleStore.foo()); console.log(CustomSimpleStoreClass.beep()); // Extend the class using alternate method. const OtherSimpleStoreClass = SimpleStore.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const otherSimpleStore = new OtherSimpleStoreClass(); console.log(otherSimpleStore.foo()); console.log(OtherSimpleStoreClass.beep()); // Extend the class, providing a custom constructor. function AnotherSimpleStoreClass () { SimpleStore.call(this) this.created_at = new Date().getTime() } SimpleStore.extend({ constructor: AnotherSimpleStoreClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherSimpleStore = new AnotherSimpleStoreClass(); console.log(anotherSimpleStore.created_at); console.log(anotherSimpleStore.foo()); console.log(AnotherSimpleStoreClass.beep()); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); // Extend the class using ES2015 class syntax. class CustomSimpleStoreClass extends SimpleStore { foo () { return 'bar'; } static beep () { return 'boop'; } } const customSimpleStore = new CustomSimpleStoreClass(); console.log(customSimpleStore.foo()); console.log(CustomSimpleStoreClass.beep()); // Extend the class using alternate method. const OtherSimpleStoreClass = SimpleStore.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const otherSimpleStore = new OtherSimpleStoreClass(); console.log(otherSimpleStore.foo()); console.log(OtherSimpleStoreClass.beep()); // Extend the class, providing a custom constructor. function AnotherSimpleStoreClass () { SimpleStore.call(this) this.created_at = new Date().getTime() } SimpleStore.extend({ constructor: AnotherSimpleStoreClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherSimpleStore = new AnotherSimpleStoreClass(); console.log(anotherSimpleStore.created_at); console.log(anotherSimpleStore.foo()); console.log(AnotherSimpleStoreClass.beep()); add(name, data, opts) Wrapper for Collection#add. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. data Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; See Collection#add. opts Object &lt;optional&gt; Configuration options. See Collection#add. Fires: SimpleStore#event:add Return value: Type Description Object | Array.&lt;Object&gt; | Record | Array.&lt;Record&gt; See Collection#add. Details Since Source See 3.0.0 SimpleStore.js, line 13 Collection#add Collection#add Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); // Add one book to the in-memory store: store.add('book', { id: 1, title: 'Respect your Data' }); // Add multiple books to the in-memory store: store.add('book', [ { id: 2, title: 'Easy data recipes' }, { id: 3, title: 'Active Record 101' } ]); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); // Add one book to the in-memory store: store.add('book', { id: 1, title: 'Respect your Data' }); // Add multiple books to the in-memory store: store.add('book', [ { id: 2, title: 'Easy data recipes' }, { id: 3, title: 'Active Record 101' } ]); addToCache(name, data, opts) This method takes the data received from SimpleStore#find, SimpleStore#findAll, SimpleStore#update, etc., and adds the data to the store. You don't need to call this method directly. If you're using the http adapter and your response data is in an unexpected format, you may need to override this method so the right data gets added to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. data * Data from which data should be selected for add. opts Object &lt;optional&gt; Configuration options. Details Source SimpleStore.js, line 441 Examples const store = new SimpleStore({ addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return SimpleStore.prototype.addToCache.call(this, mapperName, data, opts); } }); const store = new SimpleStore({ addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return SimpleStore.prototype.addToCache.call(this, mapperName, data, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return super.addToCache(mapperName, data, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { addToCache (mapperName, data, opts) { // Let's say for a particular Resource, response data is in a weird format if (name === 'comment') { // Re-assign the variable to add the correct records into the stores data = data.items; } // Now perform default behavior return super.addToCache(mapperName, data, opts); } } const store = new MyStore(); as(name) Return the store scoped to a particular mapper/collection pair. Method parameters: Name Type Description name String Name of the Mapper. Return value: Type Description Object The store, scoped to a particular Mapper/Collection pair. Details Since Source Overrides 3.0.0 SimpleStore.js, line 487 Container#as Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); const UserMapper = store.defineMapper('user'); const UserStore = store.as('user'); const user1 = store.createRecord('user', { name: 'John' }); const user2 = UserStore.createRecord({ name: 'John' }); const user3 = UserMapper.createRecord({ name: 'John' }); console.log(user1 === user2); console.log(user2 === user3); console.log(user1 === user3); between(name, leftKeys, rightKeys, opts) Wrapper for Collection#between. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. leftKeys Array See Collection#between. rightKeys Array See Collection#between. opts Object &lt;optional&gt; Configuration options. See Collection#between. Return value: Type Description Array.&lt;Object&gt; | Array.&lt;Record&gt; See Collection#between. Details Since Source See 3.0.0 SimpleStore.js, line 44 Collection#between Collection#between Examples // Get all users ages 18 to 30 const users = store.between('user', 18, 30, { index: 'age' }); // Get all users ages 18 to 30 const users = store.between('user', 18, 30, { index: 'age' }); // Same as above const users = store.between('user', [18], [30], { index: 'age' }); // Same as above const users = store.between('user', [18], [30], { index: 'age' }); cachedFind(name, id, opts) Retrieve a cached find result, if any. This method is called during SimpleStore#find to determine if Mapper#find needs to be called. If this method returns undefined then Mapper#find will be called. Otherwise SimpleStore#find will immediately resolve with the return value of this method. When using SimpleStore in the browser, you can override this method to implement your own cache-busting strategy. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find. id String | Number The id argument passed to SimpleStore#find. opts Object The opts argument passed to SimpleStore#find. Details Since Source 3.0.0 SimpleStore.js, line 541 Examples const store = new SimpleStore({ cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFind.call(this, mapperName, id, opts); } }); const store = new SimpleStore({ cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFind.call(this, mapperName, id, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return super.cachedFind(mapperName, id, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFind (mapperName, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#find call return; } // Otherwise perform default behavior return super.cachedFind(mapperName, id, opts); } } const store = new MyStore(); cachedFindAll(name, hash, opts) Retrieve a cached findAll result, if any. This method is called during SimpleStore#findAll to determine if Mapper#findAll needs to be called. If this method returns undefined then Mapper#findAll will be called. Otherwise SimpleStore#findAll will immediately resolve with the return value of this method. When using SimpleStore in the browser, you can override this method to implement your own cache-busting strategy. Method parameters: Name Type Description name String The name argument passed to SimpleStore#findAll. hash String The result of calling SimpleStore#hashQuery on the query argument passed to SimpleStore#findAll. opts Object The opts argument passed to SimpleStore#findAll. Details Since Source 3.0.0 SimpleStore.js, line 587 Examples const store = new SimpleStore({ cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFindAll.call(this, mapperName, hash, opts); } }); const store = new SimpleStore({ cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return SimpleStore.prototype.cachedFindAll.call(this, mapperName, hash, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return super.cachedFindAll(mapperName, hash, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return undefined to trigger a Mapper#findAll call return undefined; } // Otherwise perform default behavior return super.cachedFindAll(mapperName, hash, opts); } } const store = new MyStore(); cacheFind(name, data, id, opts) Mark a Mapper#find result as cached by adding an entry to SimpleStore#_completedQueries. By default, once a find entry is added it means subsequent calls to the same Resource with the same id argument will immediately resolve with the result of calling SimpleStore#get instead of delegating to Mapper#find. As part of implementing your own caching strategy, you may choose to override this method. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find. data * The result to cache. id String | Number The id argument passed to SimpleStore#find. opts Object The opts argument passed to SimpleStore#find. Details Since Source 3.0.0 SimpleStore.js, line 634 Examples const store = new SimpleStore({ cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return SimpleStore.prototype.cacheFind.call(this, mapperName, data, id, opts); } }); const store = new SimpleStore({ cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return SimpleStore.prototype.cacheFind.call(this, mapperName, data, id, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return super.cacheFind(mapperName, data, id, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cacheFind (mapperName, data, id, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior return super.cacheFind(mapperName, data, id, opts); } } const store = new MyStore(); cacheFindAll(name, data, hash, opts) Mark a Mapper#findAll result as cached by adding an entry to SimpleStore#_completedQueries. By default, once a findAll entry is added it means subsequent calls to the same Resource with the same query argument will immediately resolve with the result of calling SimpleStore#filter instead of delegating to Mapper#findAll. As part of implementing your own caching strategy, you may choose to override this method. Method parameters: Name Type Description name String The name argument passed to SimpleStore#findAll. data * The result to cache. hash String The result of calling SimpleStore#hashQuery on the query argument passed to SimpleStore#findAll. opts Object The opts argument passed to SimpleStore#findAll. Details Since Source 3.0.0 SimpleStore.js, line 683 Examples const store = new SimpleStore({ cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return SimpleStore.prototype.cachedFindAll.call(this, mapperName, data, hash, opts); } }); const store = new SimpleStore({ cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return SimpleStore.prototype.cachedFindAll.call(this, mapperName, data, hash, opts); } }); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return super.cachedFindAll(mapperName, data, hash, opts); } } const store = new MyStore(); // Extend using ES2015 class syntax. class MyStore extends SimpleStore { cachedFindAll (mapperName, data, hash, opts) { // Let's say for a particular Resource, we always want to pull fresh from the server if (mapperName === 'schedule') { // Return without saving an entry to SimpleStore#_completedQueries return; } // Otherwise perform default behavior. return super.cachedFindAll(mapperName, data, hash, opts); } } const store = new MyStore(); clear() Remove all records from the in-memory store and reset SimpleStore#_completedQueries. Return value: Type Description Object Object containing all records that were in the store. Details Since Source See 3.0.0 SimpleStore.js, line 733 SimpleStore#remove SimpleStore#removeAll count(name, query, opts) Wrapper for Mapper#count. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; See Mapper#count. opts Object &lt;optional&gt; See Mapper#count. Return value: Type Description Promise See Mapper#count. Details Since Source See 3.0.0 Container.js, line 8 Mapper#count Inherited From: Container#count Example // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); // Get the number of published blog posts import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('post'); store.count('post', { status: 'published' }).then((numPublished) =&gt; { console.log(numPublished); // e.g. 45 }); create(name, record, opts) Wrapper for Mapper#create. Adds the created record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. record Object Passed to Mapper#create. opts Object &lt;optional&gt; Passed to Mapper#create. See Mapper#create for more configuration options. Fires: SimpleStore#event:beforeCreate SimpleStore#event:afterCreate SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the create. Details Since Source Overrides 3.0.0 SimpleStore.js, line 803 Container#create Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book {\"author_id\":1234,...} store.create('book', { author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }).then((book) =&gt; { console.log(book.id); // 120392 console.log(book.title); // \"Respect your Data\" }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book {\"author_id\":1234,...} store.create('book', { author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }).then((book) =&gt; { console.log(book.id); // 120392 console.log(book.title); // \"Respect your Data\" }); createIndex(name, name, fieldList) Wrapper for Collection#createIndex. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. name String See Collection#createIndex. fieldList Array.&lt;String&gt; &lt;optional&gt; See Collection#createIndex. Details Since Source See 3.0.0 SimpleStore.js, line 67 Collection#createIndex Collection#createIndex Examples // Index users by age store.createIndex('user', 'age'); // Index users by age store.createIndex('user', 'age'); // Index users by status and role store.createIndex('user', 'statusAndRole', ['status', 'role']); // Index users by status and role store.createIndex('user', 'statusAndRole', ['status', 'role']); createMany(name, records, opts) Wrapper for Mapper#createMany. Adds the created records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array Passed to Mapper#createMany. opts Object &lt;optional&gt; Passed to Mapper#createMany. See Mapper#createMany for more configuration options. Fires: SimpleStore#event:beforeCreateMany SimpleStore#event:afterCreateMany SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the create. Details Since Source Overrides 3.0.0 SimpleStore.js, line 895 Container#createMany Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book [{\"author_id\":1234,...},{...}] store.createMany('book', [{ author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }, { author_id: 1234, edition: 'Second Edition', title: 'Respect your Data' }]).then((books) =&gt; { console.log(books[0].id); // 142394 console.log(books[0].title); // \"Respect your Data\" }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // POST /book [{\"author_id\":1234,...},{...}] store.createMany('book', [{ author_id: 1234, edition: 'First Edition', title: 'Respect your Data' }, { author_id: 1234, edition: 'Second Edition', title: 'Respect your Data' }]).then((books) =&gt; { console.log(books[0].id); // 142394 console.log(books[0].title); // \"Respect your Data\" }); createRecord(name, props, opts) Wrapper for Mapper#createRecord. Note: This method does not interact with any adapter, and does not save any data. It only creates new objects in memory. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object | Array.&lt;Object&gt; See Mapper#createRecord. opts Object &lt;optional&gt; See Mapper#createRecord. Return value: Type Description Promise See Mapper#createRecord. Details Since Source See 3.0.0 Container.js, line 199 Mapper#createRecord Inherited From: Container#createRecord Example // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); // Create empty unsaved record instance import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = PostMapper.createRecord(); dbg(args) Log the provided values at the \"debug\" level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 122 Inherited From: Component#dbg defineMapper(name, opts) Create a new mapper and register it in this container. Method parameters: Name Type Argument Description name String Name under which to register the new Mapper. Mapper#name will be set to this value. opts Object &lt;optional&gt; Configuration options. Passed to Container#mapperClass when creating the new Mapper. Return value: Type Description Mapper The newly created instance of Mapper. Details Since Source See 3.0.0 Container.js, line 1117 Container#as Inherited From: Container#defineMapper Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container({ mapperDefaults: { foo: 'bar' } }); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(UserMapper.foo); destroy(name, id, opts) Wrapper for Mapper#destroy. Removes any destroyed record from the in-memory store. Clears out any SimpleStore#_completedQueries entries associated with the provided id. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#destroy. opts Object &lt;optional&gt; Passed to Mapper#destroy. See Mapper#destroy for more configuration options. Fires: SimpleStore#event:beforeDestroy SimpleStore#event:afterDestroy SimpleStore#event:remove Return value: Type Description Promise Resolves when the destroy operation completes. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1039 Container#destroy Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is no longer in the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is no longer in the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); destroyAll(name, query, opts) Wrapper for Mapper#destroyAll. Removes any destroyed records from the in-memory store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper#destroyAll. opts Object &lt;optional&gt; Passed to Mapper#destroyAll. See Mapper#destroyAll for more configuration options. Fires: SimpleStore#event:beforeDestroyAll SimpleStore#event:afterDestroyAll SimpleStore#event:remove Return value: Type Description Promise Resolves when the delete completes. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1146 Container#destroyAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is gone from the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); store.add('book', { id: 1234, title: 'Data Management is Hard' }); // Since this example uses the http adapter, we'll get something like: // // DELETE /book/1234 store.destroy('book', 1234).then(() =&gt; { // The book record is gone from the in-memory store console.log(store.get('book', 1234)); // undefined return store.find('book', 1234); }).then((book) { // The book was deleted from the database too console.log(book); // undefined }); emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 Component.js, line 200 Inherited From: Component#emit Example Try it out // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); // import { Collection, DataStore } from 'js-data'; const JSData = require('js-data'); const { Collection, DataStore } = JSData; const collection = new Collection(); collection.on('foo', function (msg) { console.log(msg); }); collection.emit('foo', 'bar'); const store = new DataStore(); store.on('beep', function (msg) { console.log(msg); }); store.emit('beep', 'boop'); filter(name, queryOrFn, thisArg) Wrapper for Collection#filter. Method parameters: Name Type Argument Default Description name String | Number Name of the Mapper to target. queryOrFn Object | Function &lt;optional&gt; {} See Collection#filter. thisArg Object &lt;optional&gt; See Collection#filter. Return value: Type Description Array See Collection#filter. Details Since Source See 3.0.0 SimpleStore.js, line 88 Collection#filter Collection#filter Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = store.filter('post', { where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = store.filter('post', function (post) { return post.id % 2 === 0 }); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); // Get the draft posts created less than three months ago let posts = store.filter('post', { where: { status: { '==': 'draft' }, created_at_timestamp: { '&gt;=': (new Date().getTime() - (1000 \\* 60 \\* 60 \\* 24 \\* 30 \\* 3)) // 3 months ago } } }); console.log(posts); // Use a custom filter function posts = store.filter('post', function (post) { return post.id % 2 === 0 }); find(name, id, opts) Wrapper for Mapper#find. Adds any found record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#find. opts Object &lt;optional&gt; Passed to Mapper#find. Properties Name Type Argument Description force Boolean &lt;optional&gt; Bypass cacheFind usePendingFind Boolean | Function &lt;optional&gt; See SimpleStore#usePendingFind Fires: SimpleStore#event:beforeFind SimpleStore#event:afterFind SimpleStore#event:add Return value: Type Description Promise Resolves with the result, if any. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1262 Container#find Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // GET /book/1234 store.find('book', 1234).then((book) =&gt; { // The book record is now in the in-memory store console.log(store.get('book', 1234) === book); // true }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('book'); // Since this example uses the http adapter, we'll get something like: // // GET /book/1234 store.find('book', 1234).then((book) =&gt; { // The book record is now in the in-memory store console.log(store.get('book', 1234) === book); // true }); findAll(name, query, opts) Wrapper for Mapper#findAll. Adds any found records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. query Object &lt;optional&gt; Passed to Mapper.findAll. opts Object &lt;optional&gt; Passed to Mapper.findAll. Properties Name Type Argument Description force Boolean &lt;optional&gt; Bypass cacheFindAll usePendingFindAll Boolean | Function &lt;optional&gt; See SimpleStore#usePendingFindAll Fires: SimpleStore#event:beforeFindAll SimpleStore#event:afterFindAll SimpleStore#event:add Return value: Type Description Promise Resolves with the result, if any. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1374 Container#findAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('movie'); // Since this example uses the http adapter, we'll get something like: // // GET /movie?rating=PG store.find('movie', { rating: 'PG' }).then((movies) =&gt; { // The movie records are now in the in-memory store console.log(store.filter('movie')); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('movie'); // Since this example uses the http adapter, we'll get something like: // // GET /movie?rating=PG store.find('movie', { rating: 'PG' }).then((movies) =&gt; { // The movie records are now in the in-memory store console.log(store.filter('movie')); }); get(name, id) Wrapper for Collection#get. Method parameters: Name Type Description name String | Number Name of the Mapper to target. id String | Number See Collection#get. Return value: Type Description Object | Record See Collection#get. Details Since Source See 3.0.0 SimpleStore.js, line 129 Collection#get Collection#get Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); console.log(store.get('post', 1)); // {...} console.log(store.get('post', 2)); // undefined const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('post'); store.add('post', [ { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() } ]); console.log(store.get('post', 1)); // {...} console.log(store.get('post', 2)); // undefined getAdapter(name) Return the registered adapter with the given name or the default adapter if no name is provided. Method parameters: Name Type Argument Description name String &lt;optional&gt; The name of the adapter to retrieve. Return value: Type Description Adapter The adapter. Details Since Source 3.0.0 Container.js, line 1189 Inherited From: Container#getAdapter getAdapterName(opts) Return the name of a registered adapter based on the given name or options, or the name of the default adapter if no name provided. Method parameters: Name Type Argument Description opts Object | String &lt;optional&gt; The name of an adapter or options, if any. Return value: Type Description String The name of the adapter. Details Since Source 3.0.0 Container.js, line 1206 Inherited From: Container#getAdapterName getAdapters() Return the registered adapters of this container. Return value: Type Description Adapter Unspecified Details Since Source 3.0.0 Container.js, line 1223 Inherited From: Container#getAdapters getAll(name, keyList, opts) Wrapper for Collection#getAll. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. keyList Array &lt;optional&gt; &lt;repeatable&gt; See Collection#getAll. opts Object &lt;optional&gt; See Collection#getAll. Return value: Type Description Array See Collection#getAll. Details Since Source See 3.0.0 SimpleStore.js, line 156 Collection#getAll Collection#getAll Examples // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = store.getAll('post', 'draft', 'inReview', { index: 'status' }); // Get the posts where \"status\" is \"draft\" or \"inReview\" const posts = store.getAll('post', 'draft', 'inReview', { index: 'status' }); // Same as above const posts = store.getAll('post', ['draft'], ['inReview'], { index: 'status' }); // Same as above const posts = store.getAll('post', ['draft'], ['inReview'], { index: 'status' }); getCollection(name) Return the Collection with the given name, if for some reason you need a direct reference to the collection. Method parameters: Name Type Description name String Name of the Collection to retrieve. Throws: Thrown if the specified Collection does not exist. Type Error Return value: Type Description Collection Unspecified Details Since Source 3.0.0 SimpleStore.js, line 1437 getMapper(name) Return the mapper registered under the specified name. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1234 Inherited From: Container#getMapper Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); store.getMapper('profile'); // throws Error, there is no mapper with name \"profile\" getMapperByName(name) Return the mapper registered under the specified name. Doesn't throw error if mapper doesn't exist. Method parameters: Name Type Description name String Mapper#name. Return value: Type Description Mapper Unspecified Details Since Source 3.0.0 Container.js, line 1264 Inherited From: Container#getMapperByName Example Try it out // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error // import { Container } from 'js-data'; const JSData = require('js-data'); const { Container } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new Container(); // Container#defineMapper returns a direct reference to the newly created // Mapper. const UserMapper = store.defineMapper('user'); console.log(UserMapper === store.getMapper('user')); console.log(UserMapper === store.as('user').getMapper()); console.log(store.getMapper('profile')); // Does NOT throw an error getSchema(name) Wrapper for Mapper#getSchema. Method parameters: Name Type Description name String Name of the Mapper to target. Return value: Type Description Schema See Mapper#getSchema. Details Since Source See 3.0.0 Container.js, line 533 Mapper#getSchema Inherited From: Container#getSchema hashQuery(name, query) Hashing function used to cache SimpleStore#find and SimpleStore#findAll requests. This method simply JSONifies the query argument passed to SimpleStore#find or SimpleStore#findAll. Override this method for custom hashing behavior. Method parameters: Name Type Description name String The name argument passed to SimpleStore#find or SimpleStore#findAll. query Object The query argument passed to SimpleStore#find or SimpleStore#findAll. Return value: Type Description String The JSONified query. Details Since Source 3.0.0 SimpleStore.js, line 1456 is(name, record) Wrapper for Mapper#is. Method parameters: Name Type Description name String Name of the Mapper to target. record Object | Record See Mapper#is. Return value: Type Description Boolean See Mapper#is. Details Since Source See 3.0.0 Container.js, line 544 Mapper#is Inherited From: Container#is Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post'); const post = store.createRecord(); console.log(store.is('post', post)); // true // Equivalent to what's above console.log(post instanceof store.getMapper('post').recordClass); // true log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 Component.js, line 132 Inherited From: Component#log off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 Component.js, line 178 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler); // Remove a particular listener for a particular event collection.off('add', handler); // Remove all listeners for a particular event record.off('change'); // Remove all listeners for a particular event record.off('change'); // Remove all listeners to all events store.off(); // Remove all listeners to all events store.off(); on(event, listener, ctx) Register a new event listener on this SimpleStore. Proxy for Container#on. If an event was emitted by a Mapper or Collection in the SimpleStore, then the name of the Mapper or Collection will be prepended to the arugments passed to the provided event handler. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Source Overrides SimpleStore.js, line 391 Container#on Examples // Listen for all \"afterCreate\" events in a SimpleStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for all \"afterCreate\" events in a SimpleStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName); // \"post\" console.log(props.id); // undefined console.log(result.id); // 1234 }); store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id); // 1234 }); // Listen for the \"add\" event on a collection store.on('add', (mapperName, records) =&gt; { console.log(records); // [...] }); // Listen for the \"add\" event on a collection store.on('add', (mapperName, records) =&gt; { console.log(records); // [...] }); // Listen for \"change\" events on a record store.on('change', (mapperName, record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; // Listen for \"change\" events on a record store.on('change', (mapperName, record, changes) =&gt; { console.log(changes); // { changed: { title: 'Modeling your data' } } }); post.title = 'Modeling your data'; prune(opts) Wrapper for Collection#prune. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; See Collection#prune. Return value: Type Description Array See Collection#prune. Details Since Source See 3.0.0 SimpleStore.js, line 178 Collection#prune Collection#prune query(name) Wrapper for Collection#query. Method parameters: Name Type Description name String | Number Name of the Mapper to target. Return value: Type Description Query See Collection#query. Details Since Source See 3.0.0 SimpleStore.js, line 190 Collection#query Collection#query Example // Grab page 2 of users between ages 18 and 30 store.query('user') .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); // Grab page 2 of users between ages 18 and 30 store.query('user') .between(18, 30, { index: 'age' }) // between ages 18 and 30 .skip(10) // second page .limit(10) // page size .run(); registerAdapter(name, adapter, opts) Register an adapter on this container under the given name. Adapters registered on a container are shared by all mappers in the container. Method parameters: Name Type Argument Description name String The name of the adapter to register. adapter Adapter The adapter to register. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description default Boolean &lt;optional&gt; false Whether to make the adapter the default adapter for all Mappers in this container. Details Since Source Tutorials 3.0.0 Container.js, line 1291 Connecting to a data source Inherited From: Container#registerAdapter Example import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); import { Container } from 'js-data'; import { RethinkDBAdapter } from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); remove(name, id, opts) Wrapper for Collection#remove. Removes the specified Record from the store. Method parameters: Name Type Argument Description name String The name of the Collection to target. id String | Number The primary key of the Record to remove. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Fires: SimpleStore#event:remove Return value: Type Description Record The removed Record, if any. Details Since Source See 3.0.0 SimpleStore.js, line 1480 Collection#add Collection#add Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); console.log(store.getAll('book').length); store.add('book', { id: 1234 }); console.log(store.getAll('book').length); store.remove('book', 1234); console.log(store.getAll('book').length); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('book'); console.log(store.getAll('book').length); store.add('book', { id: 1234 }); console.log(store.getAll('book').length); store.remove('book', 1234); console.log(store.getAll('book').length); removeAll(name, query, opts) Wrapper for Collection#removeAll. Removes the selected Records from the store. Method parameters: Name Type Argument Default Description name String The name of the Collection to target. query Object &lt;optional&gt; {} Selection query. See query. Properties Name Type Argument Description where Object &lt;optional&gt; See query.where. offset Number &lt;optional&gt; See query.offset. limit Number &lt;optional&gt; See query.limit. orderBy String | Array.&lt;Array&gt; &lt;optional&gt; See query.orderBy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record to also remove from the store. Fires: SimpleStore#event:remove Return value: Type Description Record The removed Records, if any. Details Since Source See 3.0.0 SimpleStore.js, line 1517 Collection#add Collection#add Example Try it out const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('movie'); console.log(store.getAll('movie').length); store.add('movie', [{ id: 3, rating: 'R' }, { id: 4, rating: 'PG-13' }); console.log(store.getAll('movie').length); store.removeAll('movie', { rating: 'R' }); console.log(store.getAll('movie').length); const JSData = require('js-data'); const { SimpleStore } = JSData; console.log('Using JSData v' + JSData.version.full); const store = new SimpleStore(); store.defineMapper('movie'); console.log(store.getAll('movie').length); store.add('movie', [{ id: 3, rating: 'R' }, { id: 4, rating: 'PG-13' }); console.log(store.getAll('movie').length); store.removeAll('movie', { rating: 'R' }); console.log(store.getAll('movie').length); removeRelated(name, records, opts) Remove from the store Records that are related to the provided Record(s). Method parameters: Name Type Argument Description name String The name of the Collection to target. records Record | Array.&lt;Record&gt; Records whose relations are to be removed. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Description with Array.&lt;String&gt; &lt;optional&gt; Relations of the Record(s) to remove from the store. Fires: SimpleStore#event:remove Details Since Source 3.0.0 SimpleStore.js, line 1563 sum(name, field, query, opts) Wrapper for Mapper#sum. Method parameters: Name Type Argument Description name String Name of the Mapper to target. field String See Mapper#sum. query Object &lt;optional&gt; See Mapper#sum. opts Object &lt;optional&gt; See Mapper#sum. Return value: Type Description Promise See Mapper#sum. Details Since Source See 3.0.0 Container.js, line 566 Mapper#sum Inherited From: Container#sum Example import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); import { Container } from 'js-data'; import RethinkDBAdapter from 'js-data-rethinkdb'; const store = new Container(); store.registerAdapter('rethinkdb', new RethinkDBAdapter(), { default: true }); store.defineMapper('purchase_order'); store.sum('purchase_order', 'amount', { status: 'paid' }).then((amountPaid) =&gt; { console.log(amountPaid); // e.g. 451125.34 }); toJSON(name, opts) Wrapper for Collection#toJSON. Method parameters: Name Type Argument Description name String | Number Name of the Mapper to target. opts Object &lt;optional&gt; See Collection#toJSON. Return value: Type Description Array See Collection#toJSON. Details Since Source Overrides See 3.0.0 SimpleStore.js, line 210 Container#toJSON Collection#toJSON Collection#toJSON Example store.defineMapper('post', { schema: { properties: { id: { type: 'number' }, title: { type: 'string' } } } }); store.add('post', [ { id: 1, status: 'published', title: 'Respect your Data' }, { id: 2, status: 'draft', title: 'Connecting to a data source' } ]); console.log(store.toJSON('post')); const draftsJSON = store.query('post') .filter({ status: 'draft' }) .mapCall('toJSON') .run(); store.defineMapper('post', { schema: { properties: { id: { type: 'number' }, title: { type: 'string' } } } }); store.add('post', [ { id: 1, status: 'published', title: 'Respect your Data' }, { id: 2, status: 'draft', title: 'Connecting to a data source' } ]); console.log(store.toJSON('post')); const draftsJSON = store.query('post') .filter({ status: 'draft' }) .mapCall('toJSON') .run(); unsaved() Wrapper for Collection#unsaved. Return value: Type Description Array See Collection#unsaved. Details Since Source See 3.0.0 SimpleStore.js, line 242 Collection#unsaved Collection#unsaved update(name, id, record, opts) Wrapper for Mapper#update. Adds the updated Record to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. id String | Number Passed to Mapper#update. record Object Passed to Mapper#update. opts Object &lt;optional&gt; Passed to Mapper#update. See Mapper#update for more configuration options. Fires: SimpleStore#event:beforeUpdate SimpleStore#event:afterUpdate SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1675 Container#update Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post/1234 {\"status\":\"published\"} store.update('post', 1, { status: 'published' }).then((post) =&gt; { // The post record has also been updated in the in-memory store console.log(store.get('post', 1234)); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post/1234 {\"status\":\"published\"} store.update('post', 1, { status: 'published' }).then((post) =&gt; { // The post record has also been updated in the in-memory store console.log(store.get('post', 1234)); }); updateAll(name, props, query, opts) Wrapper for Mapper#updateAll. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. props Object Passed to Mapper#updateAll. query Object &lt;optional&gt; Passed to Mapper#updateAll. opts Object &lt;optional&gt; Passed to Mapper#updateAll. See Mapper#updateAll for more configuration options. Fires: SimpleStore#event:beforeUpdateAll SimpleStore#event:afterUpdateAll SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1767 Container#updateAll Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post?author_id=1234 {\"status\":\"published\"} store.updateAll('post', { author_id: 1234 }, { status: 'published' }).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.filter('posts', { author_id: 1234 })); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post?author_id=1234 {\"status\":\"published\"} store.updateAll('post', { author_id: 1234 }, { status: 'published' }).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.filter('posts', { author_id: 1234 })); }); updateMany(name, records, opts) Wrapper for Mapper#updateMany. Adds the updated Records to the store. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; Passed to Mapper#updateMany. opts Object &lt;optional&gt; Passed to Mapper#updateMany. See Mapper#updateMany for more configuration options. Fires: SimpleStore#event:beforeUpdateMany SimpleStore#event:afterUpdateMany SimpleStore#event:add Return value: Type Description Promise Resolves with the result of the update. Details Since Source Overrides 3.0.0 SimpleStore.js, line 1857 Container#updateMany Example import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post [{\"id\":3,status\":\"published\"},{\"id\":4,status\":\"published\"}] store.updateMany('post', [ { id: 3, status: 'published' }, { id: 4, status: 'published' } ]).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.getAll('post', 3, 4)); }); import { SimpleStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const store = new SimpleStore(); store.registerAdapter('http', new HttpAdapter(), { default: true }); store.defineMapper('post'); // Since this example uses the http adapter, we'll get something like: // // PUT /post [{\"id\":3,status\":\"published\"},{\"id\":4,status\":\"published\"}] store.updateMany('post', [ { id: 3, status: 'published' }, { id: 4, status: 'published' } ]).then((posts) =&gt; { // The post records have also been updated in the in-memory store console.log(store.getAll('post', 3, 4)); }); validate(name, records, opts) Wrapper for Mapper#validate. Method parameters: Name Type Argument Description name String Name of the Mapper to target. records Array.&lt;Object&gt; | Array.&lt;Record&gt; See Mapper#validate. opts Object &lt;optional&gt; See Mapper#validate. Return value: Type Description Promise See Mapper#validate. Details Since Source See 3.0.0 Container.js, line 881 Mapper#validate Inherited From: Container#validate Example import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] import { Container } from 'js-data'; const store = new Container(); store.defineMapper('post', { schema: { properties: { name: { type: 'string' }, id: { type: 'string' } } } }); let errors = store.validate('post', { name: 'John' }); console.log(errors); // undefined errors = store.validate('post', { name: 123 }); console.log(errors); // [{ expected: 'one of (string)', actual: 'number', path: 'name' }] Type Definitions addListener(name, The) Callback signature for the SimpleStore#event:add event. Method parameters: Name Type Description name String The name of the associated Mapper. The Record | Array.&lt;Record&gt; Record or Records that were added. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1949 SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany Example function onAdd (mapperName, recordOrRecords) { // do something } store.on('add', onAdd); function onAdd (mapperName, recordOrRecords) { // do something } store.on('add', onAdd); afterCreateListener(name, props, opts, result) Callback signature for the SimpleStore#event:afterCreate event. Method parameters: Name Type Description name String The name argument received by Mapper#afterCreate. props Object The props argument received by Mapper#afterCreate. opts Object The opts argument received by Mapper#afterCreate. result Object The result argument received by Mapper#afterCreate. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 785 SimpleStore#event:afterCreate SimpleStore#create Example function onAfterCreate (mapperName, props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); function onAfterCreate (mapperName, props, opts, result) { // do something } store.on('afterCreate', onAfterCreate); afterCreateManyListener(name, records, opts, result) Callback signature for the SimpleStore#event:afterCreateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#afterCreateMany. records Object The records argument received by Mapper#afterCreateMany. opts Object The opts argument received by Mapper#afterCreateMany. result Object The result argument received by Mapper#afterCreateMany. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 877 SimpleStore#event:afterCreateMany SimpleStore#createMany Example function onAfterCreateMany (mapperName, records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); function onAfterCreateMany (mapperName, records, opts, result) { // do something } store.on('afterCreateMany', onAfterCreateMany); afterDestroyAllListener(name, query, opts, result) Callback signature for the SimpleStore#event:afterDestroyAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterDestroyAll. query Object The query argument received by Mapper#afterDestroyAll. opts Object The opts argument received by Mapper#afterDestroyAll. result Object The result argument received by Mapper#afterDestroyAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1128 SimpleStore#event:afterDestroyAll SimpleStore#destroyAll Example function onAfterDestroyAll (mapperName, query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); function onAfterDestroyAll (mapperName, query, opts, result) { // do something } store.on('afterDestroyAll', onAfterDestroyAll); afterDestroyListener(name, id, opts, result) Callback signature for the SimpleStore#event:afterDestroy event. Method parameters: Name Type Description name String The name argument received by Mapper#afterDestroy. id String | Number The id argument received by Mapper#afterDestroy. opts Object The opts argument received by Mapper#afterDestroy. result Object The result argument received by Mapper#afterDestroy. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1021 SimpleStore#event:afterDestroy SimpleStore#destroy Example function onAfterDestroy (mapperName, id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); function onAfterDestroy (mapperName, id, opts, result) { // do something } store.on('afterDestroy', onAfterDestroy); afterFindAllListener(name, query, opts, result) Callback signature for the SimpleStore#event:afterFindAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterFindAll. query Object The query argument received by Mapper#afterFindAll. opts Object The opts argument received by Mapper#afterFindAll. result Object The result argument received by Mapper#afterFindAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1356 SimpleStore#event:afterFindAll SimpleStore#findAll Example function onAfterFindAll (mapperName, query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); function onAfterFindAll (mapperName, query, opts, result) { // do something } store.on('afterFindAll', onAfterFindAll); afterFindListener(name, id, opts, result) Callback signature for the SimpleStore#event:afterFind event. Method parameters: Name Type Description name String The name argument received by Mapper#afterFind. id String | Number The id argument received by Mapper#afterFind. opts Object The opts argument received by Mapper#afterFind. result Object The result argument received by Mapper#afterFind. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1244 SimpleStore#event:afterFind SimpleStore#find Example function onAfterFind (mapperName, id, opts, result) { // do something } store.on('afterFind', onAfterFind); function onAfterFind (mapperName, id, opts, result) { // do something } store.on('afterFind', onAfterFind); afterUpdateAllListener(name, props, query, opts, result) Callback signature for the SimpleStore#event:afterUpdateAll event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdateAll. props Object The props argument received by Mapper#afterUpdateAll. query Object The query argument received by Mapper#afterUpdateAll. opts Object The opts argument received by Mapper#afterUpdateAll. result Object The result argument received by Mapper#afterUpdateAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1748 SimpleStore#event:afterUpdateAll SimpleStore#updateAll Example function onAfterUpdateAll (mapperName, props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); function onAfterUpdateAll (mapperName, props, query, opts, result) { // do something } store.on('afterUpdateAll', onAfterUpdateAll); afterUpdateListener(name, id, props, opts, result) Callback signature for the SimpleStore#event:afterUpdate event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdate. id String | Number The id argument received by Mapper#afterUpdate. props Object The props argument received by Mapper#afterUpdate. opts Object The opts argument received by Mapper#afterUpdate. result Object The result argument received by Mapper#afterUpdate. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1656 SimpleStore#event:afterUpdate SimpleStore#update Example function onAfterUpdate (mapperName, id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); function onAfterUpdate (mapperName, id, props, opts, result) { // do something } store.on('afterUpdate', onAfterUpdate); afterUpdateManyListener(name, records, opts, result) Callback signature for the SimpleStore#event:afterUpdateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#afterUpdateMany. records Object The records argument received by Mapper#afterUpdateMany. opts Object The opts argument received by Mapper#afterUpdateMany. result Object The result argument received by Mapper#afterUpdateMany. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1839 SimpleStore#event:afterUpdateMany SimpleStore#updateMany Example function onAfterUpdateMany (mapperName, records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); function onAfterUpdateMany (mapperName, records, opts, result) { // do something } store.on('afterUpdateMany', onAfterUpdateMany); beforeCreateListener(name, props, opts) Callback signature for the SimpleStore#event:beforeCreate event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeCreate. props Object The props argument received by Mapper#beforeCreate. opts Object The opts argument received by Mapper#beforeCreate. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 760 SimpleStore#event:beforeCreate SimpleStore#create Example function onBeforeCreate (mapperName, props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); function onBeforeCreate (mapperName, props, opts) { // do something } store.on('beforeCreate', onBeforeCreate); beforeCreateManyListener(name, records, opts) Callback signature for the SimpleStore#event:beforeCreateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeCreateMany. records Object The records argument received by Mapper#beforeCreateMany. opts Object The opts argument received by Mapper#beforeCreateMany. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 852 SimpleStore#event:beforeCreateMany SimpleStore#createMany Example function onBeforeCreateMany (mapperName, records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); function onBeforeCreateMany (mapperName, records, opts) { // do something } store.on('beforeCreateMany', onBeforeCreateMany); beforeDestroyAllListener(name, query, opts) Callback signature for the SimpleStore#event:beforeDestroyAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeDestroyAll. query Object The query argument received by Mapper#beforeDestroyAll. opts Object The opts argument received by Mapper#beforeDestroyAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1103 SimpleStore#event:beforeDestroyAll SimpleStore#destroyAll Example function onBeforeDestroyAll (mapperName, query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); function onBeforeDestroyAll (mapperName, query, opts) { // do something } store.on('beforeDestroyAll', onBeforeDestroyAll); beforeDestroyListener(name, id, opts) Callback signature for the SimpleStore#event:beforeDestroy event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeDestroy. id String | Number The id argument received by Mapper#beforeDestroy. opts Object The opts argument received by Mapper#beforeDestroy. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 996 SimpleStore#event:beforeDestroy SimpleStore#destroy Example function onBeforeDestroy (mapperName, id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); function onBeforeDestroy (mapperName, id, opts) { // do something } store.on('beforeDestroy', onBeforeDestroy); beforeFindAllListener(name, query, opts) Callback signature for the SimpleStore#event:beforeFindAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeFindAll. query Object The query argument received by Mapper#beforeFindAll. opts Object The opts argument received by Mapper#beforeFindAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1331 SimpleStore#event:beforeFindAll SimpleStore#findAll Example function onBeforeFindAll (mapperName, query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); function onBeforeFindAll (mapperName, query, opts) { // do something } store.on('beforeFindAll', onBeforeFindAll); beforeFindListener(name, id, opts) Callback signature for the SimpleStore#event:beforeFind event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeFind. id String | Number The id argument received by Mapper#beforeFind. opts Object The opts argument received by Mapper#beforeFind. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1219 SimpleStore#event:beforeFind SimpleStore#find Example function onBeforeFind (mapperName, id, opts) { // do something } store.on('beforeFind', onBeforeFind); function onBeforeFind (mapperName, id, opts) { // do something } store.on('beforeFind', onBeforeFind); beforeUpdateAllListener(name, props, query, opts) Callback signature for the SimpleStore#event:beforeUpdateAll event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdateAll. props Object The props argument received by Mapper#beforeUpdateAll. query Object The query argument received by Mapper#beforeUpdateAll. opts Object The opts argument received by Mapper#beforeUpdateAll. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1722 SimpleStore#event:beforeUpdateAll SimpleStore#updateAll Example function onBeforeUpdateAll (mapperName, props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); function onBeforeUpdateAll (mapperName, props, query, opts) { // do something } store.on('beforeUpdateAll', onBeforeUpdateAll); beforeUpdateListener(name, id, props, opts) Callback signature for the SimpleStore#event:beforeUpdate event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdate. id String | Number The id argument received by Mapper#beforeUpdate. props Object The props argument received by Mapper#beforeUpdate. opts Object The opts argument received by Mapper#beforeUpdate. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1630 SimpleStore#event:beforeUpdate SimpleStore#update Example function onBeforeUpdate (mapperName, id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); function onBeforeUpdate (mapperName, id, props, opts) { // do something } store.on('beforeUpdate', onBeforeUpdate); beforeUpdateManyListener(name, records, opts) Callback signature for the SimpleStore#event:beforeUpdateMany event. Method parameters: Name Type Description name String The name argument received by Mapper#beforeUpdateMany. records Object The records argument received by Mapper#beforeUpdateMany. opts Object The opts argument received by Mapper#beforeUpdateMany. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1814 SimpleStore#event:beforeUpdateMany SimpleStore#updateMany Example function onBeforeUpdateMany (mapperName, records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); function onBeforeUpdateMany (mapperName, records, opts) { // do something } store.on('beforeUpdateMany', onBeforeUpdateMany); changeListener(name, record, changes) Callback signature for the SimpleStore#event:change event. Method parameters: Name Type Description name String The name of the associated Mapper. record Record The Record that changed. changes Object The changes. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1915 SimpleStore#event:change Example function onChange (mapperName, record, changes) { // do something } store.on('change', onChange); function onChange (mapperName, record, changes) { // do something } store.on('change', onChange); removeListener(name, Record) Callback signature for the SimpleStore#event:remove event. Method parameters: Name Type Description name String The name of the associated Mapper. Record Record | Array.&lt;Record&gt; or Records that were removed. Details Type Since Source See Function 3.0.0 SimpleStore.js, line 1987 SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll Example function onRemove (mapperName, recordsOrRecords) { // do something } store.on('remove', onRemove); function onRemove (mapperName, recordsOrRecords) { // do something } store.on('remove', onRemove); Events add Fired when one or more records are added to the in-memory store. See SimpleStore~addListener on how to listen for this event. Details Source See SimpleStore.js, line 1932 SimpleStore~addListener SimpleStore#event:add SimpleStore#add SimpleStore#create SimpleStore#createMany SimpleStore#find SimpleStore#findAll SimpleStore#update SimpleStore#updateAll SimpleStore#updateMany afterCreate Fired during SimpleStore#create. See SimpleStore~afterCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 777 Container#event:afterCreate SimpleStore~afterCreateListener SimpleStore#create afterCreateMany Fired during SimpleStore#createMany. See SimpleStore~afterCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 869 Container#event:afterCreateMany SimpleStore~afterCreateManyListener SimpleStore#createMany afterDestroy Fired during SimpleStore#destroy. See SimpleStore~afterDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1013 Container#event:afterDestroy SimpleStore~afterDestroyListener SimpleStore#destroy afterDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~afterDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1120 Container#event:afterDestroyAll SimpleStore~afterDestroyAllListener SimpleStore#destroyAll afterFind Fired during SimpleStore#find. See SimpleStore~afterFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1236 Container#event:afterFind SimpleStore~afterFindListener SimpleStore#find afterFindAll Fired during SimpleStore#findAll. See SimpleStore~afterFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1348 Container#event:afterFindAll SimpleStore~afterFindAllListener SimpleStore#findAll afterUpdate Fired during SimpleStore#update. See SimpleStore~afterUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1648 Container#event:afterUpdate SimpleStore~afterUpdateListener SimpleStore#update afterUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~afterUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1740 Container#event:afterUpdateAll SimpleStore~afterUpdateAllListener SimpleStore#updateAll afterUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~afterUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1831 Container#event:afterUpdateMany SimpleStore~afterUpdateManyListener SimpleStore#updateMany beforeCreate Fired during SimpleStore#create. See SimpleStore~beforeCreateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 752 Container#event:beforeCreate SimpleStore~beforeCreateListener SimpleStore#create beforeCreateMany Fired during SimpleStore#createMany. See SimpleStore~beforeCreateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 844 Container#event:beforeCreateMany SimpleStore~beforeCreateManyListener SimpleStore#createMany beforeDestroy Fired during SimpleStore#destroy. See SimpleStore~beforeDestroyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 988 Container#event:beforeDestroy SimpleStore~beforeDestroyListener SimpleStore#destroy beforeDestroyAll Fired during SimpleStore#destroyAll. See SimpleStore~beforeDestroyAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1095 Container#event:beforeDestroyAll SimpleStore~beforeDestroyAllListener SimpleStore#destroyAll beforeFind Fired during SimpleStore#find. See SimpleStore~beforeFindListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1211 Container#event:beforeFind SimpleStore~beforeFindListener SimpleStore#find beforeFindAll Fired during SimpleStore#findAll. See SimpleStore~beforeFindAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1323 Container#event:beforeFindAll SimpleStore~beforeFindAllListener SimpleStore#findAll beforeUpdate Fired during SimpleStore#update. See SimpleStore~beforeUpdateListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1622 Container#event:beforeUpdate SimpleStore~beforeUpdateListener SimpleStore#update beforeUpdateAll Fired during SimpleStore#updateAll. See SimpleStore~beforeUpdateAllListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1714 Container#event:beforeUpdateAll SimpleStore~beforeUpdateAllListener SimpleStore#updateAll beforeUpdateMany Fired during SimpleStore#updateMany. See SimpleStore~beforeUpdateManyListener for how to listen for this event. Details Source Overrides See SimpleStore.js, line 1806 Container#event:beforeUpdateMany SimpleStore~beforeUpdateManyListener SimpleStore#updateMany change Fired when a record changes. Only works for records that have tracked fields. See SimpleStore~changeListener on how to listen for this event. Details Source See SimpleStore.js, line 1907 SimpleStore~changeListener remove Fired when one or more records are removed from the in-memory store. See SimpleStore~removeListener for how to listen for this event. Details Source See SimpleStore.js, line 1973 SimpleStore~removeListener SimpleStore#event:remove SimpleStore#clear SimpleStore#destroy SimpleStore#destroyAll SimpleStore#remove SimpleStore#removeAll × Search results Close api.js-data.io • js-data.io "},"utils.html":{"id":"utils.html","title":"Namespace: utils","body":" js-data Namespaces queryutils Modules js-data Classes CollectionComponentContainerDataStoreLinkedCollectionMapperQueryRecordSchemaSettableSimpleStore Events Collection#event:addCollection#event:changeCollection#event:removeContainer#event:afterCreateContainer#event:afterCreateManyContainer#event:afterDestroyContainer#event:afterDestroyAllContainer#event:afterFindContainer#event:afterFindAllContainer#event:afterUpdateContainer#event:afterUpdateAllContainer#event:afterUpdateManyContainer#event:beforeCreateContainer#event:beforeCreateManyContainer#event:beforeDestroyContainer#event:beforeDestroyAllContainer#event:beforeFindContainer#event:beforeFindAllContainer#event:beforeUpdateContainer#event:beforeUpdateAllContainer#event:beforeUpdateManyDataStore#event:addDataStore#event:afterCreateDataStore#event:afterCreateManyDataStore#event:afterDestroyDataStore#event:afterDestroyAllDataStore#event:afterFindDataStore#event:afterFindAllDataStore#event:afterUpdateDataStore#event:afterUpdateAllDataStore#event:afterUpdateManyDataStore#event:beforeCreateDataStore#event:beforeCreateManyDataStore#event:beforeDestroyDataStore#event:beforeDestroyAllDataStore#event:beforeFindDataStore#event:beforeFindAllDataStore#event:beforeUpdateDataStore#event:beforeUpdateAllDataStore#event:beforeUpdateManyDataStore#event:changeDataStore#event:removeLinkedCollection#event:addLinkedCollection#event:changeLinkedCollection#event:removeMapper#event:afterCreateMapper#event:afterCreateManyMapper#event:afterDestroyMapper#event:afterDestroyAllMapper#event:afterFindMapper#event:afterFindAllMapper#event:afterUpdateMapper#event:afterUpdateAllMapper#event:afterUpdateManyMapper#event:beforeCreateMapper#event:beforeCreateManyMapper#event:beforeDestroyMapper#event:beforeDestroyAllMapper#event:beforeFindMapper#event:beforeFindAllMapper#event:beforeUpdateMapper#event:beforeUpdateAllMapper#event:beforeUpdateManyRecord#event:changeSimpleStore#event:addSimpleStore#event:afterCreateSimpleStore#event:afterCreateManySimpleStore#event:afterDestroySimpleStore#event:afterDestroyAllSimpleStore#event:afterFindSimpleStore#event:afterFindAllSimpleStore#event:afterUpdateSimpleStore#event:afterUpdateAllSimpleStore#event:afterUpdateManySimpleStore#event:beforeCreateSimpleStore#event:beforeCreateManySimpleStore#event:beforeDestroySimpleStore#event:beforeDestroyAllSimpleStore#event:beforeFindSimpleStore#event:beforeFindAllSimpleStore#event:beforeUpdateSimpleStore#event:beforeUpdateAllSimpleStore#event:beforeUpdateManySimpleStore#event:changeSimpleStore#event:remove Global _createOrAssignChildRecordIfRequired_createParentRecordIfRequired Namespace: utils utils Utility methods used by JSData. Details Type Source Object utils.js, line 1 Example import { utils } from 'js-data'; console.log(utils.isString('foo')); // true import { utils } from 'js-data'; console.log(utils.isString('foo')); // true Members &lt;static&gt; Promise Reference to the Promise constructor used by JSData. Defaults to window.Promise or global.Promise. Details Type Since Source Function 3.0.0 utils.js, line 74 Example Try it out import Promise from 'bluebird'; import { utils } from 'js-data'; utils.Promise = Promise; import Promise from 'bluebird'; import { utils } from 'js-data'; utils.Promise = Promise; Methods &lt;static&gt; addHiddenPropsToTarget(target, props) Define hidden (non-enumerable), writable properties on target from the provided props. Method parameters: Name Type Description target Object That to which props should be added. props Object Properties to be added to target. Details Since Source 3.0.0 utils.js, line 191 Example import { utils } from 'js-data'; function Cat () {} utils.addHiddenPropsToTarget(Cat.prototype, { say () { console.log('meow'); } }); const cat = new Cat(); cat.say(); // \"meow\" import { utils } from 'js-data'; function Cat () {} utils.addHiddenPropsToTarget(Cat.prototype, { say () { console.log('meow'); } }); const cat = new Cat(); cat.say(); // \"meow\" &lt;static&gt; areDifferent(a, b, opts) Return whether the two objects are deeply different. Method parameters: Name Type Argument Description a Object Base object. b Object Comparison object. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Boolean Whether the two objects are deeply different. Details Since Source See 3.0.0 utils.js, line 222 utils.diffObjects Example import { utils } from 'js-data'; utils.areDifferent({}, {}); // false utils.areDifferent({ a: 1 }, { a: 1 }); // false utils.areDifferent({ foo: 'bar' }, {}); // true import { utils } from 'js-data'; utils.areDifferent({}, {}); // false utils.areDifferent({ a: 1 }, { a: 1 }); // false utils.areDifferent({ foo: 'bar' }, {}); // true &lt;static&gt; classCallCheck(instance, ctor) Verified that the given constructor is being invoked via new, as opposed to just being called like a normal function. Method parameters: Name Type Description instance * Instance that is being constructed. ctor Constructor Constructor function used to construct the instance. Throws: Throws an error if the constructor is being improperly invoked. Type Error Details Since Source 3.0.0 utils.js, line 251 Example import { utils } from 'js-data'; function Cat () { utils.classCallCheck(this, Cat); } const cat = new Cat(); // this is ok Cat(); // this throws an error import { utils } from 'js-data'; function Cat () { utils.classCallCheck(this, Cat); } const cat = new Cat(); // this is ok Cat(); // this throws an error &lt;static&gt; copy(from, to, stackFrom, stackTo, blacklist, plain) Deep copy a value. Method parameters: Name Type Argument Description from * Value to deep copy. to * &lt;optional&gt; Destination object for the copy operation. stackFrom * &lt;optional&gt; For internal use. stackTo * &lt;optional&gt; For internal use. blacklist Array.&lt;String&gt; | Array.&lt;RegExp&gt; &lt;optional&gt; List of strings or RegExp of properties to skip. plain Boolean &lt;optional&gt; Whether to make a plain copy (don't try to use original prototype). Return value: Type Description * Deep copy of from. Details Since Source 3.0.0 utils.js, line 298 Example import { utils } from 'js-data'; const a = { foo: { bar: 'baz' } }; const b = utils.copy(a); a === b; // false utils.areDifferent(a, b); // false import { utils } from 'js-data'; const a = { foo: { bar: 'baz' } }; const b = utils.copy(a); a === b; // false utils.areDifferent(a, b); // false &lt;static&gt; deepEqual(a, b) Check whether the two provided objects are deeply equal. Method parameters: Name Type Description a Object First object in the comparison. b Object Second object in the comparison. Return value: Type Description Boolean Whether the two provided objects are deeply equal. Details Since Source See 3.0.0 utils.js, line 1520 utils.equal Example import { utils } from 'js-data'; const objA = { name: 'John', id: 27, nested: { item: 'item 1', colors: ['red', 'green', 'blue'] } }; const objB = { name: 'John', id: 27, nested: { item: 'item 1', colors: ['red', 'green', 'blue'] } }; console.log(utils.deepEqual(a,b)); // true objB.nested.colors.add('yellow'); // make a change to a nested object's array console.log(utils.deepEqual(a,b)); // false import { utils } from 'js-data'; const objA = { name: 'John', id: 27, nested: { item: 'item 1', colors: ['red', 'green', 'blue'] } }; const objB = { name: 'John', id: 27, nested: { item: 'item 1', colors: ['red', 'green', 'blue'] } }; console.log(utils.deepEqual(a,b)); // true objB.nested.colors.add('yellow'); // make a change to a nested object's array console.log(utils.deepEqual(a,b)); // false &lt;static&gt; deepFillIn(dest, source) Recursively shallow fill in own enumerable properties from source to dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 397 utils.fillIn utils.deepMixIn Example import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; const b = { beep: 'bip' }; utils.deepFillIn(b, a); console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"bip\"} import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; const b = { beep: 'bip' }; utils.deepFillIn(b, a); console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"bip\"} &lt;static&gt; deepMixIn(dest, source) Recursively shallow copy enumerable properties from source to dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 429 utils.fillIn utils.deepFillIn Example import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; const b = { beep: 'bip' }; utils.deepFillIn(b, a); console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"boop\"} import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; const b = { beep: 'bip' }; utils.deepFillIn(b, a); console.log(b); // {\"foo\":{\"bar\":\"baz\"},\"beep\":\"boop\"} &lt;static&gt; diffObjects(newObject, oldObject, opts) Return a diff of the base object to the comparison object. Method parameters: Name Type Argument Description newObject Object Comparison object. oldObject Object Base object. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description equalsFn Function &lt;optional&gt; utils.deepEqual Equality function. ignore Array &lt;optional&gt; [] Array of strings or RegExp of fields to ignore. Return value: Type Description Object The diff from the base object to the comparison object. Details Since Source See 3.0.0 utils.js, line 461 utils.areDifferent Example import { utils } from 'js-data'; const oldObject = { foo: 'bar', a: 1234 }; const newObject = { beep: 'boop', a: 5678 }; const diff = utils.diffObjects(oldObject, newObject); console.log(diff.added); // {\"beep\":\"boop\"} console.log(diff.changed); // {\"a\":5678} console.log(diff.removed); // {\"foo\":undefined} import { utils } from 'js-data'; const oldObject = { foo: 'bar', a: 1234 }; const newObject = { beep: 'boop', a: 5678 }; const diff = utils.diffObjects(oldObject, newObject); console.log(diff.added); // {\"beep\":\"boop\"} console.log(diff.changed); // {\"a\":5678} console.log(diff.removed); // {\"foo\":undefined} &lt;static&gt; equal(a, b) Return whether the two values are equal according to the == operator. Method parameters: Name Type Description a * First value in the comparison. b * Second value in the comparison. Return value: Type Description Boolean Whether the two values are equal according to ==. Details Since Source 3.0.0 utils.js, line 529 Example import { utils } from 'js-data'; console.log(utils.equal(1,1)); // true console.log(utils.equal(1,'1')); // true console.log(utils.equal(93, 66)); // false import { utils } from 'js-data'; console.log(utils.equal(1,1)); // true console.log(utils.equal(1,'1')); // true console.log(utils.equal(93, 66)); // false &lt;static&gt; err(domain, target) Produce a factory function for making Error objects with the provided metadata. Used throughout the various js-data components. Method parameters: Name Type Description domain String Namespace. target String Target. Return value: Type Description Function Factory function. Details Since Source 3.0.0 utils.js, line 548 Example import { utils } from 'js-data'; const errorFactory = utils.err('domain', 'target'); const error400 = errorFactory(400, 'expected type', 'actual type'); console.log(error400); // [Error: [domain:target] expected: expected type, found: string http://www.js-data.io/v3.0/docs/errors#400] import { utils } from 'js-data'; const errorFactory = utils.err('domain', 'target'); const error400 = errorFactory(400, 'expected type', 'actual type'); console.log(error400); // [Error: [domain:target] expected: expected type, found: string http://www.js-data.io/v3.0/docs/errors#400] &lt;static&gt; eventify(target, getter, setter) Add eventing capabilities into the target object. Method parameters: Name Type Argument Description target Object Target object. getter Function &lt;optional&gt; Custom getter for retrieving the object's event listeners. setter Function &lt;optional&gt; Custom setter for setting the object's event listeners. Details Since Source 3.0.0 utils.js, line 577 Example import { utils } from 'js-data'; const user = { name: 'John' }; utils.eventify(user); user.on('foo', () =&gt; console.log(arguments)); user.emit('foo', 1, 'bar'); // should log to console values (1, \"bar\") import { utils } from 'js-data'; const user = { name: 'John' }; utils.eventify(user); user.on('foo', () =&gt; console.log(arguments)); user.emit('foo', 1, 'bar'); // should log to console values (1, \"bar\") &lt;static&gt; extend(props, props) Used for sublcassing. Invoke this method in the context of a superclass to to produce a subclass based on props and classProps. Method parameters: Name Type Description props Object Instance properties for the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to use as the subclass. props Object Static properties for the subclass. Return value: Type Description Constructor A new subclass. Details Since Source 3.0.0 utils.js, line 657 Example import { utils } from 'js-data'; function Animal () {} Animal.extend = utils.extend; const Cat = Animal.extend({ say () { console.log('meow'); } }); const cat = new Cat(); cat instanceof Animal; // true cat instanceof Cat; // true cat.say(); // \"meow\" import { utils } from 'js-data'; function Animal () {} Animal.extend = utils.extend; const Cat = Animal.extend({ say () { console.log('meow'); } }); const cat = new Cat(); cat instanceof Animal; // true cat instanceof Cat; // true cat.say(); // \"meow\" &lt;static&gt; fillIn(dest, source) Shallow copy own enumerable properties from src to dest that are on src but are missing from `dest. Method parameters: Name Type Description dest Object The destination object. source Object The source object. Details Since Source See 3.0.0 utils.js, line 734 utils.deepFillIn utils.deepMixIn Example import { utils } from 'js-data'; const a = { foo: 'bar', beep: 'boop' }; const b = { beep: 'bip' }; utils.fillIn(b, a); console.log(b); // {\"foo\":\"bar\",\"beep\":\"bip\"} import { utils } from 'js-data'; const a = { foo: 'bar', beep: 'boop' }; const b = { beep: 'bip' }; utils.fillIn(b, a); console.log(b); // {\"foo\":\"bar\",\"beep\":\"bip\"} &lt;static&gt; findIndex(array, fn) Find the last index of an item in an array according to the given checker function. Method parameters: Name Type Description array Array The array to search. fn Function Checker function. Return value: Type Description Number Index if found or -1 if not found. Details Since Source 3.0.0 utils.js, line 760 Example import { utils } from 'js-data'; const john = { name: 'John', age: 20 }; const sara = { name: 'Sara', age: 25 }; const dan = { name: 'Dan', age: 20 }; const users = [john, sara, dan]; console.log(utils.findIndex(users, (user) =&gt; user.age === 25)); // 1 console.log(utils.findIndex(users, (user) =&gt; user.age &gt; 19)); // 2 console.log(utils.findIndex(users, (user) =&gt; user.name === 'John')); // 0 console.log(utils.findIndex(users, (user) =&gt; user.name === 'Jimmy')); // -1 import { utils } from 'js-data'; const john = { name: 'John', age: 20 }; const sara = { name: 'Sara', age: 25 }; const dan = { name: 'Dan', age: 20 }; const users = [john, sara, dan]; console.log(utils.findIndex(users, (user) =&gt; user.age === 25)); // 1 console.log(utils.findIndex(users, (user) =&gt; user.age &gt; 19)); // 2 console.log(utils.findIndex(users, (user) =&gt; user.name === 'John')); // 0 console.log(utils.findIndex(users, (user) =&gt; user.name === 'Jimmy')); // -1 &lt;static&gt; forEachRelation(mapper, opts, fn, thisArg) Recursively iterate over a Mapper's relations according to opts.with. Method parameters: Name Type Description mapper Mapper Mapper. opts Object Configuration options. fn Function Callback function. thisArg * Execution context for the callback function. Details Since Source 3.0.0 utils.js, line 796 &lt;static&gt; forOwn(object, fn, thisArg) Iterate over an object's own enumerable properties. Method parameters: Name Type Argument Description object Object The object whose properties are to be enumerated. fn Function Iteration function. thisArg Object &lt;optional&gt; Content to which to bind fn. Details Since Source 3.0.0 utils.js, line 817 Example import { utils } from 'js-data'; const a = { b: 1, c: 4 }; let sum = 0; utils.forOwn(a, function (value, key) { sum += value; }); console.log(sum); // 5 import { utils } from 'js-data'; const a = { b: 1, c: 4 }; let sum = 0; utils.forOwn(a, function (value, key) { sum += value; }); console.log(sum); // 5 &lt;static&gt; fromJson(json) Proxy for JSON.parse. Method parameters: Name Type Description json String JSON to parse. Return value: Type Description Object Parsed object. Details Since Source See 3.0.0 utils.js, line 846 utils.toJson Example import { utils } from 'js-data'; const a = utils.fromJson('{\"name\" : \"John\"}'); console.log(a); // { name: 'John' } import { utils } from 'js-data'; const a = utils.fromJson('{\"name\" : \"John\"}'); console.log(a); // { name: 'John' } &lt;static&gt; get(object, prop) Retrieve the specified property from the given object. Supports retrieving nested properties. Method parameters: Name Type Description object Object Object from which to retrieve a property's value. prop String Property to retrieve. Return value: Type Description * Value of the specified property. Details Since Source See 3.0.0 utils.js, line 865 utils.set Example import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; console.log(utils.get(a, 'beep')); // \"boop\" console.log(utils.get(a, 'foo.bar')); // \"baz\" import { utils } from 'js-data'; const a = { foo: { bar: 'baz' }, beep: 'boop' }; console.log(utils.get(a, 'beep')); // \"boop\" console.log(utils.get(a, 'foo.bar')); // \"baz\" &lt;static&gt; getSuper(instance, isCtor) Return the superclass for the given instance or subclass. If an instance is provided, then finds the parent class of the instance's constructor. Method parameters: Name Type Argument Default Description instance Object | Function Instance or constructor. isCtor Boolean &lt;optional&gt; false Whether instance is a constructor. Return value: Type Description Constructor The superclass (grandparent constructor). Details Since Source 3.0.0 utils.js, line 901 Example import { utils } from 'js-data'; // using ES2015 classes class Foo {} class Bar extends Foo {} const barInstance = new Bar(); let baseType = utils.getSuper(barInstance); console.log(Foo === baseType); // true // using Function constructor with utils.extend function Foo () {} Foo.extend = utils.extend; const Bar = Foo.extend(); const barInstance = new Bar(); let baseType = utils.getSuper(barInstance); console.log(Foo === baseType); // true import { utils } from 'js-data'; // using ES2015 classes class Foo {} class Bar extends Foo {} const barInstance = new Bar(); let baseType = utils.getSuper(barInstance); console.log(Foo === baseType); // true // using Function constructor with utils.extend function Foo () {} Foo.extend = utils.extend; const Bar = Foo.extend(); const barInstance = new Bar(); let baseType = utils.getSuper(barInstance); console.log(Foo === baseType); // true &lt;static&gt; intersection(array1, array2) Return the intersection of two arrays. Method parameters: Name Type Description array1 Array First array. array2 Array Second array. Return value: Type Description Array Array of elements common to both arrays. Details Since Source 3.0.0 utils.js, line 936 Example import { utils } from 'js-data'; const arrA = ['green', 'red', 'blue', 'red']; const arrB = ['green', 'yellow', 'red']; const intersected = utils.intersection(arrA, arrB); console.log(intersected); // ['green', 'red']) import { utils } from 'js-data'; const arrA = ['green', 'red', 'blue', 'red']; const arrB = ['green', 'yellow', 'red']; const intersected = utils.intersection(arrA, arrB); console.log(intersected); // ['green', 'red']) &lt;static&gt; isArray(value) Proxy for Array.isArray. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an array. Details Since Source 3.0.0 utils.js, line 975 Example import { utils } from 'js-data'; const a = [1,2,3,4,5]; const b = { foo: \"bar\" }; console.log(utils.isArray(a)); // true console.log(utils.isArray(b)); // false import { utils } from 'js-data'; const a = [1,2,3,4,5]; const b = { foo: \"bar\" }; console.log(utils.isArray(a)); // true console.log(utils.isArray(b)); // false &lt;static&gt; isBlacklisted(prop, blacklist) Return whether prop is matched by any string or regular expression in blacklist. Method parameters: Name Type Description prop String The name of a property to check. blacklist Array Array of strings and regular expressions. Return value: Type Description Boolean Whether prop was matched. Details Since Source 3.0.0 utils.js, line 992 Example import { utils } from 'js-data'; const blacklist = [/^\\$hashKey/g, /^_/g, 'id']; console.log(utils.isBlacklisted(\"$hashKey\", blacklist)); // true console.log(utils.isBlacklisted(\"id\", blacklist)); // true console.log(utils.isBlacklisted(\"_myProp\", blacklist)); // true console.log(utils.isBlacklisted(\"my_id\", blacklist)); // false import { utils } from 'js-data'; const blacklist = [/^\\$hashKey/g, /^_/g, 'id']; console.log(utils.isBlacklisted(\"$hashKey\", blacklist)); // true console.log(utils.isBlacklisted(\"id\", blacklist)); // true console.log(utils.isBlacklisted(\"_myProp\", blacklist)); // true console.log(utils.isBlacklisted(\"my_id\", blacklist)); // false &lt;static&gt; isBoolean(value) Return whether the provided value is a boolean. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a boolean. Details Since Source 3.0.0 utils.js, line 1027 Example import { utils } from 'js-data'; const a = true; const b = { foo: \"bar\" }; console.log(utils.isBoolean(a)); // true console.log(utils.isBoolean(b)); // false import { utils } from 'js-data'; const a = true; const b = { foo: \"bar\" }; console.log(utils.isBoolean(a)); // true console.log(utils.isBoolean(b)); // false &lt;static&gt; isDate(value) Return whether the provided value is a date. Method parameters: Name Type Description value * The value to test. Return value: Type Description Date Whether the provided value is a date. Details Since Source 3.0.0 utils.js, line 1046 Example import { utils } from 'js-data'; const a = new Date(); const b = { foo: \"bar\" }; console.log(utils.isDate(a)); // true console.log(utils.isDate(b)); // false import { utils } from 'js-data'; const a = new Date(); const b = { foo: \"bar\" }; console.log(utils.isDate(a)); // true console.log(utils.isDate(b)); // false &lt;static&gt; isFunction(value) Return whether the provided value is a function. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a function. Details Since Source 3.0.0 utils.js, line 1065 Example import { utils } from 'js-data'; const a = function () { console.log('foo bar'); }; const b = { foo: \"bar\" }; console.log(utils.isFunction(a)); // true console.log(utils.isFunction(b)); // false import { utils } from 'js-data'; const a = function () { console.log('foo bar'); }; const b = { foo: \"bar\" }; console.log(utils.isFunction(a)); // true console.log(utils.isFunction(b)); // false &lt;static&gt; isInteger(value) Return whether the provided value is an integer. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an integer. Details Since Source 3.0.0 utils.js, line 1084 Example import { utils } from 'js-data'; const a = 1; const b = 1.25; const c = '1'; console.log(utils.isInteger(a)); // true console.log(utils.isInteger(b)); // false console.log(utils.isInteger(c)); // false import { utils } from 'js-data'; const a = 1; const b = 1.25; const c = '1'; console.log(utils.isInteger(a)); // true console.log(utils.isInteger(b)); // false console.log(utils.isInteger(c)); // false &lt;static&gt; isNull(value) Return whether the provided value is null. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is null. Details Since Source 3.0.0 utils.js, line 1105 Example import { utils } from 'js-data'; const a = null; const b = { foo: \"bar\" }; console.log(utils.isNull(a)); // true console.log(utils.isNull(b)); // false import { utils } from 'js-data'; const a = null; const b = { foo: \"bar\" }; console.log(utils.isNull(a)); // true console.log(utils.isNull(b)); // false &lt;static&gt; isNumber(value) Return whether the provided value is a number. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a number. Details Since Source 3.0.0 utils.js, line 1124 Example import { utils } from 'js-data'; const a = 1; const b = -1.25; const c = '1'; console.log(utils.isNumber(a)); // true console.log(utils.isNumber(b)); // true console.log(utils.isNumber(c)); // false import { utils } from 'js-data'; const a = 1; const b = -1.25; const c = '1'; console.log(utils.isNumber(a)); // true console.log(utils.isNumber(b)); // true console.log(utils.isNumber(c)); // false &lt;static&gt; isObject(value) Return whether the provided value is an object. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is an object. Details Since Source 3.0.0 utils.js, line 1149 Example import { utils } from 'js-data'; const a = { foo: \"bar\" }; const b = 'foo bar'; console.log(utils.isObject(a)); // true console.log(utils.isObject(b)); // false import { utils } from 'js-data'; const a = { foo: \"bar\" }; const b = 'foo bar'; console.log(utils.isObject(a)); // true console.log(utils.isObject(b)); // false &lt;static&gt; isRegExp(value) Return whether the provided value is a regular expression. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a regular expression. Details Since Source 3.0.0 utils.js, line 1168 Example import { utils } from 'js-data'; const a = /^\\$.+$/ig; const b = new RegExp('^\\$.+$', 'ig'); const c = { foo: \"bar\" }; console.log(utils.isRegExp(a)); // true console.log(utils.isRegExp(b)); // true console.log(utils.isRegExp(c)); // false import { utils } from 'js-data'; const a = /^\\$.+$/ig; const b = new RegExp('^\\$.+$', 'ig'); const c = { foo: \"bar\" }; console.log(utils.isRegExp(a)); // true console.log(utils.isRegExp(b)); // true console.log(utils.isRegExp(c)); // false &lt;static&gt; isSorN(value) Return whether the provided value is a string or a number. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a string or a number. Details Since Source 3.0.0 utils.js, line 1189 Example import { utils } from 'js-data'; console.log(utils.isSorN('')); // true console.log(utils.isSorN(-1.65)); // true console.log(utils.isSorN('my string')); // true console.log(utils.isSorN({})); // false console.log(utils.isSorN([1,2,4])); // false import { utils } from 'js-data'; console.log(utils.isSorN('')); // true console.log(utils.isSorN(-1.65)); // true console.log(utils.isSorN('my string')); // true console.log(utils.isSorN({})); // false console.log(utils.isSorN([1,2,4])); // false &lt;static&gt; isString(value) Return whether the provided value is a string. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a string. Details Since Source 3.0.0 utils.js, line 1209 Example import { utils } from 'js-data'; console.log(utils.isString('')); // true console.log(utils.isString('my string')); // true console.log(utils.isString(100)); // false console.log(utils.isString([1,2,4])); // false import { utils } from 'js-data'; console.log(utils.isString('')); // true console.log(utils.isString('my string')); // true console.log(utils.isString(100)); // false console.log(utils.isString([1,2,4])); // false &lt;static&gt; isUndefined(value) Return whether the provided value is a undefined. Method parameters: Name Type Description value * The value to test. Return value: Type Description Boolean Whether the provided value is a undefined. Details Since Source 3.0.0 utils.js, line 1231 Example import { utils } from 'js-data'; const a = undefined; const b = { foo: \"bar\"}; console.log(utils.isUndefined(a)); // true console.log(utils.isUndefined(b.baz)); // true console.log(utils.isUndefined(b)); // false console.log(utils.isUndefined(b.foo)); // false import { utils } from 'js-data'; const a = undefined; const b = { foo: \"bar\"}; console.log(utils.isUndefined(a)); // true console.log(utils.isUndefined(b.baz)); // true console.log(utils.isUndefined(b)); // false console.log(utils.isUndefined(b.foo)); // false &lt;static&gt; logify(target) Mix in logging capabilities to the target. Method parameters: Name Type Description target * The target. Details Since Source 3.0.0 utils.js, line 1252 Example import { utils } from 'js-data'; const a = { foo: \"bar\"}; // Add standard logging to an object utils.logify(a); a.log('info', 'test log info'); // output 'test log info' to console. // Toggle debug output of an object a.dbg('test debug output'); // does not output because debug is off. a.debug = true; a.dbg('test debug output'); // output 'test debug output' to console. import { utils } from 'js-data'; const a = { foo: \"bar\"}; // Add standard logging to an object utils.logify(a); a.log('info', 'test log info'); // output 'test log info' to console. // Toggle debug output of an object a.dbg('test debug output'); // does not output because debug is off. a.debug = true; a.dbg('test debug output'); // output 'test debug output' to console. &lt;static&gt; noDupeAdd(array, record, fn) Adds the given record to the provided array only if it's not already in the array. Method parameters: Name Type Description array Array The array. record * The value to add. fn Function Callback function passed to utils.findIndex. Details Since Source 3.0.0 utils.js, line 1298 Example import { utils } from 'js-data'; const colors = ['red', 'green', 'yellow']; console.log(colors.length); // 3 utils.noDupeAdd(colors, 'red'); console.log(colors.length); // 3, red already exists utils.noDupeAdd(colors, 'blue'); console.log(colors.length); // 4, blue was added import { utils } from 'js-data'; const colors = ['red', 'green', 'yellow']; console.log(colors.length); // 3 utils.noDupeAdd(colors, 'red'); console.log(colors.length); // 3, red already exists utils.noDupeAdd(colors, 'blue'); console.log(colors.length); // 4, blue was added &lt;static&gt; omit(props, keys) Return a shallow copy of the provided object, minus the properties specified in keys. Method parameters: Name Type Description props Object The object to copy. keys Array.&lt;String&gt; Array of strings, representing properties to skip. Return value: Type Description Object Shallow copy of props, minus keys. Details Since Source 3.0.0 utils.js, line 1329 Example import { utils } from 'js-data'; const a = { name: 'John', $hashKey: 1214910 }; let b = utils.omit(a, ['$hashKey']); console.log(b); // { name: 'John' } import { utils } from 'js-data'; const a = { name: 'John', $hashKey: 1214910 }; let b = utils.omit(a, ['$hashKey']); console.log(b); // { name: 'John' } &lt;static&gt; pick(props, keys) Return a shallow copy of the provided object, but only include the properties specified in keys. Method parameters: Name Type Description props Object The object to copy. keys Array.&lt;String&gt; Array of strings, representing properties to keep. Return value: Type Description Object Shallow copy of props, but only including keys. Details Since Source 3.0.0 utils.js, line 1356 Example import { utils } from 'js-data'; const a = { name: 'John', $hashKey: 1214910 }; let b = utils.pick(a, ['$hashKey']); console.log(b); // { $hashKey: 1214910 } import { utils } from 'js-data'; const a = { name: 'John', $hashKey: 1214910 }; let b = utils.pick(a, ['$hashKey']); console.log(b); // { $hashKey: 1214910 } &lt;static&gt; plainCopy(value) Return a plain copy of the given value. Method parameters: Name Type Description value * The value to copy. Return value: Type Description * Plain copy of value. Details Since Source See 3.0.0 utils.js, line 1380 utils.copy Example import { utils } from 'js-data'; const a = { name: 'John' }; let b = utils.plainCopy(a); console.log(a === b); // false import { utils } from 'js-data'; const a = { name: 'John' }; let b = utils.plainCopy(a); console.log(a === b); // false &lt;static&gt; reject(value) Shortcut for utils.Promise.reject(value). Method parameters: Name Type Argument Description value * &lt;optional&gt; Value with which to reject the Promise. Return value: Type Description Promise Promise reject with value. Details Since Source See 3.0.0 utils.js, line 1399 utils.Promise Example import { utils } from 'js-data'; utils.reject(\"Testing static reject\").then(function (data) { // not called }).catch(function (reason) { console.log(reason); // \"Testing static reject\" }); import { utils } from 'js-data'; utils.reject(\"Testing static reject\").then(function (data) { // not called }).catch(function (reason) { console.log(reason); // \"Testing static reject\" }); &lt;static&gt; remove(array, fn) Remove the last item found in array according to the given checker function. Method parameters: Name Type Description array Array The array to search. fn Function Checker function. Details Source utils.js, line 1421 Example import { utils } from 'js-data'; const colors = ['red', 'green', 'yellow', 'red']; utils.remove(colors, (color) =&gt; color === 'red'); console.log(colors); // ['red', 'green', 'yellow'] import { utils } from 'js-data'; const colors = ['red', 'green', 'yellow', 'red']; utils.remove(colors, (color) =&gt; color === 'red'); console.log(colors); // ['red', 'green', 'yellow'] &lt;static&gt; resolve(value) Shortcut for utils.Promise.resolve(value). Method parameters: Name Type Argument Description value * &lt;optional&gt; Value with which to resolve the Promise. Return value: Type Description Promise Promise resolved with value. Details Since Source See 3.0.0 utils.js, line 1462 utils.Promise Example import { utils } from 'js-data'; utils.resolve(\"Testing static resolve\").then(function (data) { console.log(data); // \"Testing static resolve\" }).catch(function (reason) { // not called }); import { utils } from 'js-data'; utils.resolve(\"Testing static resolve\").then(function (data) { console.log(data); // \"Testing static resolve\" }).catch(function (reason) { // not called }); &lt;static&gt; set(object, path, value) Set the value at the provided key or path. Method parameters: Name Type Argument Description object Object The object on which to set a property. path String | Object The key or path to the property. Can also pass in an object of path/value pairs, which will all be set on the target object. value * &lt;optional&gt; The value to set. Details Source utils.js, line 1466 Example import { utils } from 'js-data'; const john = { name: 'John', age: 25, parent: { name: 'John's Mom', age: 50 } }; // set value by key utils.set(john, 'id', 98); console.log(john.id); // 98 // set value by path utils.set(john, 'parent.id', 20); console.log(john.parent.id); // 20 // set value by path/value map utils.set(john, { 'id': 1098, 'parent': { id: 1020 }, 'parent.age': '55' }); console.log(john.id); // 1098 console.log(john.parent.id); // 1020 console.log(john.parent.age); // 55 import { utils } from 'js-data'; const john = { name: 'John', age: 25, parent: { name: 'John's Mom', age: 50 } }; // set value by key utils.set(john, 'id', 98); console.log(john.id); // 98 // set value by path utils.set(john, 'parent.id', 20); console.log(john.parent.id); // 20 // set value by path/value map utils.set(john, { 'id': 1098, 'parent': { id: 1020 }, 'parent.age': '55' }); console.log(john.id); // 1098 console.log(john.parent.id); // 1020 console.log(john.parent.age); // 55 &lt;static&gt; toJson(value) Proxy for JSON.stringify. Method parameters: Name Type Description value * Value to serialize to JSON. Return value: Type Description String JSON string. Details Since Source See 3.0.0 utils.js, line 1591 utils.fromJson Example import { utils } from 'js-data'; const a = { name: 'John' }; let jsonVal = utils.toJson(a); console.log(jsonVal); // '{\"name\" : \"John\"}' import { utils } from 'js-data'; const a = { name: 'John' }; let jsonVal = utils.toJson(a); console.log(jsonVal); // '{\"name\" : \"John\"}' &lt;static&gt; unset(object, path) Unset the value at the provided key or path. Method parameters: Name Type Description object Object The object from which to delete the property. path String The key or path to the property. Details Since Source See 3.0.0 utils.js, line 1609 utils.set Example import { utils } from 'js-data'; const john = { name: 'John', age: 25, parent: { name: 'John's Mom', age: 50 } }; utils.unset(john, age); utils.unset(john, parent.age); console.log(john.age); // null console.log(john.parent.age); // null import { utils } from 'js-data'; const john = { name: 'John', age: 25, parent: { name: 'John's Mom', age: 50 } }; utils.unset(john, age); utils.unset(john, parent.age); console.log(john.age); // null console.log(john.parent.age); // null × Search results Close api.js-data.io • js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
